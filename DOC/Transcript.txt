Course Overview

Course Overview

Hi everyone, my name is Shawn Wildermuth, and welcome to my course Building a Web App with ASP.NET Core 1.0, MVC 6, Entity Framework Core, Bootstrap, and AngularJS. I've been doing software development for over 25 years. I'm an author, speaker, and a Microsoft MVP in ASP.NET. Running a web application with ASP.NET just got a lot more interesting. Now that ASP.NET Core is released, it is time to learn this new open source framework from Microsoft. In this course we are going to build an entire web application from soup to nuts. We'll start with a complete blank slate and end up with a small, but fully functional web application. Some of the major topics that we will cover include: why ASP.NET Core is a better way to build web applications, creating web pages with ASP.NET MVC, building APIs with ASP.NET MVC, securing your pages in APIs with ASP.NET Identity, and using AngularJS for client-side development. By the end of this course, you will know how to build your own applications with ASP.NET Core, but before you begin the course you should have basic understanding of how Visual Studio works. From here you should feel comfortable diving into ASP.NET Core with courses on Bootstrap 3, Angular 2, and even deploying apps with Docker. I hope you will join me on this journey to learn web development with the Building a Web App with ASP.NET Core 1.0, MVC 6, Entity Framework Core, Bootstrap and AngularJS course at Pluralsight.

What Is ASP.NET Core?

Introduction

Welcome to Building a Web App with ASP.NET Core, MVC 6, Entity Framework Core and Angular. My name is Shawn Wildermuth of Wilder Minds. The purpose of this course is to teach you how to build a web app using ASP.NET Core. My philosophy is that you can learn best by actually doing. This means that I'd like you to follow along with me, and you'll see me build virtually every line of code that's required to build a web app from start to finish. This course will teach you ASP.NET Core and MSV 6, HTML5, JavaScript, and CSS, how to use Bootstrap for layout, how to access data with Entity Framework Core, and how to do client-side development with AngularJS. So what is this course built with? We'll starting with Visual Studio 2015, with update three. We'll be showing Visual Studio Code, which I believe is at 1.2 at this point, but most of the course will be built directly with a full version of Visual Studio. The community edition is plenty. I'm also using the full RTM of ASP.NET Core 1.0. We're also using Entity Framework Core 1.0, Bootstrap 3.3, and AngularJS 1.5. Let's get started.

Why ASP.NET Core?

In this first module, I'll be introducing you to some of the basics of ASP.NET Core. First, let's discuss why ASP.NET Core was created to begin with. Did ASP.NET need reinvention or not? Was there real motivation inside of Microsoft for building a new version of ASP.NET? One of the problems is that the web stack is old. It was creaking under its own weight. It was introduced back in 2002, and most of the coding for that was actually done even earlier than that. It's weighed down by lots of code that isn't even being used anymore. The weight of the framework and the support of other technologies inside the ASP.NET umbrella, including WebForms, was causing problems in innovation on top of ASP.NET. A big part of this was the reliance on System.Web, was a large chunk of code that was impeding performance metrics. When other technologies like Ruby and Note came on the scene, it was hard to compete with them on performance because of all of this legacy code that they had to continue to live with, and as well support. Another issue was this idea of machine level upgrades to .NET affecting every version of a web app that you have on a machine. So, needing to deal with .NET 3.0 and 3.5 and .NET 4.0 and 4.5 and 4.51, and every patch to them, affecting every machine. Having a way to look at delivering the .NET framework, the run time, for the web app, as something separate and discreet, was one of the goals early on in the development of ASP.NET Core. The team really believed that performance is as fast as they could get it using the existing stack. So instead of trying to fix the old stack or change the old stack, which might break one of the millions of .NET applications out there, they decided to do something different. They decided to start from scratch, and rethink the platform from the ground up. So if you're coming to this with ASP.NET knowledge, that knowledge is still very useful in ASP.NET Core, but some of the ways that the applications are layered and built are going to be new to you. But the way you have built individual pages and individual parts of a web application are still going to be layered on top existing ideas around MVC 6, around using Entity Framework, around creating rest interfaces, none of that has summarily been changed. It's really underneath architecturally that has been changed, that's where the rethinking started, in the rewriting of this stuff really from the ground level up.

What Is ASP.NET Core?

So with a very basic understanding of the motivation, what exactly is ASP.NET Core? As we've said, it's a complete rewrite of the platform, with some different goals in mind. The first of these is that it is cross-platform and open source. So the ASP.NET Core is actually built in the public, it's built as repositories, people can get nightly builds, they'll accept poll requests, it's completely open source in the way that open source software is built. It's also cross-platform, so it's going to be supported on a variety of operating systems, not just Windows. It's combined what used to be two different platforms, MVC and WebAPI into a single platform for building your web applications, and there is no more WebForms in ASP.NET Core. Doesn't mean Microsoft isn't going to invest on continuing WebForms on the old ASP.NET 4 base, but the new version of ASP.NET Core isn't going to ever implement WebForms. Another philosophy here is that everything is a dependency, that part of the motivation of building up your ASP.NET web app is to only opt into the pieces of the application that you actually need. You're really going to pay for play, you're going to only include the parts of functionality that you actually need, and this is what makes the performance so much better in ASP.NET Core than it was in earlier versions, where everything still existed under the hood, and you can decide to use parts of the application structure, if you wanted to. They wanted to focus on the lowest memory footprint possible, so that when handling deployment to different kinds of environments, that it was no longer assuming you were going to have IIS on a giant window server, that it also might be in a Docker container, or maybe in small VMs up somewhere in the cloud. They wanted to support these different scenarios for deploying these apps. This multiple deployment really means that you can deploy in the cloud, you can deploy inside IIS, you can actually do self-hosting as well. They wanted to support all these scenarios. So let's look at this in an overview. Because we're supporting cross-platform, we have both the Windows and the Unix/Linux/OSX sort of world. Can sort of lump them into two camps, if you will. And ASP.NET Core crosses both camps, so this code is cross-platform and works on both halves, both the Unix-based operating systems as well as the Windows-based operating systems. This means that ASP.NET Core can sit on top of .NET 4.6, just like ASP.NET has always done. .NET 4.6 installed on a machine works in that same way, where when it needs the framework, when it needs the CLR, it's going to rely on one from that machine, just like you've probably always done with .NET development. Another option here is .NET Core, or the CoreCLR. This is a portable version of .NET, that supports ASP.NET Core. It's a smaller subset of the entire framework that you're getting from .NET 4.6, and really has been tuned and modeled to support ASP.NET Core as well as console apps right now. So .NET Core today doesn't have WPF. It doesn't have WinForms, it doesn't have many of the features that are really specific to the Windows world. Now, you can run on top of CoreCLR on Windows, or on Unix-based operating systems. There isn't really a distinction there between what operating system you can run on, and that's where a lot of the cross-platform support is coming. But they're also supporting ASP.NET Core on top of Mono, which is the open source .NET framework that has been built over the years and has a lot of miles on it. So you can make some smart choices about where you want to actually deploy this. To actually get it hosted, we have a couple of different scenarios. We have an IIS native loader, so you have a way that if you're used to managing your websites directly in IIS, you can continue to do that in ASP.NET Core. That doesn't have to change, but now you have more flexibility and options, so that in certain scenarios, self-hosting with the command line tool chain, the .NET CLI tool chain, ends up being really trivial. And that same tool chain also runs on Unix-based operating systems. Or you can use Mono to host those in those same way. So, it's really supporting hosting wherever you would like. You can have the small footprint hosts where you're just using the tooling to self-host it, or you can layer it on top of an actual web server like IIS, or even Apache on the Unix-based operating systems. So why three frameworks? These frameworks are about supporting cross-platform development. So .NET 4.6 is the same .NET you've always known, and you can continue to develop on top of that without any real change. If you're a window shop and you expect to stay a window shop, this is exactly where you want to be. .NET Core gives you that option to have cross-platform .NET, so that you're still building on top of a Microsoft generated .NET framework, and that may give you some comfort, and knowing that it then can live in different places. It can be in a Docker container, it can be in a VM in the Cloud. Whether that's an Azure or AWS, or whatever Cloud provider you're looking at, it gives you that flexibility of not necessarily caring what operating system it's being deployed on. And Mono, if you already have an investment there, will allow you to use existing open source cross-platform .NET framework to deploy it as well. So, the idea here is they want to give you choice about deploying on these frameworks. That choice becomes crucial to allowing you to just write code. This is one of the things I like about this idea, that I want to write my web application, and then as we get further down the road figure out how we're actually going to host it. Are we going to start, because we're a start-up, and put it in a couple of VMs and a Cloud provider and see whether it's successful, or am I going to go ahead and build out that data center that I own, because I don't want to necessarily use a Cloud providers, I want to have the old-fashioned big iron web farm plus data center that I'm used to? When I'm building my application, I shouldn't have to discern what kind of hardware I'm going to be going on and having this choice of how to deploy these becomes important. You can't be completely oblivious to it, but it does become a lot easier, so that you don't have to make those decisions up front. When working with the CoreCLR, which in many ways is the future of .NET, you have to understand that today it is a subset of the .NET framework. One of the things you'll run into if you're an existing .NET developer is some pieces that you're missing from the full .NET framework. And I'll show you several example of those, but the story here is that as you're developing your application, you may hit these walls of functionality you may need. For instance system.drawing, if you needed to generate graphs or do things with images on the server, which is not an uncommon task, there isn't system.drawing in the CoreCLR today. But there are some other options for doing that, and you're going to find that as you go forward, there's going to be more and more of these open source solutions to get around some of these limitations. An important idea about ASP.NET Core before we start digging into code is this idea of composition of your application. Your application as you use it is going to be composed of NuGet Packages. So everything above the basic functionality that is being given in .NET, everything is an opt-in NuGet Package. So the framework itself simply bootstrap your application and they don't do much more for web applications. Instead, you have all these different pieces of your application, like MVC, StaticFiles, Logging, Configuration, Identity, et cetera. Those are all just going to be different parts of the application that you're going to opt into as you need them. And so your application can be as small and discrete as you want it, which was never really a possibility earlier in the ASP.NET development. As we build an application from scratch, you're going to see that everything is optional. Some of the things you've gotten used to being just built in, is no longer built in. Something that you're going to have to opt into instead of trying to opt out of, which was the old approach. ASP.NET Core in addition embraces open web development. So where possible, it wants you to use existing technologies that are happening in web development. In this way, it's using the Node Package Manager for tooling support for things like Gulp and Grunt and other development tools that are useful to web developers today. It's using package managers like Bower for client-side library support, Grunt and Gulp for build automation, and NuGet for .NET packages. And so one of the changes of philosophy here is Microsoft is not trying to provide everything you need. Going to embrace what the open source web development system already has, instead of trying to invent their own thing every time they run into a need the developers have. You don't need to use any of this. You can do web development on ASP.NET Core any way you want, but you're going to see in some of the early tooling that there's going to be support for NPM and we're going to use Bower and we're going to use Gulp and we're going to use NuGet to build up these applications. Let's show you what it looks like.

Installing ASP.NET Core

So let's start out by getting ASP.NET Core on your machine. If you open a browser and go to dot.net, D-O-T dot N-E-T, it's going to take you to the new .NET page. This is new to RC 2, and should remain here for quite a bit. And it talks us through getting different versions of .NET. We're looking for this .NET Core download. Let's click that, and depending on what platform you're on, one of these will be lit up with what you need to install on your machine. When you look at the installer for Windows, which is what I'm running on, you're going to see a couple of things. You're going to see the ability to install the .NET Core SDK. This includes the programs and the framework required to develop against ASP.NET Core, but if you're using Visual Studio as your IDE, you're also going to want to get the Visual Studio MSI Installer. This includes the entire SDK. If you prefer to work with Visual Studio Code, or just command line tools and editors, not Visual Studio, you'll want to use this, the .NET Core SDK for Windows. So let's go ahead and get the Visual Studio one, since that's what we're actually going to be building. And one of the things you'll notice is that it says .NET Core RC 2, but it also says with the Visual Studio tools preview one, and that's because there are two versions in this current version we're dealing with. The framework, the actual code you're running against, is all in this RC 2 state. RC 2 meaning we're very close to release, but the tooling itself, the integration with Visual Studio, the command line tools, those are all in what's called preview one. And so we're going to see both of those version numbers as we develop in the subsequent modules. Once this downloads, you can go ahead and run it, and you'll actually see here it's saying Repair, Uninstall, and Close, because I've already installed this on my machine. But normally you would go ahead and click Install, and let this run. You're not going to want Visual Studio running when you install .NET Core, as well as the Visual Studio tooling, because it does some things in modifying that setup. That installer can take quite a bit, in that the integration it's doing Visual Studio sometimes is a little labor-intensive. But once you have that installed, you're going to be able to see that it's installed by opening up Visual Studio. And when you create a new project, you're going to see under Visual Studio Web, you're going to see not only the old ASP.NET web applications, which is the ASP.NET that ships with Visual Studio, but also these two new projects, the ASP.NET Core web application, for .NET Core, which we'll get into in a minute, and then the same thing for the full .NET framework. If those two are installed, then you know that your installation has worked, and you have full integration with Visual Studio.

Hello World ASP.NET Core

Next, let's start from scratch, and create the smallest ASP.NET Core application you possibly can, the traditional Hello World app. Here I'm starting in a console. I'm not going to start in Visual Studio, or any of that, cause I want to preview some of the command line tooling, because you may find benefit in using that, even if you're using Visual Studio for your primary development story. The command line tooling for ASP.NET Core is a command called .NET, and this is a significant change to the way you think about running .NET applications. Ordinarily we think about building .NET applications, we're going to build either an .exe, something that's executable, or we might build some libraries, some DLLs to use in other applications, but ultimately they're going to be executed by some executable. In our case, this new command is one that's going to allow us to do several things about an application. So the .NET tool has a number of common commands with it. New to create a new basic project, Restore to get the dependencies, primarily NuGet Packages, Build to actually do the compiling of a project, Publish to prepare it for deployment, Run to execute it, Test to run unit tests, and then Pack to create a NuGet Package. And this is actually an extensible list of commands, so that you can actually write your own commands that go and work with .NET. But we're going to focus on a couple of these. Let's start by creating a folder called Hello World. And right now, there's nothing in that directory. But if we go .NET, New, we'll actually create a new C# project in this folder, and if we look at that directory, we'll see that it's really created two files. A program.cs, which you probably recognize as a C# file, and then this new thing called project.json. At this point, we can use whatever we want to edit these. We can use Notepad, or our favorite editor. So let's actually look at these files individually. Let's start with the program.cs, and I'll just use Notepad to take a look at these files. You can use Sublime or Qedit if you want, or certainly Visual Studio Code, or the full Visual Studio are good options for editing these, but I really want to show you that what we're doing doesn't require any of these sorts of tools. So if we look at this command that they have built, you can see it looks a lot like other starting points for projects, especially command line projects, that you're probably already used to dealing with. There's a static void main that says this is where our program will start, and then we're just using some code to write out Hello World. This is very similar to code that's been written in .NET since way back in 2000 and 2001, when .NET was first revealed. But what about the other file? If you remember, we have this project.json, so let's look at it in Notepad. This is a little bit more complex in that we can see it's a .json file that has some pieces to it, and let's sort of walk through them. Version is just whatever version of this project it is. It always starts at 1.0, but you can make it whatever numbering system you want. There's also some build options, that tells it when we're building this project, we need to do certain things, and in this case we're telling it to create an entry point, cause we have to have something to execute. This is essentially pointing us at that void main. And then look into the third, and probably the most interesting part of this file if you're new to ASP.NET Core, and that is this dependencies section. Dependencies are simply NuGet Packages, that's all they are. We used to put them in different files in other versions of .NET, but this is saying that we have dependencies, where we want to go out and fulfill the dependencies from NuGet. One of the special types of dependencies that you're going to see here is the .NET Core app. This is the base library for .NET Core applications, and so instead of having to have a run time on your machine, this is saying, oh, I need the run time. Go ahead and make it just another dependency on my project. That's a very different idea than we've had before, but I think a very powerful one. And the last piece is what code this project can work with. .NET Core app 1.0 is a common cross-platform version of .NET. We can also use other versions like Net 4.51 for the desktop of .NET, or even 4.52, or 4.6 for the different versions of .NET that are out there. This is saying it's going to run on a Windows machine with a full version of the .NET framework installed. But for now we're just going to stick with using the cross-platform project type. This import is hinting at which flavors of the run time that it can work with, and this uses the same PCL naming conventions to say that it can work with different things. You can actually build this, and say that it could be compatible with certain levels of PCLs. Like it can work with universal apps, or it can work with Windows phone apps, or Xamarin apps. This framework really is just a definition of what frameworks it can run on top of successfully, and the compilers will check these to make sure that all the code you've written exists on these different platforms just like portable class libraries always have. Now that we have seen our code, let's use .NET to do a couple of things. First thing we want to do is make sure that we have all the dependencies. And so we can say .NET in this directory restore, and this is going to go to the project.json, find all those dependencies, and make sure they're fulfilled from NuGet. So because our project's pretty simple, you can see that it went out to the API.NuGet.org, to try to find those different libraries, and eventually it did, and the restore did complete, as it shows right here. Now that we have it, we can go ahead and actually say .NET Run. This will build and then run our application. We could also say Build if we want to do a build step, to make sure that it's actually generated. But I'm going to use Run, because Run is going to compile it if necessary, and then execute it. Here in this section it actually built the project, we can see that it completed with no warnings and no errors, and then finally we saw that it actually output out here to the console, Hello World. To prove this to you, let's go back to the program.cs file. And I'm just going to change this a little, and put my name in the console write line, and let's try to run it again. Because a file had changed, it recompiled the file for me, and now we're getting the new change. I didn't need to restore, because I hadn't changed that list of dependencies, so that the cycle here for making changes to the code, rerunning it, making changes to the code, and rerun it, is really pretty simple. Now in many cases, you're going to want tools, like Visual Studio Code, or the full Visual Studio to handle a lot of this compiling and running and compiling and running for you, but if you're from the school that really wants to use the command line tooling, Microsoft has you covered there as well. They don't care which way you go at this code. They wanted to enable all the possible variants. Now that you've seen the simplest sort of application, let's take a look at Visual Studio Code before we go and look at the full Visual Studio.

VS Code

Next, let's take a look at Visual Studio Code. If you go to code.visualstudio.com, you will see the download for the Windows version of Visual Studio Code. Visual Studio Code is a much lighter weight solution than the full Visual Studio. If you're already using Visual Studio for other projects, Code may or may not be the solution for you, but Visual Studio Code has one added benefit, and that is it's cross-platform like much of .NET Core. So if you're working on a Mac or on Linux, Visual Studio Code is the best way to develop ASP.NET Core applications. So I wanted to give you a brief introduction to Visual Studio Code, in case that's the route you're going. Most of the course will be developed with the full version of Visual Studio on Windows, but the differences between the two IDEs can be easily overcome, depending on what operating system you're on. So I've already downloaded it, and I'm going to go ahead and run the installer. And there's your Studio Code Setup Wizard, or the installer, it's really pretty simple. It installs the application, and optionally allows you to add it to the path, which I would suggest, and, as well as some other options like open with Code. Instead of launching it, I'm going to show you how we would normally launch it. If you remember from the previous video, we created a very simple command line application called Hello World. We can open this application directly in Code by using the command Code and the name of the directory of the project, in this case that's period, for the current directory. And this launches Visual Studio Code with the directory open. Now there's a couple ways you can use Visual Studio, but for ASP.NET Core applications, you're going to want to open it up in this folder structure. So you can see everything in that folder and be able to work with it. But one of the things you'll note is that when it opens up this file, this first CS file in the project in Visual Studio Code, that there's no code coloring or any other things that you're used to with C#. In fact, it thinks it's a plain text file, and if we click down here to select the kind of file, C# isn't even listed. The reason for that is that Visual Studio Code doesn't come with C# support out of the box. We actually have to add that as an extension. And then down at the very lower left of the IDE, there's a little button for extensions. Go ahead and click that, and click Install Extension. This will give us a list of common extensions that we can add to Visual Studio Code, and the one we want is the C# one. This small button at the end will download and install the extension, and then allow us to restart Visual Studio Code. Now that it's done, it gives us a little note that it was installed, let's restart our application, and it'll restart Visual Studio Code in the same folder. Now we're seeing more of what we would expect. We're getting code coloring, it's guessing that we're a C# file automatically, and in fact, we come down here in right console dot, you're going to start to see that Intellisense is even working in this project. As it parces your project, it's going to notice in most new projects that it wants to look at the build and debug folders to the project, so we can do this sort of Intellisense that the full version of Visual Studio would do. So go ahead and say Yes to allow them to do that, and this may take a minute for Visual Studio Code to catch up with you, so don't worry too much about it. But once we have that, we'll be able to get Intellisense, like console dot will show us cursor left, cursor top, the other things that it's actually looking at in the console object inside of our application. That means we can start to build applications very similar to the way we build them with the full version of Visual Studio, directly here in a cross-platform way. But instead of looking at this application, let's talk about how to create a new project, cause we're going to start with a brand new project for our application. The problem is File doesn't really have a New Project. It has a New File, but that's just going to create a new empty file for us. There is no notion in Visual Studio Code of creating new projects. The way we do this is in fact somewhat different. If we start here in the console, we can use a command called Yo, which is the Yeoman project. Yeoman is a series of generators for creating different kinds of files and projects, and it works across the ecosystem of web development and either other types of projects. And Microsoft has created generators for ASP.NET specifically for this purpose, the same thing that a New Project Wizard in Visual Studio would do, the Yeoman project does for people working at the command line. The problem is we need to have it installed, that means having Node and NPM installed, because it's on top of Node and NPM that this Yeoman project actually works. So let's make sure that we have Node or NPM. If we type node--version, it'll tell us if we have a version of Node installed on our machine. If we don't, we'll need to go over to nodejs.org, and download a version of Node. This 4.4.5 version is probably sufficient, this is the latest stable version, whereas the 6.2 version is the one with all the latest features, but for us the 4.4.5 is actually good enough. You'll probably have noticed on my machine, I have 5.1 installed, and so it's not important for the kinds of things we're doing that we have a specific version of Node installed. Since Node's installed, we can assume that NPM is also installed. And we'll see the version there, so we know it's installed. And so now we can go ahead and install Yeoman. We do that by using NPM, which is the Node Package Manager. I'll say, please install on my machine, the project Yo, which is the Yeoman project, but we're going to add a -g to make it global on our machine, so that we don't have to have Yeoman installed in every single project we need it in. Once we get to this point, Yeoman is actually installed. We can tell if we just type Yo at the command prompt, and you'll see it shows us Yeoman, and then allows us to do some things like install a generator, get some help about generators, or exit, get me out of here. I'm going to get out of there for a minute, because we're also going to need to install via NPM, the generator for ASP.NET. And it's called generator-asp.net, there's a pattern in Yeoman of starting the names with generator, and then dash, whatever the kind of generator it is. And there's quite a few of these generators, but I won't get too deep into the Yeoman ecosystem. For our needs, to create a new project, this is where you're going to do it. And again, we're going to add the -g to make sure this generator is global to our machine, not just in our project. Now that the generator's also installed, let's go ahead and move back to a directory, and let's use Yeoman to install this. And we can say Yeoman or Yo, and I want to generate something with the ASP.NET generator, and that will show us the options inside that generator for different projects to generate. We can see here that we can create an empty web app, a console application, web application, a basic web application, web API project, or even using Nant, a class library or a unit test project. For us, we're going to go ahead and create a web application, just a plain old big web application. And sometimes the Yeoman tool doesn't react to the arrow keys like it's supposed to, and if it doesn't do it, you can actually use the number keys to pick which one of these. So this would be one, two, and let's try three. We want a web application, and now we want to pick whether Bootstrap or Semantic UI are going to be used. We're going to stick with Bootstrap, because I'm going to show you that later, and then let's go ahead and call it Fun with Yo. This is going to create a directory and then the contents of that directory. After it's done with this, it actually runs and gets all of the requirements for that project, except for the ASP.NET requirements. So let's go to that project. We can see it created a lot of structure here, a lot of pieces that we're going to learn over the period over the course what they mean. This is sort of a complete starting point for an application. If we use that .NET command we saw earlier to create a new project and run it, or even restore it, it's going to be the same here. I can say .NET Restore, and it's going to go ahead and get all of those required libraries and NuGet Packages for this newly generated project. In that same way, I can say .NET Run to start listening on that project. Now we're actually running this project that we just generated with Yeoman, and we should be able to go to the browser and see it. Logos 5000 by default, and then there we have an actual application based on the new code it just generated for us. I'm going to press Ctrl + C to stop that, and let's go ahead and open up this project directly in code, again by using code and then a period to indicate the current directory. We're going to get the same pop-up that says the required assets for Build and Debug are missing from the project, should we add them, and this is something you'll get one time on every project in Visual Studio Code. And now we can actually walk through and see all the different parts of this generator code. Now I'm not going to go through what all this code actually does, because we're going to build a project from scratch, starting in the next video. But you can see that you can do the same things with the command line plus Visual Studio Code if you do want to follow along in this course using a Mac or using Linux, or if you just don't want to bother with the full Visual Studio. But next, let me show you how to do the same thing directly in Visual Studio.

Visual Studio

So let's talk about using the full version of Visual Studio to create the beginning of our project that we're going to build over the length of the course. Here in Visual Studio, I'm going to be using some extensions, but I'm also going to be using the ASP.NET Core changes to the IDE that were added. If you remember back in the fifth video, I showed you how to install ASP.NET Core onto your machine. And if you had Visual Studio installed, it would have added the extension that supports ASP.NET Core in this full version of Visual Studio. You can tell that this is installed if we look at the File: New: Project, and under the Web folder there should be an ASP.NET Core web application, a couple of different variety of those, in order to create ASP.NET Core applications. And this way you know that your installer for ASP.NET Core in fact did everything it needed to do. We're going to come back to this in just a moment. Throughout this course, as we use Visual Studio, I'm going to be using some specific add-ins in order to speed up development, so I want you to know what those add-ins are and have the opportunity to add them to your project. So if we go to Tools, Extensions and Updates, we'll be presented with this dialogue that shows us all the extensions that we have. If we go over to Online, there's four of them I'm going to install, so that you know how to get at them. The first and probably most important is going to be this one, Web Essentials, whatever the current version is for 2015. Currently we're on the .2 version of the Web Essentials 2015, which lines up with the version of Visual Studio you're using, and you should be using 2015 of Visual Studio as well. So let's go ahead and download and install that. And it's going to open up a dialogue, but we'll close that. We also need Web Compiler, and these extensions may not be on this first page of the most popular items, you can always search for them, like Web Compiler. I'll go and download that as well. We also want Add New File, which is an extension that will quickly allow you to add new files without using the New File dialogue. It makes creating the new files as I show you this new way of building ASP.NET Core applications much faster. I'll go ahead and add those. Coincidentally, all of these are by the same guy, Max Christiansen. He's really done some amazing work, he's a Microsoft employee, at extending Visual Studio to do things, especially around the web stuff. And the last one I am going to use is Open Command Line. Open Command Line just gives us a shortcut key to go directly to a console when we're going to need it. The last of the extensions we're going to need, and we'll need it later on in the course, is a Typescript extension. And we'll see different versions of this. We want whatever is the latest version, and in this case, this is the 1.8.4 support. And this will actually open up a browser to download the actual installer, so it's a separate installer that we have to run once Visual Studio is closed. So let me close Visual Studio, I would have had to restart it because of the other extensions, but I'll go ahead and close it. And I'll go ahead and run the installer that I downloaded earlier. And notice these are the TypeScript tools for Visual Studio. So this adds support to Visual Studio for TypeScript, which we'll use later on in the course. So now that we're back in Visual Studio, let's go ahead and create a new project. The ASP.NET Core applications give us a couple of options, either using the full .NET framework or the .NET Core Framework, and this is really whether your project needs to be cross-platform or not. Because it has more of the moving pieces, I'm actually going to start from the .NET Core application, and we may be adding the .NET framework support as we go along, if you do want to sit on top of the .NET framework. But for many of these projects, I don't want to have to think about whether my application is going to run on Windows or a Mac or Linux, I want to just have an application that will work in as many of these environments as possible. So I'll leave it at the .NET Core version, and I'm going to put it in the Examples directory so that those of you with a plus subscription will be able to get access to the source code, and I'm just going to call it Big Project for now. This is going to open up another dialogue where we can pick what kind of project. And I'm going to create the web application, which is similar to what we did with Yeoman in the last video. And this project that you can create with web applications is actually a really good starting point for creating a new web project for ASP.NET Core. The problem I have is, to teach you guys how ASP.NET Core works, there's a lot of concepts that they're throwing at us at once. In fact, they're even hiding some of the concepts, so, let me show all files, and we'll see there's actually even more files. There's the idea of startup and program that we saw in our earlier example, but on top of that, there's something called Bower, there's a Gulp file, which you may not be familiar with. There's a package.json as well as a project.json. And package.json implies that we're actually using Node for this. Look, there's even a Node modules folder. And then the typical sort of services, views, models, and controllers that we may be used to with older versions of ASP.NET, and even this magical folder called wwwroot. This is a lot to rock or understand at once, when you're building a new project, so let's not do this. Instead, I'm going to create a new project that we're actually going to build from. And I'm going to call it The World. This'll be the application that we're going to build throughout the course. And instead of starting with the full web application, which again, is a good starting point once you understand the concepts, we're going to start from empty so I can really convince you of how this stuff works together, so you can know what all that boiler plate code that's being generated for you is actually doing. This has many fewer moving pieces, really. We have a project.json, a startup, and a program, much like the Hello World project we created earlier in this module. We also have a web.config, but that web.config is really just there so that we can be hosted in IIS efficiently. Don't worry too much about web.config at this point, and assume that you're not going to be using it in ASP.NET Core for your own uses like you may have used them in earlier versions of ASP.NET. But let's start with the program.cs just to give you a sense of what's happening. In this entry point, much like we saw with the Hello World project, this is really where our application is starting up. In older versions of ASP.NET, it may have been more confusing about how your web apps are actually launching, but there's no confusion here. This is the starting point for all of your code. And instead of writing out Hello World like we did earlier, we're actually going to build up a web host that's going to start to listen to requests. This is what makes it a web application. This web host builder allows us to specify the things about that web host that are important to us. One of them is used kestrel, which is the name of the web server that you'll probably be using under ASP.NET Core. Use content root, tells it where the content is for your project, in this case, the current directory. It adds some support here for IIS, mostly to support things like specialized headers and Windows authentication, which you may or may not be needing. And then this line is very important. This says hey, go ahead and use a class called startup to set up my web server. So this is saying I'm going to have a class called Startup, and instantiate it when you start the web host. And we'll, I'll show you the startup in just a moment. And it finally builds this web host, and then starts it by calling Run. Now this boiler plate, you're probably not going to need to change very often, but understanding what it's doing is really setting up that initial server integration, and then starting to listen for requests. One of the last things it does when it starts to listen for requests is it creates a new instance of this startup class. And what this startup class actually exists here as a C# class in our project. In the startup class, there's really two things going on. There's a call called Configure Services, which we'll get to a little later in the course, and then there's a Configure. Configure is a method that is called to set up what to do as requests come in. Literally this is code that is being written and called every time a request comes in. And all we've done here is create a little piece of code that is handling that. When I looked at other web frameworks like Node and Ruby on Rails and some others, they kept on talking about this concept of middleware, and I sort of scratched my head about what exactly is middleware? What does that really mean? And I finally understood once I dug a little deeper under the surface, that all that that magic term middleware means, is, I'm going to hand you some code for you to do something as the request is happening. So this is the smallest piece of middleware we can create. This middleware says as a request comes in, return as a response, Hello World. And in fact, this is a working web server. Let's go ahead and run it, and we'll see that this is actually returning Hello World. It's not actually returning a web page of Hello World, it's literally returning the string Hello World. If we look at this call, it's essentially saying no matter what the request is, it's never looking at the request information. It's going to handle for every type of request that this should be the response, Hello World. That means that if we go ahead and change our request to something like foo and bar, it's still going to return Hello World. If I do something like icon.jpeg, guess what, it's returning Hello World, but the browser, because it's called .jpeg, assumes it's going to be a jpeg payload, and is being confused by it. But no matter what the request is, our code is simply returning Hello World. In fact, we could make this a web page by just adding the content, right? We can return an actual web content by doing the right things here, and just returning a string that represents Hello World. Cause that's essentially all we're doing. Now that our requests come in, it's returning a HTML document, but the simplest version of it, that's why the page now looks like this. It's the simplest HTML document that we could possibly do, and this isn't really what we want it to do. But it's important for us to understand that what we're doing here is the simplest sort of web development. Now this sort of call is never going to really happen. We're going to use other frameworks like MVC, or other frameworks to respond to these requests in a way that's more formulated. And we'll get to that as we walk through building up web applications in this course. But I wanted to give you the idea of what configure is doing here is setting up what sorts of code are going to handle requests as they come in. And what's important is that this is a list of code that's going to handle it in this order. So if you've worked with other frameworks or worked with earlier versions of ASP.NET, you know there's this chain of responsibility. There's code that's going to look at the request and see whether it can actually return that data or not. And digging into what that chain was in earlier versions of ASP.NET or other frameworks, was often confusing, and in our code, this is all the code that's required. So everything that goes in configure is the list of things that are going to look up the request and possibly return responses. And we'll see that as we build the course, that'll make more sense as you're digging in, but hopefully that'll give you a sense of really what configure is doing. Configure services does another task, but we'll dig into that as soon as we start needing configure services in the next few modules. So this should give you a starting point for the actual development story we're going to get to, but I want to talk about a couple of important concepts here, about the future of ASP.NET Core and how it's changing. This is being recorded for ASP.NET Core RC 2, and it's been announced that some things are changing, so let me open this up on a File Explorer for a moment. And we'll see that there's this project.json file that represents the different things about our project, and we'll be exploring that in depth as we go along. And there's also this theworld.exproj file, that is this specialized project type that is for ASP.NET Core applications right now, or more importantly, .NET Core applications. If you've done Visual Studio work before, you may have expected this to be a CS proj file, and in fact that's what's going to happen in later versions of .NET, probably around the ASP.NET Core RTM timeframe, or a little after the 1.0 is actually released. The tooling for ASP.NET Core is still going through some changes, though the Core libraries we're going to be showing you, should be pretty stable at this point. The other piece is that the project.json is going to be simplified, and some of the things that it does are going to be moved into MS Build instead, or be put directly into the CS proj file. A lot of that is still being worked out, but just know that what you're going to learn about project.json and that project file are both probably going to change as Microsoft figures out exactly the right approach as we get into finalizing the tooling for ASP.NET Core.

Where We're Headed

Next, let's talk about where we're headed. Over the modules of this course, we're going to slowly build what you're seeing in front of you, and that is the World website. This is a simple website that will allow people to plan a trip on a map. It's going to include authentication, so you can log into the website. It'll allow us to add trips, manage each of our trips, and show you a map that's going to contain all of the stops of your trip. By the time we build this, as we go through each and every module, you'll be able to see how this works, and how we're going to integrate all these different technologies to the project. Let's wrap up this module.

Summary

So where are we? You've seen what ASP.NET Core is, and that it's a whole new .NET world. Everything has changed, and it's going to take some getting used to. There's going to be some fear and some loathing. But overall, I think you're going to be happier once you get comfortable with it. You've also seen that whether you're going to do everything at the command line or you're going to use a complex IDE like Visual Studio, you can go whichever way makes you more comfortable. If you want to use thin editors and command line tools, go for it. If you want to use wizards and tooling and all the sort of helpers that many of us have gotten used to with Visual Studio, that works too. There's lots and lots of choice. And finally, the ASP.NET Core is embracing this idea that it's open source, top to bottom. Every part of ASP.NET Core is open source. We can go look at the source, we can contribute to the source, we can even debug the source. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET Core 1.0.

HTML and CSS Basics

Introduction

Welcome to the second module HTML and CSS Basics. My name is Shawn Wildermuth of Wilder Minds. In this module, we're going to introduce you to some of the basics of HTML and CSS. I'll start by showing you how ASP.NET Core serves static files, I'll introduce you to HTML, to CSS, and talk about laying out pages with HTML and CSS. Let's get started.

What Is HTML?

Before we can build a dynamic, complex web app, we're going to need to understand how layout and composition works. And that really starts with the HTML and CSS. But what exactly is HTML? If you're an existing web developer and already comfortable with CSS and HTML, you could go ahead and skip through to the next video, if you'd like. But I think there's some salient points here, especially as it relates to ASP.NET 5 that might make it worth your time. HTML stands for HyperText Markup Language. It's an angle bracket-based structural language for describing what a webpage looks like. It is derived from SGML, so it has a long history of being markup language. We can see that angle brackets are used to create a hierarchy, or a parent-child relationship with containing elements, the HTML contains both a head and a body section, and that the body contains an h1 section. The angle brackets containing the name is how it starts, and then starting with a slash and then the name is how one ends. These angle brackets don't assume that HTML is XML. If you're a developer that has used XML in the past, you may feel comfortable to think about them in a similar way. But the difference are that HTML is not case-sensitive. So HTML doesn't care whether the head tag is all caps, all lowercase, or mixed case. Different kinds of elements in HTML have different closing rules. Some elements have to be self-closed, like the image tag here, and some have to be closed with their own ending tag, like the script tag here and the h1 tag here. You'll just need to learn which is which. The Visual Studio and VS Code editors can help you validate the HTML, but it's still going to be up to you to understand which ones are required and which ones are not.

Serving Files in ASP.NET 5

Before we can create HTML and CSS, we have to be able to serve these files through the web server in ASP.NET Core. Let's see how that works. We're back here in Visual Studio, in the same project we created in the last module. I'd like to start by creating a new webpage. Right here in the root of my project, I'm going to use Add New File and create index.html. It spells the extension of, unsurprisingly, HTML files. So we can take this new file, and just like we saw before, we can go ahead and add some structure. When creating this new HTML file, it's created the basic structure of the file. But let's go ahead and create a small section that's going to show The World, the name of our website, in the main part of the page. I'll do the same by putting The World here. The title is the name as it is going to appear in the title bar of the browser, whereas everything inside the body is actually shown in the main section of the browser. Let's see if we can actually serve this and show this in a browser. We'll see that, by default, Visual Studio sets you up with serving this project through IIS Express. So if we go up to Debug, and we either hit Start Debugging or Start Without Debugging, we should be able to launch the web browser. So I'm going to pick Start Without Debugging, to just launch the browser. And here, we'll see that Hello World! But of course, this isn't what we had in our HTML file. And that's because our startup.cs is still returning our Hello World file. So let's get rid of our middleware here entirely, and let's try to run this again. Let me build it and then refresh it. And we'll see it doesn't come up with anything. It's actually a blank screen. That seems even more perplexing at first. But if we open up the browser tools with F12, and this works in Chrome, IE Edge as well as Firefox, like I'm using, and let's refresh again, we'll see that it couldn't find anything at that root directory. Well, let's change this and say index.html. Maybe that's what we need. We need the name of the file we created. Still nothing. The reason we don't see anything is twofold. First, any files that need to be served as files to the web browser can't live in our project any more. They have to live in a special folder called www root. This www root folder, similar to the way that Node and Ruby and Rails and even JSP Pages handles it, is a place that you can put these special files to be delivered without having to worry about accidentally delivering C# files or configuration files or other things that you don't want to accidentally serve. So let's take our index.html and let's move it into that directory. In ASP.NET Core, this special folder is treated like the root of our website, so that if I've done this right, this going to the original HTML page should continue to serve that page. But of course, it still doesn't. And that's because of a unique feature of ASP.NET Core that you'll want to get used to. That feature is that every feature of the web server is optional. Everything we imagine doing with the web server is optional. And this goes for the simplest case, which is serving static files. So what I can do is, I can use this app class and call UseStaticFiles. This is adding the middleware that's required to serve files to the browser. Now, notice it's showing that the StaticFiles is not defined. We can get this defined in a couple of different ways. One is to use this Quick Launch and decide to add the packets for static files. Notice we're seeing the static files for ASP.NET Core RC2, which is the current version of the project. If I add this, what it's actually going to do, and I'm going to do this by hand so you can see this a little more clearly, is, it's going to open up the project.json and it's going to add it to the dependencies. These dependencies are simply the NuGet packages that our project requires. And you'll see that the dependencies include a couple of things by default. The first is this Microsoft.NETCore.App object. And this is really the framework on top of which all .NET Core applications can run. If you think about even the framework being a large NuGet package, that's really what we're saying here. And that's why its type has to be platform, because it's the platform on top of what we're trying to build. So imagine the .NET framework being just another dependency. And that's what they really accomplished in this version of ASP.NET Core. These other lines are just NuGet packages that we require. Remember IIS integration was inside the program.cs for when we set up the web server. And Kestrel was the name of the server that we also used inside our program.cs. So let's go ahead and add a new package, the static file package, in fact. This is going to be in Microsoft., and what you'll see here is that we're actually getting IntelliSense to the NuGet packages. This is going out to NuGet and looking for packages that match what we're typing. This is similar to using the UI for adding NuGet packages or even the PowerShell commandlets for getting NuGet packages. But I actually like doing it here in the project.json because it feels more like the kinds of things that I do as a coder. So I'll say AspNetCore, and then I'll start typing static, and we'll see StaticFiles shows up there. And when I tab, it's going to go ahead and show me the different versions of that project. And I want 1.0.0 rc2-final, because again, that's the version we're dealing with. As soon as I save this file, we're going to see up here that it goes out and restores the packages by getting them from nuget.org. We come back here into Startup, we'll see that it's no longer showing an error because we now have UseStaticFiles. Let's build this project now. Should build fine. If we go back to Mozilla, should be able to serve this file finally, because now this file is in www root, and the static file's middleware is there to actually find it. But what if we want to make index.html the default file for our project? You see, we're still getting a not found here. That requires another piece of middleware. This piece of middleware is called app.UseDefaultFiles. This will add some standard default files so that when looking in a directory, and that includes the root folder of your project, that it's going to automatically look for an index.html, a index.htm, and others. You can also define your own, if you have your own sort of default files, as well. And if I build this, and go back, we're going to see it still fails. It still fails for a really important reason. The reason is that this has to be handled in the correct order. Because StaticFiles doesn't find the file at first because it's searching for just root, the default files can change what files it's actually looking for to allow StaticFiles to do its job. So what we need to make this work is to do the DefaultFiles first. To build this, let me show you how it works and then I'll come back and discuss it a little. Now that DefaultFile is working and we're serving the index.html for us. The reason this works is really important to understanding how ASP.NET does its job. That is that Configure is there to configure the middleware, as we've talked about. But the order of the middleware here are important because, as a request comes in, it's going to hand it to each middleware in this order. So because DefaultFiles is changing the request but not actually serving UseStaticFile, it has to come first. It has to figure out what file actually exists and then letting StaticFiles find it. If we do it in the reverse, DefaultFile changes the request to look for index.html in our case, but there won't be a static file handler to actually serve it. In prior versions of ASP.NET, we relied on understanding that chain of middleware as being something implicit inside of ASP.NET. In fact, we could, with the global ASAX file, we could have event handlers fire at different points in that process. But ASP.NET Core, this is the entire set of operations. That's why we're having to opt in. None of this stuff is hidden any more. And the order of these becomes important because we're defining who is handling what and in what order. Now that we're able to serve the HTML file, we'll be able to build out and show you some of the features of HTML while we build the homepage for our new website.

HTML Basics

Let's cover some of the HTML basics. Inside our HTML file, let's talk about the individual pieces so you can make sense of each of the elements of a basic HTML page. This first piece is called the DOCTYPE. This DOCTYPE specifies to the browser how to render it. There been different versions of HTML over the years, HTML1, 2, 3, 3.01, 4, et cetera. We're currently working with HTML5. And this DOCTYPE tells the browser what version of HTML you're using. Some of the older DOCTYPEs were very long and cumbersome. But there was the decision in HTML5 to make it as simple as the DOCTYPE is just HTML. That means it's an HTML5 document and it will be treated like it is. The first object you'll find is the HTML object. This is the container for everything on your page. So it normally starts and ends each of the documents you're dealing with. The first child inside the HTML (mumbles) is normally this section called head. Head is where non-structural information is kept. You can think of this as maybe a metadata structure. So one of the first things that almost every page gets is a title. I'll just call the title of our page The World for now. Another piece of information pretty much every page should have is what it was encoded with. So we'll use a tag called meta, and set a property in it called charset. This is the character set that the page is using. Utf-8 is primarily what you should be using for all your webpages. This is just to tell the browsers, This is what we think we're sending you. And ordinarily, that would be right. That allows for localization and other things to be set up with this main character set. If we run this in the browser or view it again in the browser, you can see we're still getting that HTML page. But here in the tab, it is now saying The World. This is where the title ends up in the UI. That title something that browsers will treat in different ways. In fact, as you make a new bookmark, that bookmark is also going to derive its name from the title. The next section, and the section you're going to be dealing with primarily is something called the body. The body is the descriptive structure of what your page is. Right now, we don't have a whole lot of structure. We have these h2 object, and an h2 is a header. HTML was originally created to create documents. So a lot of this will look like the sort of tags and pieces that you might imagine in a Word document or some other structural text document. So h2 says, Use the header 2 level of text. in fact, if we make this h1, we can see that Visual Studio fixes the beginning and ending for us, but also that, in the browser, it's going to get a little bigger. And that is by design. H1 all the way down to h6 are going to look like headings. They get smaller and less bold as they go down from 1 to 6. The p tag, which we also have here, is called the paragraph tag. This is just for paragraph-level text. So anything that's put inside of a paragraph will be listed as simple blocks of text. Let's create some structure here. I'm going to do this by selecting both the lines and hitting Shift + Alt + W. Now, this Shift + Alt + W experience, something that came from the Web Essentials extension that I talked about installing into Visual Studio in the first module. But in either case, we're simply surrounding those pieces of text we have in this thing called a div. A div is a structure for some part of the page. You're going to see that lots of your page are going to be made up of this container called a div. A div can contain not only elements but elements of elements, and element of elements. So what we're doing here is, we want to create two sections of the page, the main section of the page that has our content, which is going to, right now, only be these two lines of content, but also another div that's going to contain our footer. Of course, this is after the first div, so it's going to show up afterwards. HTML is drawn top-down, outermost to innermost. So because this div is lower than this div, it's going to come after it on the page. Here in this div, let's start with something called an entity. In HTML, there's a number of these shortcuts for displaying certain kinds of characters. In other languages, these may be called escaping a character. But they're called entities in HTML. The first one that you often run into is the copyright symbol. All of these start with an ampersand and then have a set of characters after them, and it ends with a semicolon. You can see a number of these, Visual Studio wants to help us with. I'm just going to say copy. This will turn into a copyright symbol on our page, which we'll see in a second. And I'll make up a company to own the copyright for our particular page. Let's see this in the browser. We now have that copyright symbol because we're using an entity in the XML page to say, This is what we want you to render, and then the plain text. And we're calling this the main part of the page and then the footer. But currently, the footer is just being shown directly after all of the content. Later on in this module, we'll show you how you can get this to actually stick onto the bottom of a page. But we're not quite there yet.

HTML Forms

Next, let's talk about forms in HTML. Everything we've done with the HTML page so far has been about emitting things for the reader to consume. So when visiting our website, we'll be able to see all this text, but won't be able to do a whole lot with it. If we want to collect information from the user, we're going to have to use something called HTML forms. Let's go ahead and create one here. It just starts with a form element. Then, inside the form element will be the different controls you want to use. First one I'll show you is something called the label. A label, unsurprisingly, is a label for other controls on the page. So I will just say Date, and I'll use a self-closing element called input. This will create a place for the user to input data for us. And let's repeat this with another label for location. Here, we're going to be collecting what date does someone want to visit some place in the world, and then where that location actually is, what you call it. And then we'll end it with some sort of button to say, Please send this to us. This is another input, but there's an attribute on input, a piece of data that you can add to describe it, called type. One of the input types is something called submit. So we view this all in the browser, we'll see we have our form laid out now. Date, Location, and then Submit Query. Because we didn't specify the text to put on the submit, we just said, Please put a button for submitting here, it went ahead and used the default text of Submit Query. 'Course, we're not querying in our case, we're going to be adding it. So we can add another attribute here called value. And I'll just say add. The reason why you have to use value on a submit button to set the text has a lot to do with the way browsers have been implemented over the past 20 years. And I'm not going to get into it, into the historical lesson. You can certainly look it up. But the important thing for you to remember is that when you want to set the text of a submit button, value is the way to go. For us, we don't really want these to be in line. We'd like it to look more like a form where you have different objects down the page. The way we can do this is to surround them with a div element. I'll do the same with the next two, and then ultimately, I'll do the same for our submit button. And what the div is doing here for us is actually structuring it so that everything inside the div is going to be shown, and then effectively a carriage return. So what you want to think about is that these are displayed as a block. And that block is going to be as wide as the container. That container, in this case, is going to be the page. So because we surrounded them with divs, we can now see it looks a little bit more like a form. These things are going to be vertically lined up one after another. Now, it still doesn't look great because we haven't styled this to make it look a little bit more approachable. We can see we're creating these input places on our webpage for people to be able to send us information. And that's critical to the kinds of things you're going to want to do in HTML. We got some basic, though very simple, structure for our page so far using HTML. Let's look at how CSS can make this a little bit more approachable to a user, because I think we all can agree that this is a pretty ugly website so far.

CSS Basics

CSS stands for Cascading Style Sheets, how you design an individual page. So the HTML is that structure, and the CSS is the design elements. We can think about it in this way. The HTML says there should be an h1 tag on the top of the page. CSS is going to tell you what the font is, what color it is, how big the text should be, how big the border around the text should be, etc. So HTML is structure, CSS is design. Keeping these separate is the best way to handle them. In HTML, you can handle styling really at three levels, style tags, style blocks, and stylesheets. Let's see how these three are separated. Here, we're back in the HTML we created earlier. Let's say that we want to take our webpage as we see it now, we may want to make it look a little better. Let's start with just changing the font. We can come here into the body and add a style property. This is where we can give it properties to change the look and feel of the body element itself. I'm going to add a font family of sans-serif. That just means I want to have a font that doesn't have the little serifs on them. Times New Roman has serifs, Arial doesn't. Helvetica doesn't, but Georgia does. So it's just a stylistic decision about what I want my page to look like. I could put individual fonts here, but it's ultimately going to try to match it as best it can on a particular machine. So typically, you're not going to want to put OS-specific font names here, like Arial. I'll also set the font size as the default for the page to be 14 pixels. Now, this is a relative size based on pixels for a webpage. I put these in a style tag, and so it'll affect the body and anyone who hasn't specifically set one of these properties on its own, which in our case is no one. When we refresh it, we'll see that it changed a little in that now it found a font that passes muster as a sans serif font, and that all the elements then get or inherit that property because it exists on body, their parent. The problem with this approach is, it doesn't scale very well. Having a style element on each piece that you want to change the look of ends up being pretty ugly. One alternative is to create a style tag. Instead of putting the style element directly in body, we can use something called a CSS selector. This is a description for what we want to apply some rules to. In our case, it's just going to be body. Any kind of element on a HTML page can be matched simply by using its name. So here, we'll put body to say, Please specify any element that is called body, normally only one, and then specify the font family and font size, in the same language we did in the style tag. This works. This is fine, if all of your styling is only on a particular page. The reality is, in most cases, you're going to want to separate these into their own file so that they can be shared amongst different pages in your web application. So let's do that, let's create a new folder under www root called CSS. And this, you could call this Stylesheet, you could call this whatever you'd like. But see, calling it CSS is a pretty common way. Now let's create a new file. I'm going to call it site.css. Let's just take this style. Instead of having it on the top of the page as a style, we'll have it in a separate file called site.css. I'll put a comma at the top so we can always know what file we have open. In order to link it here, we actually need to create something called a link and tell it that its type, using the rel, is a stylesheet, and then a href to point it at the actual file. This is effectively telling it to link our stylesheet into the page. So when the page is loaded, it's going to see this stylesheet and also load it from the server and apply it to our page. We refresh, we should still get the same page, but we're getting it from a separate request. And the separate request is important because ultimately, you're probably going to have more than one page on your particular website, and separating these out so you can share it across those pages makes the most sense in almost every situation. Inline styles, for one-offs, maybe you can get away with. Putting style sections in the header, maybe you can get away with. But in most cases, go ahead and create separate stylesheet files for each of the different kinds of things you want to do. In our case, most of our styles will be in this site.css, in one large set of rules. Let's explore CSS selector so you can really understand what you're supposed to do.

CSS Selectors

Let's see how CSS selectors work next. I told you in the last video the body is a selector, and essentially it's saying, I want to apply these rules to whatever is selected in this block. By specifying body, it's going to go ahead and look for an element whose name is body. In the same way, we can create a new rule for a label. So all the labels could have a certain look and feel. Let's start by saying the font-weight of the label is bold. Over in the browser, when we refresh it, it found each of the two labels we had and set their font to be bold. So an important idea here is that the selector is going to specify or find all the elements on the page that match that selection. Body is only once because there can only be one body tag. But label could be for any label on the entire page. Let's see how this works for input. We have three inputs on the page, and we can specify the property of width to say how big it is. Let's set it to, let's say, 150 pixels. And the browser makes them all the width we'll want. But of course, they aren't lining up in an attractive way. And we probably don't want the submit inputs to be wide, as well. We want them just to be as wide as the text. So this doesn't really work because this selected too many elements. What you can do, because CSS are applied top-down, is create an exception. CSS takes a selector for something that is more specific and it overrides something that is less specific. In our case, we can say input type=submit, and tell it that the width should be auto, or should be automatic. And this gives us the behavior we want, right? It made these 150, and then we have an override on the CSS selector for submit. But instead of just overriding submit, this is still going to capture more of the input types than we want. Checkbox and others are going to be wide when you don't really want them to be wide. So instead of this, let's just be more specific here and say, type=text. Now, type=text, let's look at the browser for a minute. We'll see that it still works. But why does it still work? The reason is that the default type of input when you don't specify it is text. So this applies to that. But we actually want more than just the text type to be included here. We want type=password to also be included, because on some pages, like a login, we're going to want to have passport control. The different between them and text is that, as you type in them, it doesn't display the text that you're typing on the page. You've seen this a million times. So we want both of those to also be that width. In fact, we probably want something called the textarea. Textarea is a multi-line input. Don't ask me why it's input, not type=textarea. That would be logical and consistent. But this is HTML, and that's not really the way that HTML works. So this syntax of listing a type and then comma means that we're going to match all of these three types and apply this set of rules to it. In our case, that's going to be width. This is the other way of doing it rather than overriding. There's going to be cases for doing both, of having a selector that selects a lot of elements and then just overriding the couple of things that are exceptions. Or in our case, we're going to only make wide the things that are like a text field. Input type=text, password, and then the multi-line text, things called textareas. Of course, in the browser it works. We still aren't seeing this stuff lined up in something that's quite pretty. This is another of the properties we can use in CSS. This one is called display. This is how an element is displayed on a page. By default, a label is something called inline. So it wants to be on the same line as other elements that are in line with it. But in our case, we want them to be separated on different lines, so we're going to use a display called block for the labels. This display block is something that divs are by default. That's why they end up getting stacked vertically one after another instead of horizontally like something that we're in line. So by specifying the label as block, the labels get their own lines now and we're starting to look like a more sensible form. We're doing all of this juxtaposition of how it's being used on the page all with CSS. We can go back and change any types or even force another div around the date and the location. We could have done that to solve this block problem, but it's just as easy to have CSS be able to do it, as well. For these multi-part selectors or individual selectors, we can see basically how those work. But what about elements that we want to be part of our conventional structure? We're not going to invent new elements just to be able to apply them to CSS. Now, that's where CSS naming comes in. Let's look at that next.

CSS Naming

Now let's talk about CSS naming. In our example, we really have two sections here. We have a div that represents the main part of our page, and now we have this div that represents the footer. So in order to style them, we can actually give them names, or what they refer to them is id's. And I'm just going to call this an id=main and then go down for the footer and do the same thing and just call it a footer. When styling these, we can use a specific type of selector called an id selector. Now, the idea behind id is very important, in that it assumes there's only going to be one per page. So this type of selector using the id should be on large pieces of your page that are only going to exist once. We specify the selector by starting with the pound symbol and then giving the name. So I'll have a section for main and then a section for footer. Here we can go ahead and describe what we want for each of these. I'm going to specify the background color of my main element to be just a little bit gray. We could go ahead and pick named colors here. But we can also use a syntax that's special to CSS that is a pound and then three digits for red, blue and green. Visual Studio gives you this nice picker, if you prefer, so you can go ahead and pick the color you're looking for. Or you can just go ahead and type it in. This can either be six digits, where each two digits is a hexadecimal value of red, blue and green, or it can be one digit where each individual hexadecimal digit is how much blue and green, on a one to 16 scale. In our case, I'm just going to say eee. And you can see that Visual Studio likes to give you a little preview of what that color will be. And I'll do the same thing for the footer, but I'm going to make the footer darker. I'm going to say 222 to make it almost black. But almost black means our text is going to be hard to read, so let's go ahead and specify color, which is really the foreground color. And I'll use that eee again for that, just so we can have sort of the inverse. We look at this in the browser, we can now see that we have this gray section on top that represents the entire main element. Then notice that because these are divs, they go all the way from edge to edge on the page, even though we're not using much of the horizontal space. Same with the footer. It goes all the way from edge to edge, and luckily the text is visible because we were able to change the foreground color so we could see it. Let's add a new section to our page. I'm going to do this by first taking the footer and the main section, and I'm going to wrap them in another div. We can have any levels of these that we need. It's just the structure of what our main part of our page is. I'm going to create a new div on top that I'm going to give the id of sidebar. This is going to be a section on the side of the page eventually that's going to include some user information and our menu. Let's first start with the user information. We're going to want an image, an img tag, that specifies a picture for the user. Then we're going to have a span. A span is an inline section of code. Paragraph is always blocks of code, spans are always smaller sections of code. And here, we'll have the name of the login user. And I'm just specifying a dummy name of Sam Hastings for now. In order to fill out this image, we're going to need to specify a source. But we don't yet have images that we can reference. So images are more static files, so we need to create a section in our www root for them. I'm going to create a new folder I'll call img for images. Again, what you call these and what the folder structure is is up to you. But for our needs, this should be fine. I'm going to add an existing file. I just have a Resources folder that, if you have the right subscription and have access to all the source code, then it'll include these images. But this could be any image. This is, in fact, just an image of some guy's head. And you notice that Visual Studio is going to give us that preview when we hover over it. But let's go ahead and, in the HTML, use that as a source. Notice we're getting IntelliSense for the source. It knows that all these are going to be inside the www root. So we can go ahead and say img/user. Image tags also require another attribute called alt. Alt is the alternative description of the image. Not everybody that uses the web can see. So where people are using screen readers, this alt becomes pretty important. So it's a required element of image. I really encourage you to fill it out. And I'll just call that headshot for now. We'd like to style this image. This image might be too big in some cases. We might not have control over how big of an image we have stored for each user. So we might want to force how large that image is. In fact, if we look at this in the browser, we'll see the image is pretty large. So we're going to want to constrain that for design purposes. We can do that with CSS. Now, we could come in here and say #sidebar img, and I'll use max-width of 50 pixels. And what this relationship does, notice there's no comma here. It's not sidebar or image. This is an image that's inside of the sidebar. This, including two selectors next to each other, says, Walk down the hierarchy. So any image that ends up being inside of this section will get this rule applied to it. We can see that it actually works. But it's not a terribly good idea in the case of image, because you could be using a lot of other small images somewhere in this sidebar, and suddenly you'd have two things competing. So another thing we can do is actually give something a class. Because there may be more than one of these on a page, remember id specifies an individual object on a page. A class says, This is going to be a class of objects that are on the page, but I want to use my own naming. So I'll call this the class of headshot. So instead of using the sidebar and image, we're going to actually use that class. And class selectors start with a period. So now that we can specify anything on the page that is this headshot with its own properties. We can see it still works. Let's go ahead and create our menu after the image and the span. We're going to use something called a list. Now, there's two types of list. There's unordered lists, which are ULs, and then there's ordered lists, which are OLs. Ordered lists are for numbered lists, one, two, three, four, five, etc, whereas an unordered list is like a bulleted list. So we're going to use an unordered list for now. Both type of list take something called an li, which is a list item. This is something that is going to be shown as an individual item in the list. So I'm going to create pages to go to. Let's just start with three simple pages, Home, About, and Contact, three pages that most websites have. In the case of these, I want to actually have these as hyperlinks. I want people to be able to click on them and go places, so I'm going to use what's called an anchor tag. An anchor tag is one that starts with an a, and then has an href for where clicking of that should go. Because we don't really have our website structure yet, I'm just going to put a pound in there for now so that we can click on them but they won't go anywhere. And I'll do the same for each of these three. Do a little editor in here and just copy the tags in. When we watch the page now, we can see that we have our menu as a bulleted list. We might want to change the way this looks. First thing I'll do is say that this unordered list, I want to give it a special name. So iIm going to give it a class of menu. So if we have multiple menus on a page, we can use the same set of rules for it. Back in the CSS, I'll create a menu class for the entire unordered list. In our case, we'll just make the font a little smaller since it's not crucial that someone can see it as well as they can the regular content. If we look at this now, we'll see that the size of each of these elements is a little smaller. What we might also want to do is, specify for our menu that each of the list items should get rid of their bullet object. We can do that with list-style-type as being none. Could also change it to a disc or a dash or whatever you want. But in our case, we actually want to get rid of those bullet points, make it look more like a menu. Again, because this doesn't have a comma, this is saying all the list items inside of the menu. For in the menu, we're going to find all the li objects inside of it and specify their list type. There the bullet points go away. We might actually want to have one more class that we could add and apply to the menu item. Here in the menu, we know that we're on our homepage. So let's go ahead and add a class to just the first one of these called active. What you call these doesn't matter. I'm not using any conventional or standard ones. I just want them to be scripted so people reading the HTML can make sense of it. In our case, I want active to be the active page we're on, and then I could use CSS to style it differently. Again, I'm still going to be menu, still li, but in this case, it's going to be the active list item. And all I'll do here is say font-weight: bold, and refresh it. Notice that Home isn't bold. It should have actually grabbed this Home as the wrong one. And the reason it didn't is because of this nature of the way that selectors work. I really want you to understand this. I told you that li after menu with a space after it meant all list items inside of menu. Well, the same thing is happening here. This is saying, List items, any children of list items that have active applied to them, make them bold. So if the anchor tag had the class here, it probably would work. But we really want to apply it to a class that is a same element as the li. The trick there is to not include the space. This is effectively saying, Only match this to li's who have the class active, not who have an object inside of them that is active. By removing that space, and that space can be sometimes hard to notice or remember, we'll now see that the current page is now shown as Home. So by using a mix of both the id tags for individual objects on our page and the classes, you can actually start to look and identify the individual elements that you want to control the rendering of using CSS. That's where CSS naming comes in. Let's talk about the box model next.

The Box Model

When working with HTML and CSS, understanding how things are laid out on the page has to do with something called the box model. The box model is the rules for laying things out on a page and sizing them. The box model starts with whatever your content is. This could be the text inside of a paragraph tag, this could be the input box, it could be any sort of content in HTML. Outside of that, there's a section called padding. This is the room around the content that the content wants to give it some space between it and the next level of content. Around the padding is a border, an optional border, but a border. So you could specify that a dotted line or solid line could be around the content, and the padding is in between the border and that content. Then we have a margin, so outside the border itself, there is room to space out the content. So padding and margin are similar, but they have to do with whether they're outside what is visibly shown in the elements, so the border in the background, versus what is shown inside the element, so inside the border or shown inside the background. When we're displaying things on the page, we can specify properties for where it is physically in the page, where it is from the left, the right, the top and the bottom. And the contents itself can have properties for both height and for width. At runtime, you can also test for two more properties, actual width and actual height. It's important to understand that the actual width and height are the size of the element that includes the border and the padding, but not the margin, and has nothing to do with where it's located, top, left, right or bottom. So this box model takes all of these individual pieces in consideration for how it's going to lay it out on a page. Let's take a look at some CSS and lay out our different elements so you can see how these end up playing a part with each other. Let's start with the head shot. Let's give it a border and a padding so we can really see the difference there. I'm going to going to give it a border. The syntax for border which we can see here is what's called a multipart syntax. This contains individual elements or individual properties that we can specify, one pixel solid red is going to give us a line of solid red around it. So for us, I'm going to say 1px solid, and then give it a color of 222, just like the other colors we're using here. If we go and look at this on the webpage, we can see now, it's a little hard to see probably in the video, but there is a small black line around it all. You can see it more around the bottom of the shirt. But I want there to be some space between the border and the picture. So I'm going to specify a padding here. I'm just going to specify about 3px, just to push it out from the box a little. Now we can see that. Now, notice the whole page got moved a little because the padding and the border are both taking up space, and so it had to allow for that extra space. The width of the picture is still maximum width of 50. So the real width of this element is 50, plus three and three for the padding, three pixels on the left and the right, and then the one pixel of border. So it's actually, if we do the math, 50 plus three plus three, which is 56, and then plus one, plus one. This is actually 58 in width. This is where a lot of developers get in trouble when they're trying to line things up. This says the width is 50, and I put something else so this width is 50, and they're not quite lining up. And that's almost always about the border and the padding not being the same. Let's show you another example. In the footer, our footer looks awfully crowded. So let's use some padding to give it more space. Now, I could give it a padding of, let's say, eight pixels. And that's certainly going to push it out in all directions. But what if I didn't want a padding of eight on all four sides? What would I do there? Padding actually allows you to do a few things. One is, we could actually specify padding left, right, bottom, as separate properties if we wanted to. And if we were only setting one, that makes a lot of sense. Otherwise, we can actually specify the padding as one, two, three or four numbers. So in our case, if we say 8px 8px 8px 8px, that's going to be the same as just saying 8px. This is specifying eight on each of the four sides of the element. By specifying only two, the first number's going to represent the top and the bottom padding, and the second number is going to represent the left and the right padding. And so they're married in that way so that you can handle the common case of having more padding left and right than top and bottom, or vice versa. Let's go ahead and give our left-to-right padding something smaller, like five. We can see that the whole element moved just a tiny bit to the left. Three pixels isn't a big change. But you can see where we're going there. You can also specify just three, and three would be giving you top, left and right, and then bottom. But that's pretty rare to use. I'm just going to use the left-right in our particular case. So here on the main one, I want to add that same sort of padding. I'm just going to use a padding of four pixels. And I have a particular problem with main, and that is there's some extra space here before we get to the edge of the actual frame of the browser. So one fix there is to actually set its margin to zero. That's purposeful and sane zero. It's a best practice if the value that you're dealing with anywhere in CSS is zero to not specify the unit, as well. Zero is zero, doesn't matter whether it's inches, pixels, picas or whatever. Zero is zero and so that's how you're going to want to specify it. Now let's style that sidebar. One of the things about the sidebar is, we really want to display itself on the left-hand side. So I'm going to include a rule for sidebar that specifies what the background is, what the foreground color is. But this time, I'm going to say position, color, fixed. And fixed is important here, because fixed tells it that we want it to be in a fixed position, that as we specify the left, the right, the top or the bottom, it's going to be specifically drawn in the exact place in the browser that we want it to be. In fact, this is married with left: 0. Left: 0 says, We want this to be on the left side of the page. And then we have a couple of others here that are important. Height and width. Height at 100% is another kind of unit you can use. Height being 100% is going to mean that that sidebar is going to take the entire vertical space of the page, up to a width of 250 pixels to the left-hand side. And overflow: hidden means that anything that gets out of the section of the sidebar will be clipped instead of just displaying over. With these in place, we should be able to see our sidebar now. Now, of course, one of the problems we have is, the sidebar, because it's fixed, is being drawn on top of all of our other elements. And that's not good. We could change each of these elements to push them out beyond where the sidebar is, but that's not really what we want to do. What we're going to do instead is, take this div we had created that contains our main and our footer, and we're going to go ahead and give it a name. I'm going to call it our wrapper. For the wrapper, I'm going to set its margin left to be the same size as the width of the sidebar. Effectively, it's pushing us over from the left-hand side. Now, I could have said fixed and said left: 0, as well. But I want this to take as much of the page as possible. So all this will do is push all the content in from the left 250 pixels. Again, it's not a coincidence it's the same value as the width of that sidebar. We're really marrying the two so they end up next to each other. So we have our sidebar and we have our elements. But you'll notice that there's some space in between them. And I'd like it to be a little cleaner than this is. To do that, I'm going to make sure that all of the other margins are zero. Because we've specified one of the values here, let's go ahead and use margin to clean this up. We want zero for the top, zero for the right, zero for the bottom and then 250 for the left. But we still have all these spaces. We specified all the elements on our page to not have space. Why do we still have space here? The reason for this is that we have to actually tell the body that we want it and all of its other elements by default to have a new margin of zero. So when you remove all the individual margins that are sticking on the other elements on the page, we finally get that more clean, app-like experience we want. The only other layout issue we have is that our footer is still floating way up here because we don't have a ton of content. The trick there is to go find the footer, and let's change its position to fixed, and set the bottom to zero. Because left, top and right don't have property set for it, it's going to take this bottom and make sure that it adheres to that. We're going to set the footer to start at the edge of the bottom of the page. But once we change it to fixed, we'll see that it doesn't want to take the entire width. So we also have to add width: 100%. So now we've got a fairly good starting point for what our app's going to look like. We're going to make a lot of changes, don't worry. But for now, we can really see, by using the HTML to create the structure of the different parts of the page and then CSS to design how they're going to look on the page with the box model on the position and using naming and using selectors, that we're starting to get a sense of how we're going to structure our web app by using these very simple structures of HTML and CSS to work together.

Summary

I have glossed over a lot of fine points of HTML and CSS on purpose, because we're trying to get through building an entire application and touching on each of these topics, so that you can get a sense of them but not necessarily understand them in a rich or deep way. If you need to go deeper to understand these, I have a Front-end Web Development Quick Start that goes over each of these elements in a bit more detail. And here you can see a link to that. Alternatively, if you really want to understand CSS, there's a CSS In-Depth course here on Pluralsight, and here is the URL for that. For really understanding CSS top to bottom, I suggest this CSS In-Depth course very highly. So where does that leave us? We've seen how this HTML and CSS basics can help us derive and build from these primitive pieces to create a rich and full web app experience like we want. And the HTML is going to represent the structure of every individual page that we're dealing with. CSS is going to then take that structure and tell the browser how to render it, and that we want to keep these separate so that they're easier to manage. As we get into JavaScript and get into frameworks, especially client-side frameworks, we're going to see that keeping the structure and the CSS separate are going to end up benefiting us greatly. That also allows us to specify things about the way our application looks and feels without having to repeat it on every page. This has been Shawn Wildermuth, for Building a Site with ASP.NET Core RC2. Thanks for watching.

JavaScript

Introduction

Welcome back, this is Shawn Wildermuth of Wilder Minds. In this next module, we're going to talk about JavaScript. I'm going to go a brief introduction of JavaScript, just to get you started. This will introduce you to some core ideas about the language. We'll talk about using JavaScript in your projects, I'll introduce you to jQuery, as well as Bower, for package management. Let's get started.

What Is JavaScript?

For the purposes of this module, we're going to talk about JavaScript, simply, in how it can be used as the client-side language for your web applications. JavaScript is useful in a number of different other scenarios, server-side with Node.js, being an obvious example. Before our needs, we're just going to focus on using JavaScript inside of HTML pages, as the client-side of our apps. What exactly is JavaScript? It's an object oriented language that uses Prototypical Inheritance instead of Classes. Since you're probably coming from a .net background, you're already used to using objects in the form of Classes. JavaScript does that in a different way, using things called Prototypical Inheritance, though Classes are coming, in an upcoming version of JavaScript. JavaScript is also dynamic, so the types aren't fixed at compile time, because there really isn't a compile time. Types can change over time, new properties can be added, and even properties can be removed. Often, JavaScript is accused of being typeless, of everything being a variant, and that's not true. It's simply dynamically typed. While JavaScript is an interpretive language, there is some confusion about the compilation of JavaScript, and what can be done in that sense. The reality is that JavaScript can be just as performant as other languages, like languages of the .net framework, or even Java, because the compilation step, in things like .net and Java, is to produce an intermediate format, that's eventually actually compiled on the fly, just-in-time compiled. JavaScript, in most cases, is just-in-time compiled. When you look at the way that JavaScript is being used in Firefox, in Chrome, in IE, and in Safari, in all those cases that JavaScript is actually being compiled down to machine code, as it's being used. If you're very familiar with .net, you'll know that this is the same way that normal just-in-time compilation works with .net. So you can expect some near level performance with JavaScript. It's not exactly one to one with other, less dynamic languages, but it is within the neighborhood of that performance, except in older browsers, where just-time compilation isn't being done, where it's simply just being interpreted. Let's take a look at some code.

Hello JavaScript

Let's take a look at JavaScript, in its simplest form on a webpage. Here in our project, let's go ahead and open up the index HTML that we were working with, in the last module. Down near the bottom, we'll create a new element called script. Script requires that you tell it what type it is, and in our case, that is text/JavaScript. We're going to have a script that is going to contain JavaScript code. In here, we can simply write some JavaScript. The var keyword is going to start the creation of a new variable. I'll just call that ele. I'm going to dive into the page itself, I'm going to go look at the .HTML document, by looking at the document object. You can see, we're getting some Intellisense here. Intellisense in JavaScript, inside of Visual Studio is good. It's not great, but it's good. You're going to get Intellisense in a lot of cases, but not in every case. It's a little different than if you've used C#, and you're used to the really rich Intellisense, we're getting with C#. This is going to help us out, but it's not going to be perfect. I'm going to call a method called getElementById. This, unsurprisingly, probably, is going to allow us to get an object on the page someplace, that has a particular ID. It returns that object that represents that live part of our page, directly to the code. If you remember, up here in the sidebar, we have this span than has the user name in it. Let's go ahead and give it an ID. Let's call that just username, all lowercase. Down here in the code, I'll just say, Go get that object called username. Now that I have this element, I can do a number of different things in looking at assigning Classes, setting styles, all sorts of little things I could do with it, in this, sort of, raw form. But instead, I'm going to replace the text that's inside of that span, with what I want the text to be, so I'm going to say, innerHTML. This will actually let me set the HTML content of that span, since it can contain any sort of HTML. My case, I'm just going to go ahead and add text, and I'll go ahead and just put my own name in there. If we run this page now, we'll see that the name has been replaced. Now, the interesting part of this isn't that we couldn't have just simply put the name into the markup ourselves, but that we actually did have code execute and run to perform this task. Now, we could've had this task performed, based on the user doing something, some code coming from a server. We could've done this task based on reacting to some other action on the page. This means that this markup, this HTML we put together, is really describing the structure of a page that we can manipulate at runtime. That starts to be the power of what web development can really do, is it can change, and mold, and manipulate the dom, in reaction to users using your page. That can be a very important and powerful idea. If we go ahead and look at the HTML page, you may wonder why I put the script at the bottom. I did this because the way that browsers consume an HTML page is, it starts at the top, and as it parses it, as it reads it top to bottom, it is taking the pieces that are involved here, and constructing this document. Scripts are a little different in that, when it constructs this part of the document, it actually tells the JavaScript parser, Ooh, this is JavaScript, please parse this for me. There's an order that matters here. On slower devices and slower machines, getting to this piece of script helps us guarantee that this is not going to happen until this has already been read in by the parser. Because the JavaScript, itself, isn't going to wait until the HTML page is ready, unless we do something to tell it to wait until it's ready. By default, this will execute after everything above it has been already parsed. You increase the likelihood that this code is going to execute, after we already have the element on the page. We'll see some techniques for ensuring that it happens late enough, that the page is always been constructed correctly. Putting scripts on the bottom is a best practice, it's a common occurrence, to make sure that they execute after most of the HTML page has been constructed by the browser. The problem here is, that if we construct scripts directly on the pages themselves, there's no way to reuse them, there's no way to create reusable parts of JavaScript, that multiple pages could potentially use for themselves. Typically, we're going to create the HTML on the pages themselves, but separate them again, much like we did with CSS, into their own folder and files. Over here on the left, I'm going to go ahead and right click on wwwroot, and create a new folder, that I'm going to call js, for JavaScript. Again, the names of these folders aren't as important as their existence. I'm going to use my shift + F2 technique to create a new file, and I'll call it oursite.js. It's going to blank JavaScript file. I always like to start with a comment in the name of the file, so that it's a little easier for me to know it's there. Let's take, from the HTML page, the contents of what we were going to do, going to just cut it and paste it into oursite.js. Now that we have JavaScript code in oursite.js, let's go ahead and add it here, by using the source attribute. This will allow us to bring in this file, and request it from the server, and get it, and then apply it on this page. It'll be parsed once it's been downloaded across the wire, just like any other resource that your page needs. We go back to the browser, and let's just refresh. We can see this still works, even though it's pulling the JavaScript from a secondary file. It's still loading it, executing the JavaScript, which, of course, changes our name from the normal name, over to my name temporarily. Now, we've seen how to take JavaScript created inside the project, and then, have a reference to it inside of our HTML pages. We can see that that all works. Let's delve into events next.

JavaScript Events

Next, let's talk about JavaScript Events. Back here in the index.HTML, you may remember in the last module, we created this section called the main div. We were styling that section using some CSS. But now, we want to interact with that section and events, and luckily, we already have this section named. Over in our JavaScript, let's create a new variable called main, and let's get it with that document, getByElementId, just like we did before. But this time, we want to wire up to events, not just set properties. One of the events we want to wire up, is mouseenter. Mouseenter is an event that happens as the mouse hovers over an element. We're also going to do the same for another event called onmouseleave, which is fired when the mouse leaves the area that contains the div. In JavaScript, one of the ways we can wire up these events is, actually, to assign a function. This is an unnamed or an anonymous function that is called, when this event is fired. If you've done C# before, this should look actually somewhat familiar, because this pattern is used in C#, as well. In this case, we're not adding it to the handler, we're assigning it to the handler. We can do that in both of these cases. We now want to take the object and do something that we can actually see. On main, there's a property called Style. This will allow us to change the different parts of the CSS, really, the rules for this object. One of the properties on that is, actually, background color. Let's set the background color to some gray property, and then we when we leave, when the mouse leaves that section, we'll go ahead and send it again, but we'll change it to just an empty string. We're essentially changing the look and feel of that page. Let's run this and see what happens. Now, we can use the mouse to hover over this main element, and you can see it get darker, because we're setting the background color to #888, which is a gray. As we leave, it gets back to that old gray, because we're no longer overriding it on the element itself. This pattern of handling events, by using callback functions, is a pretty common one in JavaScript, and one you'll want to be used to. We do have an odd problem though, with the way that this sort of JavaScript works. Let me show you. We take the copy of our URL, and put it in another browser like Edge, we can see that it works, in different browsers in exactly the same way. But let's go back to our code, and what if we had written this in a different way? A way that's perfectly valid, but written differently? I'm going to change this to actually setting the entire style, and we're going to set this up like a CSS value. Here, we'll do the same thing and set the style to empty. If we go back to Firefox or Chrome and refresh this, we'll see this continues to work fine. Over here in Edge, if we refresh it, it stops working. We have a consistent problem in the JavaScript world in that, the different browsers have implemented these APIs in different ways. We'd like to find a way to make it so we don't have to think about what is the right way to implement each of these different things, whether it's an event, or whether it's setting properties, so that it'll work across different browsers, without any concern. Because when you build these webpages, you have to make sure that they work, not only in the different desktop browsers, Safari, and Chrome, and Firefox, and IE, or Edge, but also, on mobile browsers, like the default Android browser or Chrome on those devices, or Safari on iOS devices. It's a lot of different browsers to be concerned with, and to have to write specialized code to do that, could be really difficult. That's why we're going to talk about JavaScript later in this module.

Global Scope

Now, let's talk about the Global Scope. Our JavaScript, as it sits here, may not be the only JavaScript that's being loaded on a page. In fact, for large web apps, you end up using a lot of different JavaScript files that many of them may be loaded in memory, for your particular page. You start to run into the problem of collision. What if commonly used variables, function names, are being used by different files? Because the way that JavaScript works is that, as files are loaded, they may overwrite what other files do. What if we have two different JavaScript files that both define variable called ele? The second JavaScript file that defined ele would overwrite this one. This one would disappear, would eventually be garbage collected out of existence, same with main. We could start to use really specific names. Like I could say, site_js_ele, to make sure that we don't have that sort of collision. That's not really what you want. We're getting this collision, because all of our code here is being executed in, what's called, the Global Scope. A scope is simply, sort of, a container for names. Every named piece, variables, functions, et cetera, get attached to this Global Scope. In the case of web development, that Global Scope is actually at the window level, so that whatever is in that browser window, usually on that individual tab, all get loaded in that same scope. We want to have a way to sort of minimize adding things to this global name space, this Global Scope. One of the things we learn quickly in JavaScript is that, functions provide their own scope. Things created inside of a function aren't visible outside the function, because the function itself has its own private scope, so you don't have to worry about this collision. Common solution to this is, to just wrap this all in a function. Let me call it something like startup. In this case, any code outside of this function doesn't know about all the private information inside of it. But if we go ahead and call startup, right as this is loaded, we're hiding most of the guts, most of the ugliness of what used to be global objects, inside the function. In fact, if we save this and show this in the browser, we'll see all the code is still executing, right? But having to do this particular idea, we're still leaking a name into that Global Scope. This file may be overwriting some other function out there called startup in another JavaScript file. Managing that is difficult, so we don't really want to do that. The pattern in JavaScript is something that goes by a couple of different names. Either it can be a self-executing anonymous function, or sometimes, referred to as an immediately invoked function expression. The idea about, whichever way you call this, is a nameless function, that is then executed immediately. The way we do this is, we can get rid of the name of a function, so this becomes an anonymous function. It's still a function and can be executed, but it doesn't have a name for it to be executed under. If we wrap it all in parenthesis, this ends up being one big expression. This expression, return to function, therefore, to execute it, we can add two parenthesis to say execute. We could actually supply parameters here, as parameters into this function. In most cases, what we want in a self-executing anonymous function, or an immediately invoked function expression, is just to find this is a function, declare it outside the Global Scope, and then immediately execute it, so that the code actually gets run. You can see if we take this new form and refresh the page again, that code is still executing, but now, it's executing outside the Global Scope, so we don't have to worry about all that name collision nuisance. Next, let's introduce an idea about dependencies in JavaScript.

Using Bower

Let me next introduce you to a tool you'll use with JavaScript, called Bower. Normally, on a .net project, in Visual Studio 2012, 2013, 2015, if we want to use third party projects with a .net application, we would use NuGet. We right-click on a project, there's actually a Manage NuGet Packages UI. Pops up and let's us look at certain projects out there, and add support for them into our project. We want to use jQuery. JQuery actually has a NuGet package with it, but this NuGet package installs it into the project, in a way that's more compatible with ASP.net 4 and below. That's because there were certain ways that the older versions of ASP.net worked, and NuGet was really the only way to do package management in those projects. In ASP.net 5, they really have separated these ideas. We're still using NuGet for our server-side dependency management, but they want to differ to something that most of the web development community already use, to do client-side package management. That's what Bower is, Bower is a tool for doing that. Let's come in here, and it's going to start with a configuration file for Bower. Let's go ahead and add a new item. One of the things we can add is, under our client-side, is a Bower configuration file. This creates a file called bower.json, in the root of our project. This is just a configuration file that lists what dependencies are needed for this project. Normally, you wouldn't check in these dependencies, but when someone gets a version of the code, they would let the IDE or let Bower, re-download, and re-fulfill those dependencies, and the dependencies of those dependencies. For example, there's a project that's often used called underscore. I'll actually use it later in our project, so let's bring it in here. We can add it as a member of this dependency object in the json scheme. The way that these editors work is, as I put in the name, you can see, I'm actually gaining Intellisense, by reading the repository that Bower has, of all the different projects out there. It's doing some Intellisense to see what projects exist, and we want the plain, old underscore. When we do a colon, it adds some quotes, and then, Intellisense is reading the current version of that project. Now, I could get 1.83, which is the latest stable version of underscore, or I can say, Get 1.83, but if an upgrade happens, that's okay. We're getting about this version, and that's what the tilde means in front of it. What happens when I save this file, when I add this into my project, is that Bower is going and downloading the project into our wwroot for me, because it knows it's a client-side file. In fact, we now have a lib folder here, that has underscore, and in the underscore folder, are the pieces that make up underscore. Most importantly for us, is an underscore.js or an underscore-minjs, which is a small version, a compressed version of it, that is normally used for development against. You could see underscorejs, would be the full source, and then the min version is the one you would use at runtime, because it's smaller to download, it's smaller to parse, that sort of thing. How did it know to put it in this magic folder? Where is that setting? When we installed the bower.json, it actually also installed a second file called .bowerRC, which is the configuration options for Bower. If we double-click that, we'll see that it actually specifies the directory that Bower is going to install in. By default, that is our wroot lib. If you want this folder renamed, just some other name or structure that you prefer, simply changing this name will change where Bower drops them. For our needs, the default space that Visual Studio is installing with this file is good enough. We can ignore that bowerRC file from now on, and just know that every time we add a dependency here, we're going to get it inside of a lib directory, inside of our wwroot. What we're really looking for here is jQuery, and jQuery is another library that's very common in use in web development. Our project's going to be no different, we're also going to need jQuery. Just like I did before, I'll give the name of jQuery, brings me in, shows me some versions, and I'm going to tell it to get me about the latest jQuery version. As soon as I save this file, as soon as I make that change, these dependencies are being loaded. I now have jQuery under my lib folder. In fact, if I really want to see how these dependencies work, we can see that, under the dependency tree, is now a list of our Bower dependencies. I open this up, I can see the different dependencies. If they had other dependencies, if jQuery depended on some other library, they would be shown under here, as well, because what Bower's really doing is saying, Go get the thing I need, and anything that it tells Bower that it also needs. As we build libraries on other libraries, this is pretty common. This tree view here is a way to quickly take a look at them. This flies in the face of maybe how you may be used to using dependencies or third party open source projects. You may be used to going and downloading it, and dropping in a folder, or using command line tools to go ahead and install it. This is one of the things I really like about the way that Visual Studio is doing it, is that we're actually maintaining the configuration files, and it's noticing the change, and changing our environment for us. In fact, this works the same, with our project json file, and later on, even with our NPM dependencies for tooling. Now that we have jQuery, let's take a quick lap around jQuery, so we can see why we might want to use it, instead of this raw JavaScript that I showed you how to write already.

Introducing jQuery

Let's use jQuery in a simple example, and, in fact, re-implement what we did in raw JavaScript, using jQuery, so you can understand why it's a better solution. The first thing we're going to need is, over in our index.HTML, we're going to need a new script line. Before our code gets executed here, we're going to need to bring in jQuery. We can do that by writing another script tag. We'll see that Visual Studio's giving us the project structure of our wwroot, so that we can build these URLs to these files a little easier. I'll go down to lib, jQuery, and in the case of jQuery, it doesn't have the JavaScript files at its root. Has the source of jQuery, which might be useful for looking to see how it works, as well as a dist folder, which is fairly common in these scenarios. That's a distribution folder. We'll say dist, in there we see the jQuery, uncompressed version and then the compressed. I'll go ahead and bring in the compressed version. Finish up the script tag, and now we can go back to our site, JavaScript, and let's use jQuery in here. JQuery exposes a single object to the Global Scope for use, anywhere in these JavaScript files, and that global object is called jQuery. This jQuery's also aliased in the Global Scope as a dollar sign. This dollar sign or jQuery, whichever way you want to write it, though most people write it as dollar sign, because it's short and more concise, exposes a number of methods for doing different things, like making network calls and manipulating the UI. It's called jQuery because its whole purpose is to be able to query the document for individual elements. It does this using CSS selectors as a language for it. If you remember back in our CSS file, we had selectors like body and label for getting element types by name, then we had this pound syntax for IDs, and we had this dot syntax for Classes. That is the selector syntax that jQuery also uses. What we can end up doing is, we can replace this document.getByElementId, with the jQuery syntax of dollar sign, and then, parenthesis, because what we're really doing is we're executing the jQuery function, and passing in parameters. In this case, the parameter we're passing in, is #username, the CSS selector to find this object on the page. Why would we use this syntax? The reason is, as different browsers have small, different variations in the way that they're document object API works, it's getting closer and closer that all browsers do the same things, but that hasn't always been true. Problems of having browsers, like the older IE versions, or new browsers come in with different capabilities, jQuery was there to say, Here, use our API, and we'll handle the cross browser, the multiple browser problem for you. We promise you that when you do $#username that, regardless of what browser we're in, we're going to go find the element on the page with an ID of username. We're going to guarantee this for you. This was a really important step in web development, because before this, we had to test for what browser where we're in, and often write the same code, two, three, or four times, based on what browser we were using. Now, the getElementById, that was pretty ubiquitous, that was being used all over the place. But when you started to get into some of the small changes, like innerHTML, because the spec was a little ambiguous, and in some cases, the spec was written after the browser was written, in some browsers is a innerHTML with all uppercase HTML, like we see here. But in some browsers, it was HTML, and in other browsers, they were simply missing this, and they had it in a different name. We had this problem of, which one do we use? Do we say, Ooh, this is an IE 5.5 only website, which, of course, limits your customers. Do we check for the different versions of the browsers, and do it multiple times? Or do we do something like using jQuery to make it simpler? JQuery just says, I want to set the text of this object. In whatever browser I'm in, I'm going to guarantee that text is going to set the text inside of an element for me. If we look at this in the browser, unsurprisingly, we'll see that Shawn Wildermuth still works, still does what we expect it to. Events where another place, where the different browsers could handle it, in different ways. Often, the same event had different names in different browsers. Again, we started using jQuery, with their CSS selector syntax here, to make this a little easier. Instead of saying onmouseenter, we actually call a method called on, and use mouseenter as the name of the event, and then we're still using a function as a callback. Now, a couple of interesting things here is that, you'll notice that on and text are both functions, and that's because it tries to make all of the types of calls, having the same style of API. In our case, this style of API is using function calls. The first parameter is often some data, but the last primer is, almost always, a callback of some sort. We change this again. This will make sure that our code is much more capable of running the same experience on different browsers. Now, of course, if all your customers are using the latest versions of Firefox and Chrome, this might not be necessary. The reality is it's not true. Some of your customers are going to be on an Android tablet, some of them are going to be on PCs that are new, some of them are going to be on really old Windows XP, with IE 5 on them. Do you want to really serve all those clients or not? That's one of the purposes of jQuery. In both of these examples, the elements we're getting are returning single objects. The idea of username and the idea of main always, are going to return one object, because each item in a document must have a unique ID. If not, we're only going to end up returning one anyway, because it's going to violate that rule. But it's different for CSS selectors that might return more than one value, like classes or even arbitrary CSS selectors. Let's create another one, and let's call this menuItems. We look at that HTML page, we'll remember that there is is this menu, unordered list, that has some list items in it. We might want to handle, when the list item anchor here, is actually clicked. Now, if we had to have everything with an ID, we'd have to go through these, and name them individually, and then handle the events for each one of those, and that would be painful. JQuery makes this simpler, because we can use the syntax of ul.menu, so the unordered list with the Class of menu, li for the list item, and a for the anchor. We can do all of this to say, We want to do something by storing the actual items, the actual anchors, inside of this structure, using the same CSS selector syntax. because if we had decided, in the CSS, to format that, we would've done the same thing. In fact, we did some of that by saying, menu li.active, and we could've done menu li a, color, to change the color of the text. We certainly could've done that. What do we do, now that we have these menu items? How do we get at each one individually? We could look at menu items and check for the first one, the second one, the third one, but one of the geniuses of jQuery is that, we can actually handle events on all of these, using one callback. If I say, on(click), with a function that's calling back onto it, this will actually work by attaching an event to all these menu items all at once. To put a little alert in here, and just say, Hello. Let's refresh it. When I click Home, we can see Hello is showing up, if I hit About, Hello is showing up, if I hit Contact, Hello is showing up. What this is doing is it's effectively taking our one function, and wiring it up to the click of each of those elements on the page. It's not creating a new version of each function, it's more efficient than that, but it is saying that, As long as you're clicking on one of these, we're okay. More interestingly is that, we can actually get at the item that is being clicked. In our case, we might want to show the text that's inside of the anchor, inside of our alert, so let's do that. I can do that by wrapping the this pointer. Now, this has represented the object that the function is related to. By wrapping it in a dollar sign, parenthesis, we're saying, Make this into a jQuery object for me, because I want to use jQuery to look at the object inside of this menu handler. Then, I can just say, me.text. Now, remember, I used text up here to set the text, but if I don't include a parameter for the text, it returns the text that is contained in that element I'm looking at, and in our case, that'll be what's inside the anchor tag. With this change, if we refresh, when I click on Home, it'll now show Home, because that's the text inside, or Contact, which is the text inside, or About. Obviously, you shouldn't use alerts for our whole UI, but you can get a basic sense of this, of how it is supposed to work. We've seen some basic things that jQuery can do. Let's use it to actually add some functionality to our page.

Practical jQuery

Now, let's use jQuery to solve a practical problem. Back in our js file, none of the things we've been doing so far, are actually all that interesting. I'm just going to comment them out. They were little examples, but they're not actually doing something real. What we want to be able to do is take our page, in this sidebar, we'd like to be able to show and hide it, by simply clicking a button. We can do this by, let's first create that button. In our main, since that will always be shown, let's put the button there. I'm going to create a quick div, and then just an actual button, and I'll call it sidebarToggle, and I'll just say Toggle Menu. If we look at this in the browser, we can see we now have a little button. Looks like a button, it doesn't do anything, because we haven't wired any code to it, but it gives us a starting point to actually run some code. We go over to our site. Let's, first, get at the objects that we're going to be interested in. First thing I want to do is, I want to get both of those panels. Because if I'm going to use CSS to change the way the panels look, but I first need to be able to get at them. In our case, we're going to apply a class to both of these panels. In the index, we can see that there is a wrapper panel, and then a sidebar panel. We want to actually get both of these objects together in jQuery. We can do that using the selector syntax. I'll say, sidebarandwrapper, sidebar, wrapper. That's another CSS selector syntax, that says, Get me both of these. This ends up being an and. Get me the thing called sidebar and the thing called wrapper, and return it, as what's called a wrapped set. It's a wrapped set of dom elements, that is sort of the cornerstone of the way jQuery works. I like, conventionally, in JavaScript, that if I'm using jQuery, I will start the name of my object with a dollar sign, so that I can more easily, as I read it, know that this is a jQuery object, a jQuery wrapped set, in this case. What I want to do is use the sidebarandwrapper, and use a method called toggleClass. ToggleClass does, is it will add a class if it doesn't exist, or remove the class if it does exist. It eliminates our need to saying add class and remove class, it just says, toggleClass. In our case, we'll say hide-sidebar, it's going to be the name of that class we're going to toggle. Now that we have it toggling, we have to toggle it based on something. Let's use jQuery to go get sidebarToggle. Here, I'm just going to call on, and I'm doing it directly on the return of the jQuery function, because that's often common, if I'm not going to use this element more than once. Sidebar wrapper actually, you need to use in a couple of places, so we got that separately, but for the sidebarToggle, we only need it once. When we click this sidebarToggle, we should be toggling that add sidebar class, as necessary. Let's look at this in the browser real quick. If we refresh the page, and let's use the F12 tools, different browsers will show this in a little different way, but I'm showing you Firebug in Firefox to do this, though Chrome tools are going to be similar. I'm just going to show the sidebar and side wrapper elements in the div, in the live version of that document. If we come over here and click that Toggle Menu button, we'll actually see the class being added. If we click it again, it will clear the class. Add, clear, add, clear. This gives us the opportunity with CSS to say, Oh, when hide sidebar is here, we're going to change the way both of these panels look. Let's open up that CSS page, and let's start with the sidebar. We'll say sidebar.hide-sidebar. This is going to be a rule that's going to take effect, let's move it up a little, when we're hiding the sidebar. One of the things we can do is change the left. Left, right now, is at zero, which is the left hand side of the page, but if I say, -250px, it should take it off the page. The reason it's 250 pixels is because that's how wide it is. Eventually, you'd want to keep these in sync, if you decide to make the width 300 later, you'd have to make the left minus 300 to hide it off the side of the page. Let's show this working, get rid of the debug window for a minute. But if we refresh it and then click this, it'll actually disappear off the page. But, of course, we aren't making what's left of the page any wider, so that's what we'll do by doing the same thing in wrapper. Here, we're using a margin of 250, in order to make room for the sidebar. Here, we will simply say margin-left, zero, when we want to hide the sidebar. Instead of having that gap for the sidebar that we put in in the CSS chapter, we're going to get rid of it, when that hide sidebar is there. If we refresh it again, and as we toggle it, we'll see that it's showing and hiding, exactly the way we would want to. This is a way of using JavaScript to get the kind of functionality we want. This is working now, but I don't like that it just says Toggle Menu, I'd like it to actually say, Show and Hide. I'd like to be able to do that in that same way. Let's go ahead and do that in the JavaScript. Back in the JavaScript, if we come over here, and after we toggle it, let's just do a little test. If sidebarandwrapper has class, hide-sidebar. If the toggle actually turned it on, then what we can do is say, wrap the this, which is that sidebar toggle button, and let's set its text to show sidebar. We'll go ahead and put an else in here, so that when we're removing that class, we'll change it's name back to Hide Sidebar. With this functionality, we're changing the look, in reaction to the state of the class, not just in reaction to it being clipped. Let's refresh it again, and the first time we click it, it'll say, Show Sidebar, Hide, Show. We'll probably want the first state to go ahead and look at Hide, but for now, I'm just going to leave it the way it is, because we're going to change it to an icon in a little while. You can see that what we're doing here is, we're really allowing our page to be much more dynamic. Let's make it a little more slick than it is right now. We can do that with CSS animations. Over in the CSS, I'm going to come and add a transition inside the CSS rule. This transition is going to be, when we're applying this amount, I want you to not do it all at once, but to actually animate it. This transition, I'm going to have to tell it what property I want to transition, because there may be a lot of properties here. I'm going to transition left, I'm going to use an ease, which is going to make it slowly, and then more quickly later, make this change, and then I'm going to tell it how long, which, in our case, is going to be .25 seconds. Let's do the same thing for the margin left. Transition, but in this case, it's going to be margin-left, because that's the property. Ease and .25 seconds, again. I want them both to be .25 seconds, so that they move together. Let's go back to the browser. When I first hide it, you can see it slide over. That's that transition, but when I show it again, it's just going to pop back into view. That's because we actually need the transition in both directions. Here in the wrapper, it'll be transition, margin-left ease .25 seconds, and then same with the sidebar, because both have it where the classes applied and where it's not applied, it'll know to do the right thing. As we refresh, slide out, slide back in. Slide out, slide back in. That's a much more pleasant experience for the user. They see where it's going, it's not just disappearing on them. In their mind, it is just off the screen that they can show, if they need to get information on the sidebar later. The only other thing we need to worry about, you'll notice that there's a little underline, under transition in all these cases, and that's because not all the browsers support transition, in the same way, right now. Visual Studio knows about this. As a feature is being adopted, often the browsers will implement their own versions of these rules, that can be ignored someday. That way, they can test out features that may be browser specific. When we hover over, it'll actually say here what browsers are supporting it. It says that there are browser compatibility for vendor specific properties. It looks like Firefox, IE, and Opera all have their own versions of it. If we right click, we can say Add Vendor Specifics, and it'll go ahead and add those specific properties for us. It just makes a copy of them. In fact, it went and found it in all of the places that we're using these, and applied them. You see they're a little faded, because visual studio wants you to know, that those are copies of the main transition, that it's going to try to maintain for you. This way, when you're using a browser, if someone's using an older version of WebKit or older version of Firefox, that this will still work. The current or Edge versions all support transition now, the older versions that people may have not have updated, might need these vendor specific versions for it to be a little bit more compatible. Hopefully, up to this point, you've seen some of the value in, not only JavaScript on your page, but also using jQuery to make some of that code a little easier, more concise, and simpler to write. Let's wrap up this module.

Summary

In this single module, I've tried to just give you a taste of some of the pieces of JavaScript that we're going to be interested in using with this new website, and we've implemented a pretty simple feature, the showing and hiding of the sidebar using that. Later on, in this course, we'll go ahead and use AngularJS to implement all of our client-side business code. But, we still might have additional jQuery or plain, old JavaScript pieces of code, that our website continues to use. So far in what I've taught you, I've really barely scratched the surface in JavaScript. It can be a fairly deep topic for you to really understand, when you're doing web development. I do encourage you to not take this as your entire teaching of JavaScript, and learn some more on your own, either during a viewing of this course or later on. The two courses that I can suggest is, I have, like I suggested last time, a Front-end Web Development Quick Start. Here, we go a little bit deeper into JavaScript, or when you want to go much deeper, I have a JavaScript for C# Developers course, that can take you through, and compare JavaScript to C#, to try to teach you a lot of the meat and guts of JavaScript, so you can be more comfortable with it more quickly, if you're coming from the C# space. JavaScript is one of the deepest places in the Pluralsight library, so if you also want to just dig into JavaScript, as a language, search for JavaScript at the search bar, and you're going to get a plethora of great courses on JavaScript. I do encourage you to learn JavaScript, as a ASP.net developer, don't just assume that everything you're going to do is on the server-side. What have we learned so far in this module? Hopefully, you've seen that JavaScript, while it comes from humble beginnings, is a pretty powerful language for manipulating, doing client-side code. You've seen that is the default language for client-side web applications, and for the most part, it's going to be the language you're going to use or generate. The Bower package manager can simplify getting of these JavaScript packages, as we need them. Through the course, we'll be getting different pieces of the client-side experience, using Bower. We'll see how it can simplify getting these packages, and handling the dependency chains of those packages. Finally, I have introduced you to jQuery as, really, a great tool for building complex webpages, though it is the starting point for where we're learning JavaScript. Later on, we will spend some significant time with AngularJS, as a client-side framework, for building your web applications. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App With ASP.net Core 1.0.

MVC 6

Introduction

Welcome back, this is Shawn Wildermuth of Wilder Minds. In this module, we're going to talk about MVC 6 and how it relates to ASP.NET. We'll cover supporting MVC 6 in ASP.NET projects, creating your own controllers, creating views and layouts, using model validation, and I'll introduce you to Tag Helpers. Let's get started.

First Controller/View

So, when we're talking about MVC 6, the MVC really stands for Model-View-Controller, and this is a technology that's part of ASP.NET Core that's going to allow you to build views for clients. This may be HTML pages for actual users, or this may be data in the form of APIs. The model itself represents the data we're talking about. The view represents whatever representation of that data. Again, whether it's an HTML page in the browser, or it may be an API as it's consumed by somebody. And, then the controller is the part of the code that is responsible for negotiating between them for taking in, forming the data, and then passing it to create the view. This is simply a server side framework for doing all of that. Let's see how this works in practice, and I think you'll get a sense of what it's really for. We're going to start by creating our first controller and our first view. So, let's start by creating our first controller that I'm going to call an app controller. The app controller is going to handle some top level pages we want the user to be able to go to like the Contact page, like the Homepage, like the About page, sort of a catchall for some of those common cases for our new The World website. I'm going to use the Add New File dialogue to do this because it's going to allow me to create the folders pretty easily as well, and I'm going to start with a folder called Controllers. This is a convention that MVC 6 uses to find the controllers that are responsible for your project. It doesn't actually have to be in a folder with this name, but it's really common for that to be the case. I'm also going to create another directory called Web, so that my web controllers are in their own directory. Again, this is totally optional. Lots of small projects just put everything into controllers, but for our use, I like the extra level of definition. And, I'm going to call the class App Controller.CS. This will add the new file as a C# file. We can see that here, and the first thing I need to do is add public because all controllers need to be public, so that they can be discovered. And, I'm going to derive from a class called Controller. This Controller class should be the base for every controller in your MVC 6 projects. And, you'll notice it's giving me the error condition now, and that's because we don't have MVC in our project yet. If we hold down Control period or use the helper, one of the options you'll see here is to add the ASP.NET Core MVC package. I could add that package here, but that's actually a sub-package of MVC. This is a Nuget package or a dependency of our project. Instead of doing it here, I'm going to go over into our project.JSON which we've talked about a little but really haven't done a lot with. You'll remember this is where we added dependencies like static files when we needed to support that in our project. I'm going to come here and add all of MVC because I know that's what I'm going to need. So, Microsoft.ASP Net Core, MVC, and then the version we're using right now is the RC2 version, so the 1.0.0-RC2 final is the correct version. You'll notice that a lot of these version numbers are going to be the same across an individual version of your project. Now that we have that added, we should be able to go back to the controller, and it will just add the Namespace we need which is Microsoft ASP.NET Core MVC. We also need what is called an action. An action is a method that is going to return a view. We can do this by just creating a simple public method with a name, and these methods are going to return an interface called I Action Result. So, allows us to return different kinds of results, and you'll see some of these as we go forward in this course. I'm going to call this first action just Index. It's not going to take any parameters. It's going to be used for that Homepage we want. And, in order to know this is going to return a simple HTML view, we're just going to actually say, Return view. This will tell it to go find a view, render that view, and then return it to the user. The user that made the request that this is actually fulfilling. Next, we'll need the actual view. We'll need what's called a Razor page that represents this view. We'll do that just like we created the controller by creating a new set of directories. MVC 6 looks for a folder called views in your project to find individual views. It also looks at the name of the controller. In this case, that's App Controller. It's going to try to find a directory called App to match all the views for your controller, and then the name's going to match the name of the action. In this case, it'll be Index. And, the extension is CS for C# HTML. When we start with a CS HTML file, we're going to want to add just generic HTML as the beginning content of this Razor page. And so, let's go borrow that by looking at our Index.HTML that we had created earlier. This is just a file that's normally served, but if we copy the whole thing, we can put it here in our Index.HTML page and actually have logic that's involved here. So, let's do that. Razor supports a number of C# constructs, and one of them is the @ and then braces to have arbitrary C# content in there. So, what we're going to do here is we're going to set a View Bag which is a property bag of data that can be sent and retrieved in these views, and I'm just going to give it an arbitrary name like Title, and I'm just going to call this our Homepage. What this allows us to do is then inside of our Title, we can say, @ViewBag.Title. Now, you'll notice that we got intellisense after we put the @. This is going to allow us to just inject property names or method return values directly into the markup of our project. If we go ahead and save that, we now have our first view. Now that we have a view, let's go ahead and run this and see what we see. Well see, we have our project, but if we look at the title bar, we can see that we're not getting that Homepage as part of the title. So, this must not actually be our new view. The reason we're getting this is that we're still looking for Index.HTML as a default page. So, let's go to the startup because we're not really going to ever use the default files that we had set up before. We're just going to be using views in MVC 6 to do this. We don't need to look for Index.HTML as a default file, so let's get rid of that line. Let's rebuild. And, let's refresh this page and see what happens. Now, we're getting a blank page. Maybe that's also wrong. So, I'm going to hit F12 which you can hit in either Chrome or Firefox like we're doing here, also works in some versions of IE and Edge. And, I'm going to get the Console of what is actually being returned. Let's refresh this. And, we'll see what we're actually getting is file not found. There's nothing listening for that root page and actually driving that to our app controller and therefore our view. So, let's understand why. Because nothing is listening for the Homepage, for the root of your website, nothing is being returned. Remember we used to be using the default file's middleware to determine that it's really indexed that HTML we're looking for. But now, we need some sort of middleware here to actually configure and listen for specific routes that we're going to actually implement. Let's look at that next.

Enabling MVC 6

So, now that we've created a controller and a view, let's go ahead and enable MVC 6 in our ASP.NET Core project. We need to be able to enable some middleware to start listening for any routes that we want. Remember that this configure is going to be a list of things to do as a request comes in. And so, MVC has to be added here, has to be opted into here when you're using this. This also means if you decide that another set of middleware is better suited to the project you're trying to create, you can even omit using MVC at all. But, you're here to learn MVC 6, so let's focus on that. Because we've included MVC in our project already, we can see that the app builder now has a method called Use MVC. This Use MVC is going to enable MVC to listen for that operation. And, let's see if that's enough to get our root page working. Let's refresh it again, and we'll actually see that we're getting a server error. The server is saying unable to find the required services. Wow, that doesn't make a whole lot of sense at first. You can see that it's suggesting that we call Add MVC to configure services. Let's do this, but let's also talk about what this means. So, configure services we can say, services.Add MVC. But, what does that actually mean? In ASP.NET Core, we're required to use dependency injection so that this configure services, the job of it, is to setup that service container, that container for all the different services the different parts of your application require. So, MVC requires a number of services, a number of interfaces, a number of instances of classes in order to do its job. And so, we have to tell it that hey here, we're going to register all of the MVC services. And, then when we call this down here, it should go ahead and allow MVC to work which is going to make that error go away. Let's build this briefly now that we've made that change, and let's refresh the page. So, when we refresh the page, and we've gotten rid of that 500 error, but we're back to the 404 again. That doesn't make a whole lot of sense, but it does. Here in our project we need a way for it to know about what routes belong to which controllers. We're not going to magically have a way to tell it that this controller should be invoked when we are executing a specific route. We can do that by using a lambda to configure MVC. And, we're going to create a route by using the config object, and there's a method called Map Route. This Map Route allows us to create different routes that will take a pattern of a URL of different options that are in the URL that's being specified in a request and map them to specific controllers. So, I'm going to create a default route, and this will be sort of the fallback when no specific route is being used for a specific method. We may be adding more of these as the project goes on. So, the first piece of this is going to be the name, and I'm just going to use this C# construct, so that we can see what these individual pieces of the route are. And, then there's a template. And, the template is going to be a pattern matching. So, I could say, Foo bar, quox, as a specific URL I want to enable. So, anytime a request comes, it looks exactly like this, I could have it map to a specific controller and such. But for us, since we want it to be the default, we want to allow it to be used for more than one controller. So, we're going to use curly braces to specify a pattern. So, the first section of any URL that comes in, we're going to assume is the name of a controller. And, then the second part, we're going to assume is the name of an action, and finally the third part, is going to be an optional ID. Now, we want to make the ID optional, so we're going to put a question mark after it to say that this part of the URL doesn't have to exist. But, we assume that both of these do have to exist. And, we can also specify some defaults. So, if these aren't actually supplied, what should we use as the default properties? So, if the controller isn't specified, we're going to default to the app controller. Remember that same controller name we created in the last video. And, the action if not specified will default to Index. So that if the action isn't specified, we're going to use an action called Index. And so, essentially what this says is that if the URL matches the name of a controller like app, if they don't specify anything after app, we're going to look for an Index method on that controller. Which if you remember from a minute ago, is exactly what we called that. If the app isn't specified either, then we're going to assume app and Index, so that this will actually allow us to have the root path mapped directly to that index method on the app controller. Let's see how this works. Let's refresh now. And, we're now getting our actual Homepage. Let me get rid of the debugger, and I know that because we're getting that generated Homepage directly here. It's actually working. It's actually generating this. And, all the same things should continue to work that we had built in our last module. Now that we have the basic Homepage working, let's re-factor it into a master page, or a layout page as it's called, so that we can use the same sort of frame for a bunch of different pages. Let's do that next.

Creating a Layout

So now, let's create a layout view that we can share amongst different pages. Here back in Visual Studio, let's go back to our Index.HTML and talk about this. If you remember, I talked about the views folder having some folders that mapped to the name of controllers. Here's app controller, and here are views that are being used by that app controller. And, in fact right now, it's just the index view. But, we'd like to have some pieces of our pages that are shared across these different controllers as well as views. And so, we can do that by actually creating a new folder called Shared. This is a special folder name under views for any views that need to be shared across different views that we're creating. And, the first kind of these that we're going to create is actually a layout view. So, I'm going to go Add New Item. And, one of the ASP.NET things that we can add is a view layout page. You'll see that it's automatically named _Layout.CS HTML. And, this layout page has a couple of pieces in it like it's created a stock HTML page, and then has that same view title trick that we talked about earlier as well as a render body. So, let's go back to the Index.HTML. And, let's copy everything below our project for the moment, and let's just replace the layout with what we have for our main page. We're still using Razor because this is still a view for writing the title into that page, but we have some data in the middle of here that is all this information around the world and the website and the form that is really specific to our Index.HTML. So, let's go back and replace everything on the page with just the stuff that's specific to our Homepage, this header, this paragraph, and then this form. Those are the things that we want on our Homepage. Notice I've kept this code at the top that's specifying the title because specifying the title here is going to allow it to spit out the title here as well, and this is a way that we can share and push data into the layout view. The next thing we need to do to make this work is to tell the layout page where to emit any content that it's getting from the actual view, in this case, Index.CS HTML. We can do that by calling a Razor function, again notice the @. And, we're going to call Render Body. This Render Body says this is the place holder. This is the part of the page that I'm actually going to inject here. This allows you to say whatever the body is of that page that's where it belongs. If we go and refresh our page, we'll notice that we're missing a bunch of stuff. We're just getting the world and the form, none of that boilerplate in the layout page are actually being emitted here. That's because we haven't been able to tell it which layout page to use. If we come back here, we can actually say, Layout equals Layout.CS HTML. In fact, we can just say, Layout. And, we'll see here that by specifying the layout page name it's gone and gotten that and then injected what is on our view, only the stuff that's in our view, directly in that part of the page. That's sort of the magic here. Is that the chrome of your website, the outer portions of your website that you want to reuse on every page will continue to be there. And, then just the content that's related to that page can be simply part of your view. But, it's probably annoying to have to specify this on every page. And, there's actually a better way to do this. In the views actually adding a new item called a View Start page. You'll see this is named _View Start.CS HTML. And, it's important that this is going to go in the Views folder, not in any of the sub-directories but right in the actual Views folder. And, by default what it's doing is it's specifying that every page is going to use this layout page as its page by default. Pages can override this, but we're specifying that we want to use this layout or this master page in every page by default. You can also add other things to the start because essentially this View Start is merged with whatever happens in the views as sort of a boilerplate for the beginning of anything that needs to be set code-wise for each one of these pages. And, that's what View Start is really for. So, if we've done this correctly, should be able to refresh and get that page without having to specify the name of the layout specifically on this view. And, that's one of the magic pieces here. Is that this idea of finding different parts of different views is part of the logic of MVC 6. It's part of this logic where it's trying to make it obvious and convention based for finding different parts of pages. And, we'll see as we build these things we're going to be using more and more injectable sections of pages. And so, you can really componentize a lot of the different parts of pages that you're building. Let's create another couple of views, so you can see how this works in practice.

Adding More Views

So now, let's add some more views using the controller and new view files now that we have the layout page specified. If we open up that app controller again, we can just create new methods that are going to follow the same pattern, but we can have them with different names. Like, I'm going to say, Contact, for a Contact page. And here, we're going to return just a view as well. And, then I'll do the same thing for an About page. Now, in these examples, we're building actions that aren't really doing any actions. They're just specifying that we want a view and that's all. The normal practice, and you'll see later on, we're going to add quite a bit of code into these in order to specify things like what is the model for a page, and do any other logic like checking for authorization or authentication. There's going to be a lot more code in these then just return view. But, this should give you an idea. Now, if we go over to the app and just use the Add New File dialogue again which I'm a bit happy with, we can just create a new page that has the same name as our action. So here, I want to create a view for the Contact page. And, all I'll do is say, H2 contact me, and we'll implement this page a little later. That'll be enough for us to see it change. And, then I'll do the same thing again for About.CS HTML. And, I'll just give it its name there. And, in both of these cases, we may want to specify that View Bag title again. So, let's go ahead and create those sections, @, brackets, and then if you remember it's View Bag.Title contact page, and we're doing this so we can inject our page name directly into the layout page. And, I'll do that same thing here, but I'll make it the About page. So again, we've created the controller methods, the actions, and then the views that are mapped to them that it's finding conventionally because we have About, Contact, and Index in our App folder that matches the name of the controller. Let's build that briefly. And, then here if we go and change the URL to the controller name which is App, and then the page name which is Contact, we should see we have that Contact page. And, in fact, we have some of the other content, but our page is all messed up. We're missing a bunch of details. In fact, Firebug is telling us, or Chrome Tools will tell you that there's actually some bugs. Let's look and see what they are. Oh, it can't find the CSS or the jQuery and all of that. And, you'll notice that's because it now has the word app before each of the paths. The reason for this is if we go back into our layout we have a bunch of links here that when this was an Index page was fine because it was at the root of our website. But, because the paths are a little different, we'd like to be able to tell the page that when you emit these links, to emit them based on the root of the website. And, we could just say slash, and that would probably work. Unless some of the ways it can be hosted, it might not be the actual directory. It might be hosted in a sub-directory or sub-domain of a project. And so, what we really want to do is tilde, slash to begin each one of these. And, that is a trick in Razor to say replace this with whatever actual root of the website is. So, let's do this. I'm going to go find all the cases where we're using URLs like the image and the script tags, and it should convert these to not using that app name in the URL as the beginning point of our page, but actually the root of our website no matter what we do. We come back here and now refresh contact. You'll see we're getting that contact page now, and all those links now work in the way we had expected them to and will continue to. We have that App, Contact, and we'll just make sure About works as well. And, just to remind you the reason why these links work is the route we had specified in the startup page. So, this is essentially looking at the pattern and going, Okay there's a name here in the URL or the URI that's called app. And so, I'm going to map it to the App controller. And, then there's a second piece which is the name of an action, so I'm going to map that to the method called that action which is Contact or About. And, nothing else is specified because the ID is optional. And, we'll talk a bit about that a little later. And so, this defines that even though we had used defaults so that the root page would be App Index, the other ones need to have the entire pattern the controller and then the action. Now that we have these methods, we have a little bit of a problem. Let's go to the Contact page, and let's throw an exception. Bad things happen to good developers. So, we have the instance where some operation, some code we're writing might be doing something wrong. It might throw an exception. We'd like to know what that actually looks like when we run our project. So, let's go to the Contact page, and we get an empty page again because we threw an exception. Let's see what this actually looks like. Oh, this threw a 500 error because no one was catching that exception and doing anything with it. We'd like to have a way to show that. In prior versions of ASP.NET, you had to live with the yellow screen of death or to write your own page, but if you didn't override that behavior, your users would be presented with this really bad experience. Now, I'm not saying that the blank page is better, but at least, you're not leaking exception information in this case. You're just doing the sort of right thing which is returning this 500 error that tells it that something really bad happened on the server. But, as developers, we'd like to have that information. We'd like to see those errors. So, let me introduce you to a couple of concepts here that are going to be important as you continue the project. If we go back to the startup class, one of the things we can do in configure is add a new piece of middleware called Use Developer Exception Page. And, this is in its own package just like a lot of what we've talked about. And, it's in Microsoft ASP.NET Core.diagnostics. So, I'm going to go ahead and automatically add that dependency. And, now that it's added it, let's go back and look at that same page. We're now getting a much better error. We're still returning that 500, but now, we can see the stack of what happened. Where did this error actually happen. And, we can actually look at the line of code that was thrown. We can look at any query stream, cookies, or even headers that were included. And so, for a developer, this isn't a bad experience. But, we don't want to expose this to users. So, if you've done C# for awhile, you may instinctually want to go, Well, I'll just say, If debug. So, if we're in a debug build, we should be fine, right? We only want to show this on developer machines, and developers only use debug builds. The problem is you may have different classes of machines that you actually want to show this on. What if you have test servers and staging servers where collecting this error information would actually be useful if it's throwing exceptions? Certainly don't want to put this on production machines, but there may be other environments where this is really useful. If your organization only has developer machines and production machines and that's it, the If debug works pretty well. But, once you get away from that, it becomes a little chaos to try to figure out when to do certain things in developer machines or in staging machines but not in production. So, the trick here, and one of the things that ASP.NET supports, is an interface called I Hosting Environment. Now, notice how I just added this to configure, and that is because configure is using service injection just like the rest of ASP.NET Core are. Remember the configure services is setting up that service container for the things that my application needs, but there's also a number of interfaces that just the system provides and Hosting Environment is one of them. By adding it as a parameter list here, it'll be fulfilled and an environment will actually be a good variable for us to use. What we can say here is if environment is development. So, we're protecting this only when we're actually on a development machine. Now, is development may not be a lot better than is debug. In fact if we look at this, this class has three different types of machines, production, staging, and development, but you may have your own. And, in fact, those three methods are all actually calling Is Environment. So, this is actually doing this code. It's saying, Is Environment Development, and then we can specify what things to do on a development machine. But, how does it know it's a development machine? That's another important idea here. Inside the project itself if we look at its properties, Alt, Enter's the shortcut to get there, and look at when we debug these projects, you'll see that there's a environment variable that's set. ASP NET Core_Environment Development. This is how you specify different environments. This value would be staging for staging machine, production for a production machine, or different names if you have different classes of machines. You may have smoke build machines. You may have testing machines. You may have QA machines where you want to do something a little different on those machines. These are just strings it's comparing. And, this is how it specifies it with an environment variable. This works across platform like everything else we talk about because environment variables are pretty ubiquitous. So, let's go back. We've now protected, use developer exception page, so that as you do the project if you get any actual problems with your code, this will show you better the answer than just getting a 500 exception. It should make development a lot easier as you go on. Let's get rid of the exception we threw here, so that we're back at a space where we can continue to the next step.

Using Tag Helpers

So now, let's talk about Tag Helpers. These are a way to add functionality into your views using programmable attributes. Let me show you what that means. So, we come back to our page here. We'll notice that the Contact page is on this app contact, but our links here still are broken, right? And, we could go to the layout page for a moment. We could come here and fix this by just saying, slash for home /@about/contact, right? And, this will certainly work. We can now go to the individual pages by just clicking on our little menu that's a little hard to read, but it does work. But, what happens if we change the way our routes work? Do we want to have to go find all these instances of links we have and replace them? And, that's where something like Tag Helpers can actually help. Instead of using the hrefs here, Tag Helpers allow us to do things like ASP-Controller, so we know that this is going to be our app controller. And ASP action is index. Now, this is more typing than you would expect, but it's less fragile. It's less fragile because as that app index changes the way that routing gets to them, it will change the value of where this link goes, so that you can change the patterns of your routes later without having to go find every instance of it. We'll do the same thing here with About, and we'll do the same thing here for Contract. So, we go over to the page and refresh. You'll see that these actually have disappeared, right? There's no links anymore. There's no links because what these attributes are supposed to be doing is generating the href programmatically while it's being rendered on the server. But, these have actually just been emitted because we don't have Tag Helpers enabled in our project yet. Let's talk about how to do that. We're going to start by going to the project.JSON, and we're going to add a new dependency for them, Microsoft ASP Net Core MVC Tag Helpers, and again, it's that same version. So, this is the dependency that includes the Tag Helpers. So, we now have them in the project, but we need to actually wire them up. And, we do this with another special type of view at the route of views called View Imports. Let me talk about this for a minute. Let's go back to our layout page. And, there is a special kind of thing you can do in views now, and that is @inject, and you can do things like inject Hosting Environment ENV, and then you could actually use this hosting environment directly on your page. It allows you to inject different services directly onto your pages. But, there are some services we want to be available everywhere. And so, we can actually do that here in views by adding a new type of view called View Imports Page. This allows us to add things that are going to be imported into every view we have, so that we don't have to duplicate those sort of imports over and over for things that are going to be common. So, we can do this by saying, Add Tag Helper. Then you'll notice it turns yellow, so you know it's correct. And, then we're going to give it the name of our Tag Helper. And, the name is going to be everything, and that's what the star is for inside of Microsoft ASP Net Core MVC Tag Helpers. This will inject all the Tag Helpers into each of the view that we actually need. We could also add using statements here as well that we want to be shared. Like, if you wanted to have The World.models or Controllers, that namespace included in every page, you could do that here as well. But, we're not going to bother with that quite yet. Now that we have that view imports, we should be able to see that we now get the links, and if you look at the bottom left corner, you can see that the home link is now at the root of the page. And, then as I go down, it's calculating the correct link to those individual pages because we've specified them with Controller and action, ASP-Controller, ASP-Action. All of the built in Tag Helpers are going to start with ASP-, so we know where they're coming from. Now that we've got Tag Helpers working, we have our layout page working, and we have some of our sample pages, let's go ahead and implement an actual working page. And, let's do that with the Contact page. And, we'll do that next.

Implementing a Contact Page

Now that we have the Tag Helpers, let's go ahead and implement the Contact view. If we go back to our Contact.CS HMTL let's go ahead and add a new form here. I've created a form on our main page, but this'll be our first form that we're actually going to hook up to MVC 6. So, inside the form, we'll start with a label for name, and we'll add an input which is going to accept the name, another label for email. And, this time we'll type it to an email type of input. And, then finally, we'll need the actual message. And, instead of an input, we're going to use a text area. Text area allows us to put the number of columns. It's about 40 for the width, and then rows equal four to make it a multi-line input area. Then finally, another input for submit. I'll put as the value Send Message. And, to make this appear the way we want it to, let's go ahead and wrap this in its own div, so it gets its own line by default. We're going to reformat this later, but this'll be a good way for us to start. Let's go ahead and run our Contact page. Go to the Contact page. We now have that very simple form. Let's go back to the code. And, in our project, we're going to create a new folder and a new class. I'll do that with the Add New File, and the new folder's going to be called View Models, and our new class will be called the contact view model.CS. So, make sure that's public. We're going to create some properties for it. The first is going to be name. Then we'll create another one for email, and then finally, one for message. The purpose of this class is to be able to communicate with the Contract page and get that data back. We could get it as just a series of fields here, but by using a class, we're using something called model binding to allow us to accept the data from that form directly inside of a method of our controller. Let's see how that works. If we go back to that view, we can use some Tag Helpers to help us build this page a little more effectively. And, if you remember, Tag Helpers start with ASP, and we're going to use the ASP for tag to allow us to say that we want this to actually be a label for the name. And, we'll do the same thing here for the inputs as well. And, I'll do this for email, and then finally for message. Now, these names here are purposefully matching the view model we just created because we're going to accept data from this in the form of that view model. The final piece of the puzzle is to tell our view what the model for this page is. What data is going to be sent to it and sent from it. And, we're going to do that with an @model declaration, and this is where we're going to use the name of our view model, just Contact view model. And, this is going to be in the world.view models.contact view model. The ASP fors that we're using here are going to assume that these are going to be names of properties that are related to the class that's being used as the model. This will allow us to more easily build our page up and do some more interesting things that you'll see in a moment. If we run this, you'll see that the name and email and message are the same. And, that's because it's pulling this from the name of that property of our view model. We'll change this a little later and watch it actually change here automatically for us. But, let's introduce validation first. Let's do that next.

Using Validation

Let's introduce validation to our view model, so we can see how that works. If we go back over to our view model, because this is going to be the contract with the page that's ultimately going to be manipulated by a user, we might want our contract here to know about the validation or data rules for our individual pieces of our contact. And so, for us, we actually can use an attribute here called Require to say that this field had to be filled out. These are all in the system.componet model.data annotations namespace. So, I'll go ahead and add that. And, we could add to all three of these. But, there are more types of validation then just simply saying whether a field is required or not. We can take our email, for example, and actually tell it that it is going to be an email address. That's a type of validation that makes sure that it is a valid email address, since that is such a common case. In the case of message, we can use an attribute like string length, and introduce what lengths we're talking about. So, let's say that our maximum length of our message is going to be about four K, but we can also say minimum length is 10. That way we're not being sent empty messages either. So, with these changes, if I build, should be able to refresh the page. And, we can see that new changes are really taking place here. None of our validation is actually taking form because we need to hook up the client side, the code in the HTML to actually know about this. The goal here is to take that information that we have in that validation and to be able to display it here, so that the user knows something is wrong and can fix it before they go ahead and send the message. So, let's go back to the Bower.JSON file that we were using earlier in the JavaScript part of our course. And, let's add a couple of new libraries, jQuery-validation as well as jQuery validation-unobtrusive. Those are he two libraries we're interested in. And, as we save these, those new libraries will appear in our bin folder. So, let's go back to our contact view, and we'll see the two new libraries here. And, here in the Dist folder, we'll have the validate. I'll grab the minimum version, since this is what we want to actually run on our page. And, we'll do the same thing for unobtrusive. There is the minimum version, and I'll drag it up here as well. Now, this will work kind of fine, but we'd like to have these scripts show up at the end of our other jQuery script. So, we'd like to have a better way of doing that then hoping they're just going to be at the top or the bottom of a page. Let's go back to our layout view for a moment, and let's add them. Here, is where our jQuery is, and then we have our site wide JavaScript here which we're going to be adding to later. So, let's move that a little down, and let's add a section called Render Section. This is where we're going to add a name here, and I'll call it Scripts. And, I'm going to say, Required false. The reason I'm saying required false in this case is not every page needs a scripts section, and if one isn't supplied, this just will render into nothing. But, for pages like ours that need a scripts section, we'll go ahead and make sure that any scripts that are in that are emitted here at this point in the layout page. It allows us to have different parts of the code that are in a view be emitted in different places. So, let's go back to the page. And, around our scripts, we'll put a little thing called a section. And, we'll call it Scripts. And, the trick here is that everything inside this Scripts section we'll be emitted here over in the layout right here, right after our jQuery inclusion. And so, that should actually work. Let's refresh our page now that we have these pieces. And, now that we have those loaded, we should actually when we press Send Message, you'll see that it didn't actually launch the new page. It actually put us back on the name because hidden here, hidden behind all of this is the fact that the validation is actually validating it and going, You need at least a name. So, if I put some sort of name there, and I press Send Message again. You'll see that it puts us in the email because that's where the next error is. We'd like to show these errors to our users though. We can add these validation messages using Tag Helpers. So, we come here after our input for name. Let's add a new span, and then do ASP validation for name. And, let's see what happens if we show this page now. Get rid of that name, refresh the page, and press Send Message. Guess what. The reason name is failing is now showing up. Let's repeat this for all three, so that we'll have validation for email and validation for message. And, let's go refresh that page. When you send message now, we're getting the error for each one of these. So, name is required. That's easy to fix. Let's go ahead and put Sean. And, you'll notice that as I type it's making the error go away, so that's great. And so, email is required. So, if I start to put S, H in there, required is now fulfilled, and we're seeing the next part of that message which is email field is not a valid email address. Oh. So, it's actually doing a validation probably with a regular expression for what an email address should look like. So, let's go ahead and put in the pieces that make it look like an email address. So, we have an email. So now, that one's fine. Message is required. Let's go ahead and put in a message, but you remember that one of the validations we put in the view model was string length. So now, it says it must be 10 with a maximum of 4096. So, I'm going to have to type something until we reach 10 characters, and then it goes away. And so, in this way, we can use that view model that's going to validate the data on the server, but it's also going to emit some code in the view to make sure that the client knows about those same validations. So here, we'll create a span but use ASP.validation summary. And, this will allow us to use one of multiple values. Either it could be any errors that are on the entire object, or each of the different models. So, I'm going to say, model only, which means this is only going to show errors that aren't being shown on individual forms. And, this is useful for errors that may be about the entire form. Let's say you were using some sort of validation to make sure the postal code matched the country or the postal code matched the state in the case of a U.S. form. This summary would show the list of errors that aren't about the individual fields. That way the user will know about them as well. We're going to use that in a minute. Now that we have validations showing, let's show how we can get this data to actually be sent to the server, so we can do something with it.

Supporting POST

So, now let's support posting of this Contact form directly to the server, so we can actually send the mail out. The first thing we're going to need to do is come over to our form and add a property called method. This allows us to assign which of the http verbs we're going to use. And, most likely, post is the one that makes the most sense. The get verb is primarily used to retrieve information. The post verb is used to add information. The put verb is used for updating information, and delete is for deleting. And so, since we're adding a message, this message may end up in a database or as an email message, we're creating something new. So, the post makes the most sense. Let's go over to the controller and add support for this. So, this action that we have here is specifically to allow us to do a get. By default, the behavior here is to get based on that route of app slash contact. But, we want to do the same thing here also going to return an action result and also going to be called contact, but in this case, we have that contact view model, and it's the data we're being sent. And, we're going to return the view like we've done otherwise. How is this different? This is different because we're going to add the verb http post to tell it that if someone posts to the action that is contact this is the method that should be instantiated, and that we're expecting to have the data being passed to it as well. I'm going to set a break point here in the view, so we can talk about that. Let's run this. And, let's refresh our page. We've got some valid data in there now. Let's go ahead and press Send Message and see what happens. Here, our contact is being called because that form posted all that data to the view. And, if we look at the view model, we're actually seeing those in the correct spots. It's doing this via what's called model binding. So, we have three pieces of data that we know about, name, message, and email. And, we're expecting a class that has those same fields in it to be filled in with the data that's being sent there. Now, we could have done this by having individual pieces, but having this class gives us this unit of work to validate and communicate data to the controller and through the controller as we write code. Now that we're getting the correct data through the form, and that we know that this data is working because it's been validated on the client before it was being sent to us, we need to have a way to actually send this message out. And, we'll do that by implementing our own service. We'll do that next.

Adding a Service

So now, let's walk through adding a service to our project. Let's create a new folder and interface for our service by saying, Services, I mail service. Let's make sure that that interface is public because we're going to need it to be. And, then for our mail service, let's go ahead and create what we think each mail service is going to need. Void Send Mail let's say a string to the recipient, a string for whom it's from, a string for subject, and then a string for the body. So here, we're defining the interface that each of the mail services may need. Now, let's implement a service based on that interface. So, in the services folder, I'm just going to create a debug mail service class, and I'll make it public as well. And, I'll derive it from our mail service interface. I can also use that Control period to implement the interface for us. We can even see it previewed here. And so, that we have a starting point for the actual implementation of the service. This version of the service isn't going to actually send the mail. I'm just going to throw out the data into the output window just so we know it's working. So, I'll use the debug class in system.diagnotics to just write a line sending mail, and let's use the dollar sign string interpolation syntax to say, To, from and subject, we won't bother putting the body in there. It'll be good enough for now. Just so this way we know that the mail service is actually running. Later on, you'll want to implement your own mail service to actually send the mail to you. In this course, we're not actually going to implement the other class. But, let's see how this works because what we need is a way to use this debug service. Let's go over to our app controller and talk about that. What we really want to be able to do is call the send mail method from the model. But, we don't want to necessarily know the implementation class. We don't want to have to do new debug mail service because in some instances we may be using a real one and other times a fake one. So, we want to use dependency injection to do this work for us. And, the trick is multi-part. Let's talk about how we would change our controller here to support it creating a new constructor. And, this constructor's going to take in our interface mail service because our app controller now needs that actual service to implement that post method. And, I'll just call it mail service, and I'll bring in that world services namespace, so we have it. And, I'll just say, mail service equals mail service, and then I'll use the Control period or the light bulb to go ahead and generate the field for me. The reason we're using the controller to do this is that when this controller is created, is generated by the request, it's going to see whatever's in the constructor here and try to see if it can fulfill this request. What it'll do is it'll instantiate app controller and pass in an implementation of this interface, so that all this code will work. Now that we have the mail service, we should be able to down here call it. Mail service, send mail, and just put in a hard coded to, and this is going to be from model.email. The subject will be from the world, and the body is going to be model.message. We're not actually using the name, but we could later. But, this'll be good enough for us to say, Hey, we want to actually send this mail. The problem, of course, is that our system doesn't know about this interface natively or that we have another class that implements this interface. Let's show this by running our website. When we try to go to the Contact page, we get an error that say, Unable to resolve the type of I mail service while activating the app controller. So, like I explained, when it tries to create the app controller, it wants us to apply the services in the constructor, and it doesn't know about mail service yet. We can solve this by going to startup, and inside configure services, we can make a decision about registering our own services. Remember add MVC was adding the services that MVC knows about, but now, what about our own? We can do this with services.add transient. Add transient means we're going to supply an interface, I mail service. I'm going to bring that namespace in. But, it can be fulfilled by a certain class. In our case, that's the debug mail service. Transient means it's going to create an instance of debug mail service as soon as it actually needs it and can keep it cached around. We can also change this to add scoped which will create an instance of the debug service for each set of requests. So, if a request comes in, a new debug mail service will be generated and reused during a request. That's different from the way transient may be loading it and recreating it every time or getting it from a cache. The last kind that you're going to want to be interested in, and we'll actually use later is add singleton. And, singleton says, Oh, we're going to create one instance the first time we need it and then pass that instance in over and over and over again. For our needs, we're going to say, Add scoped, because we want this debug mail service to be reused, but only within the scope of a single request. Now, that we've registered that, and if we run the project, and we supply our data and call send message, we're going to see that we've gone beyond the mail service, and we've gotten that instance of debug mail service as we needed it, and in the output, we should be able to see sending mail because that's all this send mail is doing so far. So, we've got this working, but we've got this silly implementation of the mail service, and later on, you might want to actually implement your own real one. Debug mail service might be fine for development, but for production, this probably isn't want you want. And so, you may decide that the solution there is to use an if debug. Let's put an else in there, so that you can know to go implement a real mail service, right? To go ahead and later on create a mail service class that can actually send mail. But, there's a problem with using if debug. If debug makes the assumption you really only have a couple of different kinds of servers. Imagine that on a development machine debug's going to be used, but if you start passing out builds to test servers and staging servers and such, you may want to be able to test this stuff without actually sending real mail. So, we'd like to have something more sophisticated to do this. The trick here is that startup itself can accept injected parameters in the constructor just like our controllers can. And, there's a special interface called hosting environment that can be really useful. So, I'm going to store the hosting environment here, so I can use it and configure services. Configure services can't take additional interfaces to be fulfilled because it's setting up all the services that it could inject. And so, you get into this weird loop, so they don't want to allow it in services. So, we're going to allow it to be injected here earlier and store it at the class level, so we can sue it down here. So instead of if debug, we're going to use that environment to say, Is development. So, if we're on a development box, this makes perfect sense otherwise go ahead and implement the real service. Now, this development is kind of interesting. The environment has three kinds of tests, is staging, is production, and is development. But, all three of these actually do something different. They actually call is environment with the name of an environment. So, we can ask for is development. Or, is a new type of machine that maybe only your organization has like testing. So, you can say that you're not going to use a real one in development or testing otherwise go ahead and assume you need a real service for things like staging servers or smoke builds or things like that. You can make those decisions. And, this is a much more flexible way of doing this. But, how do we know it's a development box? How do we know we're right here on a machine? We could search through the hard drive and find the number of games on a laptop and determine that it's a development machine if it has World of Warcraft. But, that's probably not a good way. Let's look at the properties of the world, and we'll see under debug there's an environment variable called ASP Net core_environment that is defined for development machines. So, when we're debugging this. This is actually being set so that we know it's a development machine. This also means that later when you deploy this into different environments like test servers and staging servers and production servers, you can use an environment variable to set up those machines for those different environments. And, use the is environment to test against it. That gives you a lot of flexibility for that. So, we now have our service implemented. Let's go ahead and complete our form in the next video.

Completing the Form

So finally, let's complete the form by tying it all together. If we look at the way we're using the mail service to send it, we remember we hard coded where this was being sent. We probably don't want this hard coded because who knows who's going to be responsible for answering these emails down the line. So, we'd like to have a way for it to be configurable. The trick is to use a configuration file. So, I'm going to go over to our project and add a config.JSON to our project. This is a common form that we might be using configuration from other sources like environment variables of INI files or XML files. But, let's start with a JSON file. And, I'm going to come in here and say, Mail settings, and then I'll add some structure to it by saying, to address, and then give it a real address to actually send these to. This configuration file allows us to store information, have some structure to how we're going to get these individual pieces, and even set them up in different sections if we want. Gives us a lot of flexibility. But, how do we actually read this? We don't want to have to load up a JSON file and read it directly. Let's go back to the startup, and in our constructor let's go ahead and setup some configuration. I'm going to create an instance of a class called Configuration Builder which is in Microsoft extensions configuration, and I'm going to say add JSON file because that's what we just did. We want to add the set of configuration from a JSON file. This is in its own package. So, as we select it we'll be seeing the RC2 version. And, then we can set the configuration, and we'll actually store it here at the class level, so we can use it throughout our little project here by calling builder.build. So, it's going to read the configuration here, and we'll go ahead and store it in case we need it in other parts of the startup class. What builder returns is a thing called I configuration root. And, because we really need it in the app controller, what we really want to be able to do is add it to the constructor. I configuration root, and we'll just call it config. And, we'll do the same trick where we'll get it in the constructor but then store it at the class level, so we can use it, so that down here when we're sending mail, we can just read it out of our configuration. Now, if you remember, the config.JSON called it mail settings and then to address. So, the configuration system takes that structure and flattens that out into name value pairs, and you'll see why in a moment. But, if we call this mail settings, we can use a colon in here to say this is walking down a group, and then we can say, To address. And, this config here will return whatever is in that config file for us. But, in order to inject it here into the constructor, we need to tell startup to store it. Just like we registered the I mail service interface, we can also register the configuration root service. But, in our case because we're reading it on the startup of our application, we probably just need a single instance that we can share across everywhere. And so, we can use services, add singleton in this case. And, for the singleton, I'm just going to pass in the config. And, it's going to figure out that config is I configuration root, and that's the interface that this instance, this single instance will now be supplied everywhere it's being used. So, let's see if this actually works. So, when we run it, it has a problem in the startup class, and it's showing us the error by saying the config.JSON wasn't found. And, it wasn't found because it's not really sure what directory it belongs in. So, over here we can add another method to our builder to say, Set base path. So, we can tell it for all the configuration files where the configuration files live. And, in this case, we can use the environment to supply the content root path. The I hosting environment that we got for our other purpose over there also supplies the directory that our content is in and also the directory that our web root is in. Now, web root is the wwwroot folder, and content root is the root of your actual project, since that's where our config file is that's where our root path is. Let's go ahead and run this in debugger, so we can see what's happening. And, we'll just quickly get it to pick our different pieces. We'll press Send Message, and we come back to the view, and the thing that you will notice is that the config for the mail setting's to address, which I'll copy and throw here in the immediate window, is returning that correct address from the config file, so that we're getting this valid information. In fact, we can see that sending mail is now sending it correctly to Sean Wildermuth even though obviously this isn't really sending mail. The interesting thing about the way we're using configuration here though is the way this builder works because we can actually add other sources. And so, for us, I'm going to add environment variables here. They're also in a separate package, so we'll go ahead and add that. And, the reason we're adding multiple is because not only can you commingle different configuration sources by using this method, but you can also allow configuration to be overridden in different formats. So, in our case, the config.JSON is a very comfortable way for development for us to add these default settings. But, you can imagine in talking with IT people using environment variables that override those would be very helpful. And, in our case, we can actually override it. Let's do this by going to the properties, and let's add a new environment variable here. Since we want to override the value with the environment variable, we're going to use the name of the main section mail settings, and we're going to separate it by two underscore to represent the structure. Two underscores are going to replace that colon that we had used from the config file. The reason for this is colons aren't allowed in non-Windows environments for environment variables. And, since we're supporting cross platform, we need to think about that. So, the double underscore is going to replace the colon in our case for the environment variable, and then we're just going to say, To address, and let's make it BGates@GatesFoundation.org. And, if we run this again, let's just resend that form, we'll see that the mail was sent to B Gates because it overrode what was here in that config file. So, this allows us to in development use a config file which is much easier for us, and then when we hand this over for production, or we move this into the cloud, just use environment variables. Environment variables are really useful to IT folk because they know how to script them a lot easier than having to read through and parse a config file. And, the config file doesn't get overridden with these values every time you deploy a new version. Environment variables can stay static on the machine while having all those pieces of source code not be, you know, the secrets or the database connection streams or whatever else you need IT to set for you application. It becomes a much more robust way to handle configuration in your project. So, let's talk about a couple more things just to complete this idea. We have validation coming in for this contact view model, and we're using it to sort of hint on the client side to validate that the data is correct. But, what about on the server? The server, part of the model binding here is to test against those validation attributes. So, we can actually say, If model state is valid, this is telling us that the state of the data that we passed into the form is completely valid. And, if it isn't valid, it's going to fall through and just return back to the view and display the view with any errors that are associated with it. So, you might imagine that if you failed to have errors that showed up during the client side, but that got munched or muddled or changed on the server side, then we could still be returning errors back to the view. In fact, we can do some tests here to say, If model.email contains aol.com, which is a common fake address suffix. Probably not a great idea. There's probably real people with aol.com addresses, but for now, that'll be good enough. We can actually say, Model state.add, we can add a model error for the email to say, We don't support AOL addresses. So, we can have our own sort of validation checks directly here in the model, and this is good for exceptional cases. Because if we've added the model error here, this is valid is going to be false. Let's see what happens to this in the real world. So here, I'll put Sean again, but I'll use me@aol.com for an address instead, and then for the message I'll just put some garbage. And, when we send the error, you'll notice we didn't get one of the standard problems here, but this was actually mapped to the error that we produced on the server. So, we got this error message directly back into the UI because we added an error to one of the fields. If we wanted to add it to the entire object, we can actually send and empty string as the property we're setting the error on, and then it'll show up in the summary. And, then if we run this, we use the AOL address again. When we send that message, it'll show up here in the summary instead of next to one of our controls because we've told it it's a model error not a property error. So, by adding a model error with no name, it shows up here when the validation summary is showing only the model error problems. To finalize this, let's add one more piece up here which is if view bag.user message does not equal no. Let's go ahead and add a new div here that just shows a view bag.user message. This will allow us to send a message directly in the form in case it succeeds. So, in our app controller, since we've got this valid here, we can go ahead and say, View bag.user message, message sent, and that way we can show a good message when we're done. Let's change this to Yahoo.com, so we don't get the AOL problem. We'll send it. Now, we can see that message sent is there. But, our form still has the data in it. Probably not what we really want. So, we can come here and just say, Model state.clear. This will remove all the data from the model state, so that when we go back to the page in this return view, we'll have the user message that it sent, and we'll clear the form. So, let's send this message again. We didn't need to refresh the page because we had it, and now, we're getting that experience. Message sent, and the form is cleared. So, if they need to send another message they can. But, it does prevent them from necessarily having that same data and just printing send message 100 times, and you getting 100 emails in your box. So, we've used MVC to not only build these different pages in the layout, but you've also got a Contact page that works using MVC 6 and form handling to deal with simple forms on your new web pages. Let's wrap up this module.

Summary

So, what have we learned? In MVC 6, we've learned that we can separate the logic and views, and this will enable testability. So, we could write tests against our applications. That's sort of the magic of model view and controllers working together. I've shown you how to separate your project into layouts, so that you have a master page that has most of the chrome on it. And, then you can keep the job of just building the contents, the inner part of your main webpage, so that the work of building an individual page can be small and concise. And, then you don't have that HTML and CSS and other parts of the code repeated for each and every page. I've also shown you how ASP.NET Core supports configuration that plugable from multiple sources, and then overriding those sources really, really works. This has been Sean Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET core 1.0.

Bootstrap

Introduction

Welcome back. My name is Shawn Wildermuth of Wilder Minds, and this is the Bootstrap module of building a web app with ASP.NET Core 1.0. In this module we're going to talk about how Bootstrap can help us build our web app. I'll go ahead and add Bootstrap to the project, I'll show you how can skin Bootstrap, we'll introduce you to the grid system inside Bootstrap, we'll create a navigation using Bootstrap, and we'll show you how Bootstrap can make your forms look better. Let's get started.

Adding Bootstrap

So what is Bootstrap? It's an open source framework that you can use in your own web applications, websites. It's composed of CSS and LESS, LESS is a language for writing program-like facilities in CSS, as far as you're concerned as a consumer of Bootstrap, you're just going to be using the stylesheet, the design of Bootstrap. It also includes JavaScript components to help you do some common features like carousels, like styling of buttons. It's modular and skinnable which means you can use the components you want out of Bootstrap, as well as being able to change the way that Bootstrap looks and feels. And we'll see how that works. And the focus here is to have Bootstrap help you solve the 80% of common design metaphors you're going to see in your web applications. So a bar for navigation through the website, breadcrumbs, panels, thumbnail images, etc. Also support all of that. It doesn't want to decide how to design your entire website, but take the 80% of commonality that every website seems to include and provide solutions for doing those easily. Let's get started by adding Bootstrap to our web app. Back in Visual Studio, the first thing we're going to need to do is to add Bootstrap to our list of client-sided dependencies. So that means opening up our JSON again, and we're going to add Bootstrap as a dependency, and we'll go ahead and use the 3.3.5 version, though when you view this there may be a little bit later of a version. There will be a Bootstrap 4 coming out in the next few months, with no clear release date, as of the writing of this course, Bootstrap 4 is in the Alpha version. So we can see the components, but it's certainly not ready for production use. Once we've included Bootstrap, we can see that it's now in the lib folder, like our other dependencies, and unlike some of the other projects, this is going to include JavaScript as well as CSS and even fonts. So to use this, let's go ahead and open up our layout view, and I'm going to go ahead and add Bootstrap to both of these locations because we're going to use Bootstrap sitewide. So for the CSS, I will create a CSS link at the top of my layout and notice that there's a Bootstrap and a Bootstrap theme. The Bootstrap theme is an optional component you can include that'll give you the default look and feel of Bootstrap, but you also always need the standard Bootstrap CSS. For us, we're going to use something else later to theme it, so we're not going to include that theme. We've also included the theme before our own CSS, because we want to be able to customize what the Bootstrap looks like, and CSS documents are applied in the order that they're included here. So our site's CSS can now override the Bootstrap CSS if we want it to. Let's go down to the bottom, and again, before our site JS, I'll include a link over to the Bootstrap distribution JavaScript. Now even though there's some other files included in Bootstrap, we don't have to incorporate them into our layout because the CSS or the JavaScript are going to be referencing those. And it's primarily going to be images and font files. With all that included, let's see what this looks like in the browser. Now so far, not a whole lot looks different, and that's because all we've really done at this point is include the new CSS and so we're getting some of the different fonts that we've included here, but we are overriding them with some decisions we made. So let's reverse that, now that we're going to use a framework for our CSS and components, let's rely on them for the look and feel of most of our website, and only use the site CSS for exceptional cases, like our toggle menu here. So I'm going to go ahead and open up our CSS, that site CSS, and let's get rid of the body tag here, and the label and input, because we're going to rely on Bootstrap for our form design as well. So I'm just going to comment them out. I'll leave those in for now. Into the CSS, though, I probably would delete them if this were an actual project. But so you can see what we started with, I'm going to leave them commented out. And if we show the site again, we'll see it's changed a little because we're now relying on all of the look and feel to be dependent on Bootstrap. We're going to add some things to improve the look of our website in a minute using Bootstrap. Let's start with that toggle menu, as just sort of a starting point. In our layout form we have this toggle menu that we're using to show and hide the form. And one of the first things you'll find out about Bootstrap is that it uses a number of classes to decorate the UI to describe the kinds of formatting we want to do. And one of the first things that people will run into is the button class, the btn class. We add the button class to our existing button, this toggle menu at the top when we refresh, will take on the look and feel of a built-in button, but by default the button itself doesn't have a whole lot of look and feel, so we want to actually make a small change, and add as a second class to decorate it, what kind of button we want. And let's say primary button. There are colors inside of Bootstrap that describe the different kinds of basic colors that are supported. Danger, default, primary, success, info, and warning. And they all represent themed colors for different sorts of opportunities, so let's start with primary, cause this is going to be a bold color for our button. So we can see we have the now look and feel for a Bootstrap button, we're getting the mouseover experience for it, the rounded corners, it looks like a standard button, but this blue color is what is defined as the primary style color that's used within this current Bootstrap theme. We change this to something like success, which normally is a green-like color, we're going to see that will change as well. And let's take that same idea and color what's in the footer down here. Let's go ahead and wrap this all in a paragraph. Now we'll use our text primary to tell it how to describe that color. And see it's now that same blue, though because we're on a black background it's a little harder to see. If we make this another color like warning, we're going to see it's on orange for warning, and you're probably not terribly surprised that danger ends up being a reddish color. For our case, let's go ahead and just leave it as primary for now. But we can see that the same color schemes for the different sort of colors is one of the ideas you want to kind of get your head around in Bootstrap. Let's go back to our button for a moment, and I'm going to make this button primary as well. And I'm going to add another modifier here called btn-sm for small. Now we have the standard-size button, but when I refresh, we'll see this button gets smaller. The text inside of it gets smaller, and the literal size of the button gets smaller. We can do the same for lg for large, to make a really bold in-your-face button. And again, these are some common ideas that the small and large, the sm for small and the lg for large, are common metaphors in the classes you're going to use to style your website. I'm going to take this out and leave the button to be a standard size button for now, but I wanted you to see how that worked. Another one of the things it has built in is a set of fonts. And instead of the fonts being special text that we might want to use, they're actually icon fonts. And they map these icon fonts to classes. We can do this by using an i tag, which used to represent italic, by specifying the text that's a voice or a mood. But we're sort of overriding its basic meaning, and actually using it as an empty tag to say this is where an icon goes, and I'm going to use the class to represent what icon to share there. And it uses a class called glyphicon, and then glyphicon with a certain name for the different kinds of icons that are supported. In our case, we're going to use glyphicon chevron left. It's going to create a little left angle bracket right before the toggle, so we're giving a visual indicator of what we want. When we refresh it now we can see that we have that little icon now showing there. In fact, for me, I don't think the word toggle is important anymore, so I'll get rid of it. So now we got a little just icon button, which you'll see in a lot of different places. And of course, this still works, but as soon as we click it, it's getting rewritten. Before we fix this, let's talk about something. I'm showing you Bootstrap 3, it's at the end of its life cycle, Bootstrap 4 is on the horizon, in the next six months or so. Most of us will be moving to Bootstrap 4. If you used Bootstrap in the past, you may have experienced the pain of going from Bootstrap 2 to Bootstrap 3, which was a big, monumental change, lots and lots of changes happened. But between three and four, the changes are going to be more subtle. There's a few things that are coming and going, and I'll actually have a slide discussing which ones are coming and going in a minute, but one of the more important ones I want to talk about are these glyphicons. Cause these glyphicons are actually going away. And they're going away because there's actually a much better alternative, something called Font Awesome. It's an open source font for doing icons and doing some other things, even things like animated icons, which are not uncommon. So we're going to replace this with actually the Font Awesome icons cause it's just a better solution. So let's go back to our bower and let's add that in addition to our Bootstrap. It's just called font-awesome, and it's their 4.4 version, that is the current version. And like Bootstrap, we also need to include a CSS stylesheet. And unlike Bootstrap, it doesn't require JavaScript to run as well, it's just a set of CSS. So how is this different from the glyphicons that Bootstrap supports? The style is actually remarkably similar. It's still using an i tag, it's still using a decorator class like the glyphicon here and then a descriptive class for what I want to show, except it's fa for Font Awesome, it's fa, and we're going to use angle left instead of chevron left. And with luck, we're now getting that icon as well. And it's a different look and feel, you could choose a larger or more dramatic icon if you want, but it certainly does what we want. But we still have the problem of when we click this, our old JavaScript is doing some things we don't want it to do. So let's look at the JavaScript real quick. And if you remember, this is further down, we were setting the text to show and hide sidebar for us. Well, let's simplify it and just use a change of the Font Awesome. The first thing we'll need is to get a reference to the icon. Now we haven't named the icon, so you might think oh, I better go put an ID on this, but we actually don't have to do this. What we can do instead is say sidebarToggle i.fa. Let's talk about what that is. This says go find the sidebar toggle and as one of the children of it, find an italic that is classed with, you guessed it, fa. So when we look at this, we can see that this is the sidebarToggle, and has a child in it called i, with a class of fa. Now, jQuery is going to deal with these classes as individuals, so when I ask for a class of fa, this is going to qualify it. Or I could say class of fa angle left, and it would also classify it. And so here instead of saying this, I can say icon remove class, and here I'm actually going to remove the angle left and then I'm going to add angle, you guessed it, right. And then I'll just use some editor inheritance of copying these and just changing these from add and remove. So we should have that experience of switching it back and forth for us. Let's find out. Starting with that left icon. Turns to the right, left, woohoo, we got it right. And so the experience we're getting here is what we want, and we're using the Font Awesome and Bootstrap stylings all together to give us something that represents an icon button for our application. This is sort of the tip of the iceberg of what Bootstrap can do for us, but let's delve into some more demos of how we can use it to style our website next.

Using Bootswatch

Now let's talk about Bootswatch to theme our application. Now Bootswatch is a list of templates that are easy to install, you can install them through bower, that changes the look and the feel of the standard Bootstrap templates. You can also go purchase third party templates as well, that will give you even more dramatic changes to your Bootstrap-based website. But we're not going to get into the paid templates, because it can be a little overwhelming. We're just going to use one of these, in fact, we're going to use Spacelab as the look and feel of our website is kind of clean and concise for the things we want to do. So how do we get it? Like the other parts of what we've talked about, it's simply another call to bower. Now the Bootswatch is a little different in that it's based on the version of Bootstrap you're using and then the version of Bootswatch that's currently out there, and the plus two is the current version, so their versioning system's a little weird, and so it tends not to find it as you're typing these things in. But if you're using this directly from what I'm typing in, use 3.3.5 and then 3.3.5+2, or go look at the Bootswatch website, they can give you some help about finding the right bower package. Now let's save that, and the only thing we need to do to style our Bootstrap site with a Bootswatch template is to actually just include another stylesheet. And then each of those templates we saw on the website are included in here, we just have to pick the important folder. So I'm going to go ahead and pick spacelab, and then just include the bootstrap.min.css. Also going to go into the site CSS, and get rid of a little bit more of our look and feel. So our main element had some background color and padding and margin as well as our footer. I'm just going to comment those out, because we're going to use Bootstrap to describe those later as well. We go back to our website now, we're starting to get the different look and feel, you can see the font usage is now based on what we had in the overridden template. You can especially see that here in the different look and feel of that button, it's no longer as flat as it was in the default Bootstrap template, it's now got a little bit more depth to it than it did before. Now all of this is designed a little ugly at the moment, but we're going to make this better as we get closer to defining our entire site using Bootstrap. So each of these themes is a little different. The Spacelab, as we saw, is using one set of fonts, and if all we do is change the name of the template here, we can get another look and feel as well. We can see this is again, a little different from the default look and feel. And this Yeti template is the one we're going to actually use to finish designing our website. I like this sort of cleanness of the fonts as well as some of the color choices and the squareness of the things like the buttons. You can decide aesthetically what you want, but this is the one I'm going to choose. Let's start using Bootstrap a little bit more fully.

Building a NavBar

So next, let's build a NavBar. We're going to incorporate some more of the Bootstrap-like elements to help solve some of these common metaphors like navigation. We'll start here in the layout, and if you remember, we have this menu class here. This is just a list of links, essentially, that we've styled in a certain way. But I'd like it to be a little bit more friendly and that's where nav type, I'm going to replace the menu type with just the nav type. And this is going to give us the ability to show these as something that's a little bit easier to click on with the mouse and even with touch, if you're using it on a mobile device. Let's see what that looks like, just changing the class to nav. Now these are sections that are nice and big, and we can click anywhere on here, it doesn't have to be right on the name like it did a minute ago, and it's more fitting with everything else we're trying to do. Now, they are still just links, because of course, we haven't changed any of the li's or the anchors in here, we're still using all the tag helpers to build them and all this. It's just this class nav that's telling it to style the unordered list in this very friendly way to the user. As you start looking at this, you probably will start saying oh, I know the 4,000 different websites I use that are probably already using Bootstrap because I'm starting to recognize some of these metaphors in use. Another common metaphor is an actual, what they call a NavBar, this is a bar that includes navigation elements and can even have things like buttons and such. And we'll incorporate our button here for showing and hiding the menu into a NavBar on top of our main section. The first thing we'll want to do is to add a class to both the main and the footer element inside of our main wrapper. Now remember that this sidebar is fixed to the left-hand side, and you can certainly do some different things with Bootstrap to change that, but we're going to ignore that and just assume that this is going to be the main part of our website, this wrapper down here. And what we'll do is add a class to each of these called container fluid. Now there are two actual containers that Bootstrap supports, and this plain old container is fixed sized, towards sort of the middle of the page, to try to give a fixed-size experience for lots of websites. Before apps, I found that using container fluid which says take as much of the webpage as possible. And then as we do grids later, it'll fit within one of these containers. and so no matter what size screen you're on, it'll try to give you appropriate widths for how big the browser is. And we'll do the same thing here for footer. Because of the nature of our website, not a whole lot's going to look different, except you'll see that we got a little padding on the left, and that's by design. It knows that this is going to be towards the edge of the page, both sides, but of course, there's no text over here, and so it's giving us some standard padding on the left-hand side to give us room between these two. And now we can start to build a NavBar here at the top. And we're going to do this by actually creating another element above the main section and even above the footer, of course. It's going to be called a nav section. This is a type of HTML5 element that tells browsers and such this is where navigation is going to be contained in, and it's going to have navbar, whoops, as a class as well as for us, navbar default. And that's just the styling for NavBar. There's also an inverse. In fact for us, let's go ahead and use inverse. And within this NavBar we can have different sections. So as a container for what's inside here, let's go ahead and create a div with the class of container fluid, and then we can create an unordered list here to contain the different elements. And for us there's actually only going to be one element, and we can sort of borrow it by grabbing that button down here. And I'm going to get rid of this div in the main, so that this sidebar toggle, we've moved it, but it's not actually going to be changed in many ways, we're just going to say contain it here in our NavBar. And so now, in the browser, we can see that NavBar button here but we also have this dot here. Why the dot? That's because we haven't styled that unordered list yet. This is where understanding and in some ways, looking and studying the different ways of setting up these NavBars would do you some good. A lot of times I'll have to go back to the Bootstrap website to look at an example to really understand. This is actually one place where Bootstrap 4 will start to simplify some of the NavBar, because it does require knowledge of exactly how all these things come together, and the first time out of the box it seems a little confusing. But this unordered list starts with a nav as a class, and then a navbar nav, and these set it up as a container for a number of items that are going to sit inside the actual navbar, which is that block that goes from left to right. You can have a number of these. We're actually going to just show you three of them. And then we want to tell it where we want this on the list. So we can say navbar left. And what that does is left justify whatever is inside of our project here. We show this now, we can see we now have this on the left-hand side. We're also going to show you something that is just after this and then we're going to show you some buttons on the right-hand side, so that you can see the ability to do each. Here we're just going to create a plain old anchor, and we'll put inside of it, the title of our website. So that every page is going to show this, right now we have it sort of in the content of our main page, but we'd like there to be some sort of link that will take us back to the home page everywhere, especially if the menu's not being shown. Now we can put an href here, but instead, let's use those tag helpers. And so this should build us just a link back to the homepage. Now if we go ahead and add a class here, we'll tell it what to do with this. And there's actually a navbar brand class that says this is for that big piece of text that represents sort of the branding of the website. Let's see what this looks like. We can now see The World directly to the left of our buttons here. So let's go ahead and create a section on the bottom that represents everything right justified. And I'm going to show you how to create a couple things that look like a toolbar button, and so we'll create another unordered list, and we'll class it just like we did up here. In fact, I'll copy these. But the big difference between them, is that instead of left is that we're going to tell it to right justify them. And let's go ahead and create a link. And we're just going to use a simple link, but for our destination of our link we're just going to say this page, which is what the pound represents. Because we don't actually want them to do anything right now, we might wire up events to them later, that sort of thing. We won't actually do that in the course. These are more to just show you though. But we're going to use as a class, the button class. The reason we're using the button class is that this can change the way a link looks and represent it as a button. And I'll make this a small button and let's go ahead and make it info. And for the content, let's say this is going to be a save button and we'll go ahead and use that font icon i element again to do that, so fa to say it's a font icon icon, and then fa and there's probably a save, yeah, save. Let's create another one, cause the idea of putting this in an unordered list is actually going to show these left to right but we can represent them as a list of items, even though we're telling Bootstrap to display them in a certain way. In this case, I'll say print, and there's a fa for print as well. And if we refresh the page, we can see we now have the buttons on the right-hand side, just like we thought we would. So now we have a look and feel for the top of our page that kind of gives us that experience, we now have a working button on the left, we have a link over to our homepage here in the middle, and then we have the save and print buttons that don't currently do anything. But if we had some more of these buttons, or we wanted to represent them as just icons, we could get quite a few here before we start running into space issues. And finally, let's fix up this awful-looking footer we have here, we want to get it to the bottom of the page like we had it before, and we want it to just look better. So we use some of the same techniques here. We're going to leave this as the container fluid, but here I'm going to change this to an h4, instead of a paragraph tag, and that'll represent kind of making a little beefier, a little larger. And I'm also going to use text center to force this to be centered on the page. Refreshing it, ooh, that looks a little better, but it's still at the bottom of the content, we really want it to be fixed to the bottom of the page. We can use the NavBar to do that as well. We do that by just wrapping this in another div, and this extra div is where we're going to set as the navbar item, again using classes. So navbar navbar inverse, so we have the same look as the top bar, and navbar fixed bottom, will push it to the bottom of the page. So we've got it showing on the bottom of the page, but we're actually missing the text. Wonder where it went, might be off the page. In fact, it's there, but it's the same color as the bottom of the page, so let's just here in the layout, let's instead of saying primary, let's change that to info. Let's see what this looks like in the browser. Better, it's a little muted, but that's fine with me. Gets the look and feel of what we want. So now we're starting to get some of the aesthetic sense of what Bootstrap is actually giving us, and so we're able to get a sense at least from the layout of some of the structure we're getting. Let's apply some of that same structure to our actual page here. We're going to do that by understanding the grid system. Let's talk about that next.

The Grid System

In Bootstrap, we're able to do layout of a page in a pretty special way. It's using a grid system, where you're going to think about the world living in 12 columns. So this represents 12 blocks across the page, and regardless of how wide the form is, it's going to still separate that into 12 even units. So when we lay things out on a page, we're going to use classes. Classes that represent a .col dash a size of screen we're looking for, and we'll talk about that more in a minute. And then the number of columns we want to take. So if we want two things side by side, they're going to be column six width and column six width and it'll lay them out correctly. If we want three, we're going to use column four. And that three and four always confuses me, because it always gets in my head, what do you mean four is in thirds, of course, if you think about it as a 12 column system, of course four is in thirds. Math is our friend. If you want four even units, threes, and six even units in twos. And so that we can start to think about building these in smarter ways, so if we have a column nine and a column three we're going to get that sort of relationship between them on the page. We also have a column offset where we can say skip a couple columns and then show it. So if we wanted to use eight columns wide, but have centered in the middle, we use an offset of two, and the column of eight. And if, we can just mix and match these as well, so the offset doesn't need to be in the beginning of the column, it could be after another column as column declaration is shown. So here we can see the three, and because it's offset two, it's the six columns offset two skipped columns and then taking up the next three. And if we directly after that have a set of columns that are three after that, Bootstrap knows well enough not to put it off the edge of the page, instead it moves it to the next row. And so getting comfortable with this 12 column grid system will allow you to aesthetically build things and lay things out in a systematic way. So if you're doing things like a grid of information, you know, little cards of, let's say, movies, on a movie website, what you're really doing is saying oh, let's go ahead and make these two column wide, that way we'll get six across a page, and that seventh one will end up going in the first column, really on what you can think about as a second row. So you don't have to think about building one row at a time like you have done probably for years with things like tables. Becomes much easier to do these very simple and powerful layout mechanisms. Now in all these descriptions I've put little xx's in between the column and the number. And that's because we're really dealing with designing sites for different sized grids. And those grids have four different sizes for four different screen sizes. So for screens that are 1,200 pixels or wider, which is sort of a modern laptop, the designation is lg. For anything over a small laptop or a large tablet, that's what's called the medium sized grid. Then there's the small grid for smaller devices, like large phones, phablets, and then you have smaller phones, everything that's smaller than 768. And what's important here is that you may decide on different widths on different size grids for different screen sizes. So for example, we may say, oh here's some content that we want on a very small screen to be the full width of the page, and that's what we're pointing it as grid 12. But on a medium size screen, go ahead and use six. Now we don't have to designate all of them, because we're saying greater than, we can actually do things like say col mid, and it'll work for mid-sized and large size, that same column number. And saying xs means that small and extra small will both get that 12 grid, or that wide size. If you do need it special for all different sizes, you can include them. And so as you work with responsive layouts, with dealing with different sized devices, you're going to want to tweak these to see what they do. Let's see this in action to really sort of cement how the grid system works.

Using the Grid System

Let's take a look at how the grid system works. So we're going to leave the layout for now, and work with some of our individual views. Beause that's where grids end up being the most important anyway. Remember, we have this landing page that includes some information about our site, and then a form to add new locations, which of course, we haven't wired up, and it doesn't do anything yet. So the first thing we're going to want is a top-level div here, with a class of what's called a row. And a row is basically a container for making grid decisions inside of. So it's not literally a row, because things are still going to wrap if they are equal to more than 12 columns across, but it just is sort of a container for the grid system itself. And so inside this row, let's just take this entire section here, and let's put it in a new div, and let's use one of these column classes. We're going to choose md so that it does mid-sized machines all the way up. And I'm going to give it the size of six. Let's create another div inside here for where we're going to create the map later. And I'll do the same thing, col-md-6. Let's put a little the map in here, so that we can see this. So we now have the look here where it's split between left and right-hand side. And what's interesting is, on a very large screen, it's doing this split half and half. But what if this wasn't that big? Let's go ahead and make this smaller until we're starting to approximate a smaller device, like a large tablet. As soon as we cross this magic barrier, even though these are supposed to be taking up half the screen left to right, it knows that on smaller devices, that those are going to get crunched down really quickly. And so when we cross that magic barrier, of somewhere around 900, the small size grids take over, and they end up being top to bottom instead of left and right. In fact, you can see that our NavBar even changes the way it looks when it gets really small on more phone-sized devices. But what if I really did want these to be left and right no matter what I did? Let's come down here and also add col-xs-6. So for every device under that, let's make this four wide, and let's make the left-hand section eight wide. So the map is still going to be small, but we're not going to get that falling into just a top and bottom arrangement for small devices. We're overriding the basic behavior, and that is to make sure that each of these elements ends up on top of each other, which, honestly, is what you often want, cause again, on small devices like phones, vertical scrolling is the only scrolling you're going to really want to support. So now that we do this, let's scrunch it down a little, when we get small, and even smaller, it is giving us that sort of 1/3, 2/3 experience, but we're overriding it by saying I know better than you, I want it to actually have this behavior cause I'm giving specific extra small or small sized columns for this element. But for a majority of what we're going to do, we're just going to specify minimum and let the really small sizes deal with themselves. Usually having them on top of each other ends up with a better user experience at the end of the day, unless you really have something special you're going to need to worry about. Let's do the same with our contact page real quick. So the first thing to do for us is to wrap this all in a div row, because we're going to want to use columns, and we want columns to be inside of rows. And I'll take our whole contact form, and I'll put it in another class col mid again, and I want this to also take six, I want it to take about half the page. But I don't have other content to show. I just don't want the form feeling that large. So by saying six, I'm going to tell it to only take half the page but instead of leaving it on the left, I'm going to use an offset of three to say push it in three, use six, so it's effectively taking up half the page, but then centering it in the center of the page. So we can see now, regardless of how large it is, it's going to pretty much stay in the center of the page. We're going to pretty up the form in a minute, but for now, we're not that far from where we want to be. But the nature of this, with the offsets and the grid size, is that still, once we get into tablet and phone sized, it's going to do what it wants to do, which is take up as much of the width of the screen as possible. Because frankly, that's usually the better experience for users, is taking as much room as possible. Once we format our forms correctly, we'll see that that's going to make really good looking forms whether that's on a large page, like we're going to normally view on a website, or whether you're on a mobile device. So by using these grids, we can determine the layout without having to get down into how many pixel widths, and that's really the magic of a grid, is that you never have to start dealing with CSS pixel widths, you can really depend on proportional spaces on a webpage. And that really is going to simplify a lot of things for you. It's going to take a little time for your brain to click into grid mode, but once it does, you're going to be much happier, trust me. This once.

Bootstrap and Forms

Let's apply Bootstrap to our forms now, so we can see what that looks like. Let's go back to that index page, and let's look at what it looks like before we start to apply Bootstrap. Here's our form, but everything's sort of disjointed, and frankly, a little ugly. The way Bootstrap wants to work is it's going to take each of these form groups, really, a label and an input, and we're going to give it a class called, unsurprisingly, form group. On the inputs we're also going to add another class called form control. Let's apply that to each of these so we can see kind of what it looks like. And if I show you that in the browser, we'll see that the controls now take the width of whatever the column it's in, and it's given us sort of a distinct look and feel to each of those labels. So we're inheriting this look and feel from the webpage, but it's often a good look. But what about this submit? We could certainly class it with form control, and that, because of the nature of form control, just makes it wide. That's usually not what we want. It might be, that might be the look you want, usually I find that using button, button success, in the case of an add button, I like green to tell the user oh, this is something we actually want you to do. And refreshing it, it's going to give us a look that makes it a little bit more cohesive here. Instead of the default look of the submit button, we're telling it that we want to actually style it as a specific type of form. Of course, this form doesn't work. Let's see what we can do to make this contact form look a little better. Cause this has a few more moving pieces. Let's go to that contact page. We'll apply the same ideas. Let's first wrap each of our controls and validation in that div, and put form group in it. And I'll repeat this for each of the three controls we have here, obviously, if there were a lot of controls, this would take a little bit more time. For the last one, we'll continue with form group. And even for a submit button at the end, we'll want to put that in a form group as well. Now we haven't styled any of the inputs yet, and already the contact form is starting to look a little better. It's put each of these on their own line, it's a little prettier. Let's go ahead and apply the class form control to each one of these. And whether it's a input or a text area, form control is going to do what we want. Starting to look like an adult form, isn't it? And for our submit message here, we'll do button success. and in our case this ends up being important, because of the validation we have here. Now that we have validation messages here, we might want to style these as well. We can do these with just the text styling, and let's do muted. Text muted's one I haven't talked about before, but only applies to text as far as sort of stylistic colors and that is a color that, unsurprisingly, is a little muted. I find this is better for validation messages than using something like warning or danger, seeing orange and red might really indicate to them, but I also want to be kind to my users, and so the reality is that that's probably good enough, right? I want to be nice and subtle. You could of course, when you do this, pick whatever color you want for those validation messages. I also don't like that send message is just the only thing we can do here. So one of the common things I like to do is I'll include another link, but this will be an actual link back to the homepage. And so, let's use the tag helper, just like we've done before, to go back to the homepage in case they want to cancel it. And so we'll just say cancel here, but of course, I want to turn it into a button. So I'll use the class again, but I won't give it a success or anything I want them to push, I'll just make it plain old colored. So now we have a cancel and a send. Of course, the cancel, all it does is take them back to the homepage, so they have to go back to the contact page to get back here where we want it to be. Now we're giving them the experience of a cancel button, but it's really just a redirect. And this is the common metaphor that I tend to like to use is to use a link over to another page, it's just really a cancellation of an operation. And you can see multiple buttons down here, actually are going to look pretty good together. So we use Bootstrap to really take a look at our forms and make them nice and pretty. We've added some NavBars, we've shown you how to use some of the grid systems to start to look like a website made by an adult, or let's say, even a designer, without having a lot of design skills. Of course, bringing in a designer may be doing overrides to Bootstrap to make it look a little bit more like your company's identity is never a bad thing. But it's something you want to make a decision about. We'll continue to use Bootstrap through the rest of the course, as we add different elements to our application. But this has hopefully given you sort of a quick step into Bootstrap so you can start using it in your own websites.

What about Bootstrap 4?

So we're using Bootstrap 3 in this course, because Bootstrap 4 isn't quite ready. But let's be honest, Bootstrap 4 is on its way. And what does it really mean? Hopefully if you've viewed the rest of this module, you heard a couple of my asides talking about what's coming, but let's really talk about the core of it. Bootstrap 4 is just entering Alpha I'm recording this course in September of 2015. So depending on when you view this course, Bootstrap 4 might be out and ready and available, or even patched by now. Unlike the transition between Bootstrap 2 and 3, this is a much more modest change. Most of the changes were small API changes while they made some big architectural changes under the hood to improve performance and create some consistency in what they were doing. NavBars, which we've shown you, are actually getting an important reworking and retooling. So they should be simpler to build when you start looking at Bootstrap 4. There's a new component called the Card, which is going to replace things that Bootstrap has in it called Panels and Thumbnails, so that there's really one type of component instead of having a few different things, or a few different cases. It should simplify some websites that didn't know which of these that they should be using. And then as we did talk about earlier in this module, glyphicons are going to be gone, just use Font Awesome instead. Font Awesome won't be built into the box of Bootstrap, Bootstrap just isn't taking responsibility for supplying icons to you. There are alternatives to Font Awesome as well, so if you want different icon sets, go for it. Bootstrap just isn't necessarily supplying icons going further. They just feel like other open source projects are doing it better, why compete. The last important thing here is that Bootstrap isn't going away. Again, unlike the transition between Bootstrap 2 and Bootstrap 3, they don't expect that many people are going to go to Bootstrap 4 immediately. Bootstrap 3 will actually continue to be used and supported by the Bootstrap team, including bug fixes, for some amount of time. Whether that's a year, whether that's two years, that hasn't really been explained, but they are saying that they're supporting Bootstrap 3 even when Bootstrap 4 has been released, so that everyone doesn't feel like on the day that it turns over, they have to immediately convert all their websites.

Summary

So I've been able to give you a taste of Bootstrap, but there's quite a lot to it, and we'll be covering some other parts of Bootstrap during this course, but we certainly can't teach you all of the components in Bootstrap with any amount of reliability. So I suggest one of two courses. I have a Bootstrap 3 course, here's the link to it. That covers Bootstrap from beginning to end. It covers really all of the main components that you may want to use in your websites. There's also a Responsive Sites with Bootstrap 3 course, that talks specifically about using Bootstrap 3 in sites that need to change between desktop sites, tablet sites, and mobile sites. I recommend that course as well. Of course, I do like my course better, but that's just because I'm selfish. So what have we learned? Hopefully I've gotten you excited about Bootstrap, if you haven't used it before. You've seen that it is a comprehensive CSS and JavaScript web framework. And so, many of the components we have have API's to them that we can then use. We've really mostly just touched on the CSS framework part of it. I showed you how to use navigational panels for different kinds of navigation you might want on your website, not always just the plain old top NavBars like I showed you, but you can also have simple navs as well. I skinned Bootstrap with Bootswatch, though you could certainly use Bootstrap's skins from a variety of places, both free and paid. And then we started to look at using the Bootstrap components. We showed you how they work with forms, we showed you how they work with things like the navigation panels, the text usage, and the grid system, to create a single look and feel for your application using this framework that Bootstrap supplies for the look and feel of your application. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET Core 1.0.

Entity Framework Core 1.0

Introduction

In this next module we're going to be talking about Entity Framework Core. We're going to start by creating some entities. We'll use the DbContext to be able to interact with the database. We'll talk about seeding and creating databases. I'll show you the Repository Pattern, and then I'll talk about Logging. Let's get started.

Creating Entities

So what is Entity Framework Core 1.0? The Entity Framework Team decided to chuck all the code they had, take the ideas behind Entity Framework and re-write them from the ground up. They wanted to build the next data access layer for .Net that didn't only work with relational databases. This version of Entity Framework is a work in progress. For the current release of Entity Framework Core, they focused on a bunch of use cases that are going to help a majority of the users out there. They've done this all in the open, all the design and implementation of Entity Framework Core is out there in Open Source, directly on GitHub. But there will be some cases where you'll need some of the features of Entity Framework 6 that have not been implemented in Entity Framework Core, and so you're still free to use Entity Framework 6 if you're using ASP.NET Core on top of the full .Net platform. If you need that maturity, then Entity Framework 6 is a still real viable option. Let's start by creating some entities. Let's start by creating an entity called Trip. This will be the data that we want to store that represents a single trip that a user might be going on. We're going to create all of these entities in a folder called Models, though you can call it anything you want, Data Access, Data Entities, it really doesn't matter. And I'm just going to create a simple, pure .Net class. I'll start by making it public, and I want to add some pieces here, I want to be able to add a name of the trip, so I'll use the prop shortcut here to create a property for name. I'll create another one for the date created. And yet another one for a string that's going to contain the user name of whomever owns this trip. We also want some sort of identifier that uniquely identifies a trip, so we're going to go ahead and create another property called ID, though you can call it something else, ID is just an easy way for Entity Framework to know that it's the ID for our trips. And the last thing we're going to want to build is a little bit more complex. We're going to create a member that's going to hold each stop on a trip, and I'll call that Stops, and the type is going to be an ICollection of stop entities. This ICollection is going to allow us to add and remove them, and that's why we're using the ICollection interface instead of something simple as IEnumerable. IEnumerable is read only, so we really want to be able to actually add and remove. But you notice the squiggly line under stop, that's because we also need to create an entity for stop. We can do that with refactoring, by generating a new stop class in a new file. Let's go ahead and do that, and we'll see stop appear here so we can actually see stop turn blue here, so we know that it's actually generated, but we have a little problem here. If we look at the class, and hover over it, it actually shows it correctly, it's in the world models and stop. But in Visual Studio with ASP.NET Core these days, sometimes it creates it in the wrong directory. We can actually see it over here in the root of our world project. I'm just going to drag this up into the Models folder 'cause I want them all under the same folder, and I like that the folder is going to match the name space, the world models and then the stop class. Let's navigate over to that with F12, and let's complete that class as well. We're going to start with an ID, just like we did on the trip, so then we can use as the primary key. And we need a few more properties than we did before. So let's start with a string for the name of the stop and this is usually going to be the city, and then we need a double value for the latitude, so we can plot these on a map, and we'll do the same for longitude. We're storing these in a data, in some sort of data store, and so storing them as two numbers might be a little easier, depending on the data store you're dealing with. You might actually want to use something like a Tuple or something in other cases, but for us, having two separate properties is fine. We're also going to create a property for order, so we know what the order of each of these stops are, and then finally, a date time, let me go ahead and add that using statement, or the arrival date. And I'll just call that Arrival. And so what we have here now are two separate pieces. We have a simple trip that represents a trip a user can take, and we can see that we're going to use user name to get trips for individual users. There are certainly better, more sophisticated ways to do that, but for what we need this is probably good enough. And then the trip itself has a collection of stops which we represented with this small amount of data. Now that we have our entities to find, let's figure out how we can actually store them in the database by creating our context. Let's do that next.

Creating the DbContext

So now let's create a DbContext class so we can interact with the database. With our entities created as stop and trip, let's go ahead to that same folder and create a new class that we'll call World Context. This is going to represent the access to the database itself, so we need to make this public and then drive from a class called DbContext. This represents a context to the actual database. You'll notice that it can't find it, and then when we actually show the helper, it shows us that we can add the packet for Microsoft Entity Framework Core. That's exactly what we want to do. It's going to add the name space here, as well as add the packets to our project. Let's create a constructor real quick by using the ctor shortcut, and we're going to come back and use that constructor in a little bit. What we also want to do is take each of the type of entities we have and expose them as a property of a special type called DbSet. So let's use the prop snippet, and just call this DbSet of trip, which is that class that represented the entity, and let's just call it trips to make that easy and we'll do the same thing for stops. What this gives us is a class that we can execute LINQ queries against. These properties of DbSet are starting points for IQueryable interfaces, and we use this when we start to query the database directly. Now that we have the very basic structure of our context class, let's go over to the Start Up and let's register it so that we can actually use it in other parts of our project and we register this by adding it to configure services. We added the configure services in this sort of a special way. Instead of saying something like add transient or scoped for our class, we're actually going to add DbContext. This is a special extension method that's used to not only wire up all the entity framework interfaces, but also our context. So we put our context class here as World Context. We'll need to bring in that models name space, and now we've actually registered not only Entity Framework, but also our specific context. Our context is now injectable in different parts of the project. Now that we have this, let's try to use this correctly in one of our controllers.

Using the DbContext

Now that we've created the DbContext, let's go ahead and use it. If we open up our App Controller, you might remember how we use the constructor to inject the mail service and the configuration data. Let's go ahead and add to that our World Context. I'm going to go ahead and add the models name space, and this is going to work because if you remember from the last video, we added it to the configure services so that this World Context is now injectable. Let's go ahead and store it here in the App Controller class. We'll probably change this later, but for now this would be a good place to start. Now that we have it, we can actually get some data by calling the context class, and if you remember, we added Trips and Stops as these DbSet collections. And what that allows us to do is say, Trips to list and that will go to the database and get a list of all the trips as those trip classes. We look at this data we'll see that it's actually returning a list of trip objects. Now we can take this data and pass it into the view. And we'll use it in the view in a little bit, but let's talk about what's happening here. This context is going to go out into a database someplace, and query for the Trips is going to convert this little line into a query that is appropriate for the database we're going after. In our case we're going to use SQL Server, but this could be a no SQL database, this could be an Object database, a Document database, could be any one of these. And so let's go ahead and set a breakpoint here, and let's see what actually happens. So let's go ahead and run this. We'll see here we've gotten a context object. It's been injected correctly, but when we run this by pressing F5, we're going to actually see an exception is thrown. So it says, no database provider has been configured. Now I told you that query was going to turn into a query for whatever database we're going after, but we haven't done any of that work yet. So let's go ahead and add that. The way we support that, is to actually come back over to the context class, there's actually a couple of ways we can do this, But this is the one that makes the most sense, and that is to override a method called Unconfiguring. And unconfiguring gives you this database options builder that allows us to say, use SQL Server and then we're going to pass it in the connection string. Now SQL Server is in a separate package, and so the trick with Entity Framework Core is you have the Entity Framework Core is the base library that is the actual handling of context and entities and those sort of things, then there are separate packages for different engines. There are ones available now for SQL Server and for SQLite and other database engines, both relational and non-relational. There's even one for an in memory database that can be used for when you don't actually want to save any of this stuff long term. But for us we want to add the Microsoft Entity Framework Core SQL Server package, and then what we'll pass into that, like I said, is going to be the connection string. There's also some options we can use, but we're not going to use any of those now, we just want to actually set up a database connection string. The hard coding here in the code is, of course, the wrong way to go. So we want to be able to use that configuration data that we had already set up here at the top of Start Up, right. We have this builder, and if you remember we added it as a singleton, so we can go ahead and add it as a parameter to the World Context. Iconfiguration route, let's bring in that name space, and then I'll store it here at the class level so I can use it. And as you walk through this, understand that we're using this constructor injection, so we don't necessarily need to know how to construct these objects, but that the dependency injection layer will do that for us. Now that we owe the configuration, we should be able to say config, and then something in config to store our connection string. So let's come down here and open up that config file. Let's add a new section. When you open up a new property in the config file, one of the things they're suggesting is a section called data, and ordinarily this is where connection strings would live, but it's only a suggestion, we can call it anything we want. So in fact, I'll call this Connection Strings, in case we have more than one, and now add another member here called World Context Connection, for a lack of a better name. And then I'm just going to build the connection string to a local SQL Server. This could be a SQL Server on your machine, or in my case, I'm going to use one that is often included with Visual Studio Installations. So if I come over here and I look at SQL Server Object Explorer, or I can find it here in the View, I can see that one of the databases I have here is local DB, SQL Local DB. This is one that's installed usually by default. So let's say Server equals Local DB, MS SQL Local DB, and if you have different names here, go ahead and use those, those are fine. After server we need a database name, and this is going to be the name of the data that we're going to have for our project, and you could cal it anything you want. We're going to create a new database for our website, though this could be an existing database out there, so I'm just going to call it The World DB. I'm going to say trusted_connection equals true because I'm just going to assume that we're running as us during development. We may replace this with an actual SQL Server somewhere in the data center or in the cloud when we're ready to do this, but the entire connection string will be changed. And then we're going to need multiple, active, result sets equals true. This is a parameter that is going to allow us to do batch querying, so we need that turned on as well. And now we have our config json to include our database connection, we just need to look it up in our context object. So, if you remember it's connection strings, colon, because it's a sub-object, World Context connection. Because we're using unconfiguring, we actually need to add another parameter to the World Context because the base class for DbContext accepts something called DbContext options, and we need to be able to pass these down to that base class, so in order to do this, we have to say, DbContext Options, and have that injected for us, and then pass them to the base class before our unconfiguring will work correctly. Now that we've set both of those up, let's go ahead and run this and see what happens now. It takes a moment because it's attempting to read the database, but it's failing, because it cannot open the World DB, that database name that we specified. Now the error you're seeing is saying the log in failed. But the reality is that this is actually happening because there is no World DB on that server. We can see here in the SQL Server Object Explorer, that in the database folder, there isn't a database called The World DB, so we need to have a way to actually create it, and maybe even insert some of our own test data. Let's do that next.

Using Migrations

Now let's talk about migrations so we can create our new database. We want to create a database that will be able to store our trips and stops, and our database context. To do that, we actually have to go back to project json and add some tooling. And we're going to first need a new dependency for the tooling for Entity Framework, so we're going to say Microsoft.EntityFrameworkCore.Tools, and we're going to be using the preview2 version of the framework. Because this is part of the tooling, Microsoft is still working on this part of .NET Core. The tooling is only used during the development or deployment phase, and those are the things that are still in flux inside the ASP.NET team. So we're going to go ahead and pick the preview2 version, at least as of the recording of this course, but we need to specify more than just a version. So one of the things that you can do in dependencies when you need to be able to specify more than one thing is to assign this dependency an object. I'm going to grab that version, and I'm actually going to assign as one of them the version. And there you can see it's still giving us that IntelliSense to allow us to do that. When we come down to the second line, we're going to see the different kinds of things that we can use to augment this dependency, and for us we want to actually say type. This is going to tell Visual Studio in the build system and .NET Core that we actually want this reference, but it's only for doing the build. This is a special indication saying that this dependency isn't actually being used at runtime or as part of the platform, but is only being used to build our application. Adding the dependency isn't enough for the tools. We actually have to add them to this tools section as well. So I'm going to create a new item in the tools section, and I'm going to use the same name that we saw a minute ago, which was EntityFrameworkCore.Tools. This name is the same name that we used for the dependency. We could even copy and paste it over. And like before, we're going to be using an object to be able to specify certain characteristics. The first one, like before, is going to be the version, and it'll be the same version that we're using in the dependency, but we're also going to specify something called imports. This tells .NET Core and the .NET Core tooling what versions this project can be run on top of. And what we specify here are that we can run it on top of .NET Core, dnxcore you see here, or just plain old portable over on top of win8. These are hints as to what version this tooling is compatible with and can run on top of. It's not crucial that you understand exactly how it works, but this is the exact text you're going to need to include. And I made it an object, but I should've made it an array because this is going to be a collection of the different kinds of imports that it supports. The whole reason for adding the tools section, as well as the dependency that it's using is to allow us to use Entity Framework at the command line. So go ahead and hold down Alt and hit space, and that should open up a console window. If it doesn't you should be able to right-click on TheWorld and say Open Command Line. And you just want the Default (cmd). If this command isn't in your version of Visual Studio, you just need to open up a command shell in the same directory as the project itself, not at the solution level, but actually the same directory that the project.json lives in. So I'm just going to open up this as the default and say dotnet ef migrations, which is the migration tooling inside of the EF tool, and I'm going to say add InitialDatabase. This last parameter called InitialDatabase is just naming what I want to call the set of migrations at this point. And what this command will do is go and read the project and look for a DbContext object and then create some code that will not only create the database, but also create all the structure in the project, so it'll create a Trips and a Stops table for us. so that it works on Windows and non-Windows platforms, But what did it actually do? If we come back to the project, we'll notice there is a new folder called Migrations, and this Migrations has a magic number and then the word InitialDatabase. If you remember, that's what we called it, plus the WorldContextModelSnapshot. These are two CS files that the project knows about and has the instructions on how to actually build our database. So we could write code to go ahead and run these migrations on the project as we go forward, but I find that can be problematic in recreating the database as you make changes and such, and so the other option, which we'll actually use here, is to use the dotnet ef command again, but we're going to use the database set of commands to go ahead and update the database. This is going to go into our project, look at the migrations, and update the database to the latest set of migrations. In our case, there's only an initial database, so that will create the database and then create all the schema that we needed. It said Done, so it should've done it. Let's go back to our trusted SQL Server Object Explorer and refresh, and we now see TheWorldDb, and it has unsurprisingly two tables, one for Stops and one for Trips. And there's also an EFMigrationsHistory. This has some data in it about the current state of migrations for our database. But this is only being used by the tooling. You shouldn't have to ever actually look at this. It's the Stops and the Trips that matter. So let's look at the Trips, Columns to see what it actually built. We can see it created a primary key for the Id, and it did this by inferring that a name called Id or ending with Id would be a primary key; otherwise, there are some ways to hint to EF to make it a primary key. It also created a Date column for us, an nvarchar for the Name, and then an nvarchar for the User. But if you remember, there was one other piece of information in here, and that was the collection of Stops. The Stops table, because it knew about that relationship, actually has a TripId as a foreign key, as well as all of the other fields that you probably are unsurprised by it creating. So it actually created this relational structure for us based on that description of the entities we created. So we now have a database that we can actually store this stuff in, and if we go ahead and look at our AppController again, now that we have the connection string set up and the database created, we should be able to go and run this query. And we are going to get data, but of course there's no data in the database. So it's not returning any data. Let's do that next by creating an initializer, something that will add some sample data for our application without us having to go through the trouble of manually adding it one by one or scripting our sample data as sets of SQL. Let's do that next.

Seeding the Database

Now that we've got a database, let's go ahead and seed it with some sample data. Entity Framework doesn't have anything built in currently, they may in the future for seeding the database, but doing it's pretty simple in ASP.NET Core because we have all the different pieces we're going to need. In the Models directory let's create a new class. We'll call it WorldContextSeedData. Let's make that public, as usual. Let's create a constructor with the ctor snippet, and let's add a World Context Object to it, because we're going to use the World Context Object to add new see data if we need it, and like before, we'll go ahead and save it here at the class level. Then we'll need a method. Public async Task, and I'm going to make this asynchronous because one of the calls we need to do is going to be asynchronous, and we're going to return a task, since we're not actually returning a true or a false, we're just going to execute it, and we'll call it Ensure Seed Data, but you can call it anything you want. Now that we have the method, let's see first if we need to actually add any data. So I'll start by just testing if a context object has Trips.Any. Now, what the Any will do is go and return a Boolean if there are any objects in it. We could also put a lambda here to test to see whether any objects pass some qualified test. But for us, we really want to see are there any trips in the database so if there aren't any trips, then we need to add some sample data, but in every other case, when we call this, it will just skip creating the seed data because we've already created the database and the sample data. So we're going to start by creating a US trip, by creating a new trip object, and then we can set the data for our sample. I'll say DateCreated=DateTime.UtcNow, so we're creating it right now, so that's probably fine. Name = US Trip, UserName = , and we'll just put an empty string there and add a little to do at user name. Once we get authentication working, and then finally, Stops = a new list of Stop, and we're going to leave that empty for now because we're going to add actually some stops in a moment. That's just creating an instance of the trip, but we're going to need to call the context.Trips.Add to go ahead and actually add the US trip to the database. Now this is adding it to the context, we're going to save it in a moment. Let's add here the stops as well, and we'll do Add Range to the UStrip.stops. So what this will do is it will take all the stops that we've added to this trip object, and add it to the stops table essentially, inside the database. Let's repeat this for World trip, and we'll do the user name again as an empty string, and put a to do, and we'll just create an empty collection again. And just like before, we'll do context.trips.add our World trip, and we'll do the same thing with stops and add range for our Worldtrip.stops. So up to this point we're creating each of the sorts of sample data that we want in the database itself, and we've added it to the context so it knows that these are new objects. The final thing we need to do here is use a await keyword, because this call is going to be asynchronous, and say context.SaveChangesAsync. This will go and actually push that data to that database, wherever that database might exist. Now we could run this and see it work, but let's go ahead and add these stops. Now if you have access to the source code, you can simply go to the resources folder, inside of the source code for the project and there's going to be US trip, and a World trip cs file. This is the same place that you got the user image that you used earlier in the course. If you don't have access to that source code, I still have these demos out there, and these demos are available on a GitHub repository, and you can see that link here at the bottom. So I'm just going to open these files in Visual Studio, but I'm not adding them to the project because they're actually just a collection of stops so that I can copy and paste them over. You could hand type these as well, but probably not what you want to do. And so for our US trip I just have a set of US dates, and one of the things you'll notice is that a pre-populated demo that's actually longitude and latitude, so we can map them later. And the World trip is the same thing, but it's a much larger trip, this actually mimics the World trip that I took after I got married, so it's a lot more stops, but hopefully that will end up as being a good list of just sample data. Again, if you don't want to bother with all that, just add your own random stops with names and arrival, and again, just simple object creation. So we have the seed data object, how do we actually get it to be executed? We're going to actually do it in Start Up. This is going to take two phases. First, we're going to add it to the services by adding a transient object. And here we're just going to supply the class name, WorldContextSeedData, and again transient is going to create this every time we need it, and we're going to inject it here directly in the configure method. I'm going to move this to a separate line so it's a little easier to see these, but now I can say WorldContextSeedData, and I'll just call it Seeder. Now you might be wondering, why bother adding it to the services collection, when I'm just going to need it here in configure. Why don't I just do a new World Context Seed? And the reason is the context itself. Because if we need other things, we want the dependency injection layer to follow down all those dependencies for us. Remember World Context also requires a configuration object, and it also requires some other things, or may even change in the future for that, so by leveraging the dependency injection layer, we're going to gain the benefit of the construction here is going to be automated for us. And for the World Seed Data, let's go ahead as the last thing we do, after we even add NVC to the project, let's call it. Seeder.EnsureSeedData, snow, parameters, and I'm just going to call Wait. I'm going to call Wait so this becomes a synchronous operation, and then it's going to return. Though our problem here is I can't make configure an async call, has to be synchronous, so I'm going to use the little trick of using Wait instead. So if we run this now, our seeder should be executed, and then when we do a query for our data, the data should now include those two trips. Here's the trip for the US trip, and the trip for the World trip.

The Repository Pattern

So let's introduce the Repository Pattern. The idea behind a repository is an interface that we could implement in test scenarios fairly easily. Becomes a unit of work for queries to the database, and really wraps that context class so that we're not having every user of every page, or everyone implementing each page, having the write the queries themselves. So here in Models I'll go ahead and create a new class. I'll call WorldRepository, as usual make it public. And what I really want to do in the repository is I'm first going to need a constructor because I need, big surprise, a World Context class. Now go ahead and generate that, and then in order to get all of the trips, for instance, let's start a new method, and I'll say that we're going to return a collection of trips, and we'll say Get all trips, with no parameters. And then we can simply use the context to generate that query. And so while this is the same code we wrote before, we might find later that there's some benefit to having a single place of entry for each of these queries, so that if we end up having to tune it or change it, that we have the single entry point, but more importantly, that this repository could me mocked up for testing, so that we can test the controller against this repository or against a fake repository, to make sure the controller's doing everything it's supposed to do. So this is a very common and beneficial pattern that you're going to see in a lot of web development. In order to make this an interface so that we could mock it up later, I'm going to use refactoring by going to the class name, and hitting control + period, to extract an interface. This will pop-up a dialog for Extract Interface, and you see that in named it IWorldRepository just as the common pattern for doing that. You can change this if you want. Should have the filename that matches that, and then we're going to select all members that count, and in our case there's only going to be one for now. And for some reason it actually failed to finish its work, it crashed. Probably has to do with the current state of the tooling. In much like the other refactoring, we ended up with an I World Repository in the root of the project instead of here in Models where it belongs. You'll see that it actually created the interface correctly, so we can go ahead and close that, and just make sure we add it here to the actual repository. So we've got the repository and we have an interface that matches the interface we want to use. Let's go back to Start Up and allow it to be used by adding it here to configure services. Now this is a place where we may want to decide on what kind of dependency injection we want. So I'm going to go ahead and add it, but I'm going to add it as a scoped service, and the reason for this, is it may be expensive to actually create the context class that we need in the repository, so I only want them to be creating one per request cycle. And so scoped is going to allow me to do that. And inside of the generic arguments, I'm going to first give it the interface that I want to ask for, which is World Repository, and then then instance of the class we want to use for that. The trick here is that here in our website World Repository is the correct way to do this, but you might, if you had a test project, have something like a mock world repository as the implementation of that interface. So it might have different versions of this for different use cases, one that might be real here, or one that might be mocked up in let's say a testing scenario. Now that we've added this, let's go back to our controller, and let's change the way we're going to use this. We're not actually going to use the context bare, and that's on purpose. Again we don't want to necessarily be doing direct queries here, but you certainly can, I just think in most cases there's a benefit to having the repository pattern instead. So I'm going to replace the injection of the context with the injection of the I World Repository. And then that same way I'm going to replace the member. Let's go ahead and generate that, and then I can use the repository, get all trips instead. So now that we're getting the trips through the repository, when we inject the world repository into the constructor here, we're again, allowing that dependency injection layer to determine everything we need. So we're saying we need the interface for World Repository, which it knows that we really need this class, World Repository, and then World Repository, in order to be created, needs a World Context class, and because the World Context class, in order to supply it needs to be created, it knows it needs a configuration route and a DbContext options. Now, in this way, this interface was registered so it can just pass it in as that singleton and then craft the DbContext options based on the information that Entity Framework registered with the service collection. And this is really the power of using the dependency injection in this case, is that as this changes it has different requirements are brought in, the dependency injection layer is going to figure out all of the requirement and supply them as necessary. Becomes much easier for us to write the code. In the controller, now that we're getting the data, earlier we had passed it into the View, but we weren't doing anything about it, right. So let's go to the View for that. Let's talk about that. Earlier, in the contact page, let me actually bring that up, you remember that we had the model for the contact view model, 'cause we were using it for the form, but that's not the only case where you're going to want to use model. In our case we're going to use a model for IEnumerable trip, and we'll need to add the entire name of trip here, and so the model becomes that collection that was actually passed in, only passed it into the View, it means that we can start to use the model. And this is strongly typing it. Let's comment this out for a minute, so I can show you what that actually means. So now that it's commented out, if I come down here below the map, I can still do razor calls based on the model, but the model type here is actually dynamic, which means it doesn't know the type, and I'm able to still write razor code, and let's wrap this with the unordered list to be able to show data, this works. Let's run this real quick so you can see that. So now seeing the different trips as an unordered list underneath our Map title, but the benefit we're going to have is in development. If we change this to specify the type of model, when we do this, we're going to know that this is numeral type of model, and more importantly when we do name, we're going to get intellisense, so that we know the kinds of things we can actually show. So here we can say date created, to string, and we'll do it to a short string so we can see it. Refresh this, and now it's still working, we're just being given a better development experience, because we've typed the model up top. And that's one of the benefits of using model, not just the shape you're going to use inside of the form like we saw on the contact page, but also so that as you're writing the razor code, that it makes a bit more sense. So last thing in this module that we still want to do, is show that we can log any exceptions that we actually run into. Let's do that next.

Logging

So let's talk about Logging. In our project here, we'd like to have a way to more easily show when exceptions actually happen. So in our project here we'd like to have a way to log information as it happens, and even see information that is logged by other systems. And that's where Logging comes in. Let's go back to Start Up, and in configure services we're going to want to add support for logging by saying services.addlogging. It's going to add all the interfaces and services required for logging, or opting into that, and then here in the configure, let's go ahead and ask for an Iloggerfactory interface, and that's in Microsoft Extensions Logging, and from this factory, we can add certain types of logging. For development, instead of actually writing out to a log, let's use that factory to add a debug logger. Now debug, as a logger type, is actually in another package. There are different packages for writing out the console, writing the debug, and then there are other ones that'll allow you to write other sources like databases and such. So add that package, and when we add debug, we can actually tell it the minimal level we want to log. And in our case, let's go ahead and say we want information level, and again I've put this inside of, if it is a development environment, but let's go ahead and do the same thing here for non-development environment, and let's change this to something that isn't as verbose. So let's go ahead and say that we want to log errors or better. This log levels are how many log messages actually get dumped out. Let's run this before we start using the logger so we can see what actually happens. The Entity Framework Core actually has a lot of debug information, and we're telling it to go ahead and write that out to the debug window. So we've run this page, and we've run this non-error situation right, we went to the database and got some data, and here in our output window, inside the debug source, we're going to actually see that Entity Framework has written to the debug the actual code that it's using. The select case is actually the any call inside the seeder. This is the way that it's efficiently as much as possible checking to see whether there is at least one trip in the database. And then down here further, you're going to see a select for actually getting the trips from the database, and there is no where clause, because we told it to get all of the trips. And so the way Logging works is it allows the system to write out these logs and then we're opting into the different kinds of listeners. And debug is the listener that will write out to this debug window when you're debugging. Let's create our own messages here so we can actually see what's going on. Let's go to our App Controller, and let's add support for Logging, and the best way to do this is to actually ask for the system to give us an ILogger object, and the ILogger object we're looking for is actually an ILogger for ourselves. So we're going to use the generic parameter of App Controller in this case. We're going to need the name space of Extensions Logging, in order to bring in that logger, and then just like everything else, I'll go ahead and keep it at the class level. What this is going to allow us to do is actually look and trap errors, so I'm going to try and catch, in case something bad happens in my query, and then I can use the logger to log what kind of message this is. Is it a critical, debug, error, etc. In my case, I'm going to assume it's an error, and I'm going to say, failed to get trips in index page. And then I'm going to just include the error from the exception, by using the dollar sign interpolation here, and I can just say ex.Message, and that way that'll dump it out to the logger, and then I can return something different like redirect to error, or some other operation, if this fails. More importantly, it doesn't matter what I'm doing here nearly as much as that I'm logging the exception, even though I don't want to necessarily show that to the end user. This is the best way to handle the case of I have an exceptional case, but I don't want to just throw a 500 error to the browser window, I want to catch those sorts of exceptions and then do something about them, and add a minimum log the problem so that we can look at the logs later and do something about it. This is the same way you're going to use Logging throughout your system if we had decided to add Logging, let's say to the repository, we might add Logger for World Repository, so let's add that using again, and in this case instead of logging just exceptions, which we certainly could do here, I'm going to use the logger to log some informative messages like getting all trips from the database. Now I don't have to put the name of what is calling this log message, because all of that will actually emit it into the log, which is why we're using a specialized logger with the class name already in there, the logging system does that for us. So let's run this again and see if we can find our new actual log message. We're not going to see the error, because obviously no error is happening, but if we look at output, we should see this line, the World Repository information. The first section is where it's from, the second is the type of message, and then here we're saying we're getting all the trips from the database. And then this way you can add your own logging messages for debugging and such. Obviously we wouldn't want it to show all that information in production, because it's going to slow us down, but that's why we can change the log level, depending on our environment. Now we have the beginnings of Entity Framework working really well, but we're going to be extending this as we go ahead and build both the API as well as the identity structure, so we're going to be coming back to the Entity Framework quite a bit in the rest of this course. Let's wrap up this module.

Summary

This module represents a beginning point in understanding and learning Entity Framework. We haven't looked at it at all exhaustively, to all the given things that you might want to do, like start with an existing database, or go into complex queries and those sorts of things. If you want to go deeper, there's a couple of different courses I'll recommend. One is EF 7, Looking Ahead, by Julie Lerman. You can find that at Pluralsight.com/courses/entity-framework-7-looking-ahead. The current version of this course is looking at an earlier version of Entity Framework Core, before it had been renamed from Entity Framework 7 to Entity Framework Core, but the main concepts are still there. And you could also look at my Best Practices in ASP.NET about entities, validation, and view models, which is a course I have here in Pluralsight at aspdotnet-bestpractices-models. So what have we seen in this module? I've shown you how Entity Framework is the beginning point for any of your data storage needs. We're using it for relational, but any Framework Core has been built on the idea of it not necessarily being just for relational data storage. I showed you how Migrations can be used to build the database, and in fact later in this course I'll show you how you can use it to update the schema for database as well. We also saw how adding sample data, or initial data, or even look-up data can be done by seeding, and that while seeding isn't built in, it-s really trivial to build it into your own applications. And lastly I introduced you to the repository pattern, so that you can create a testable way of actually doing your database access while being able to test your controllers with mock versions of those repositories. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET Core 1.0.

Creating the API

Introduction

Now we're ready to create an API with MVC 6. In this module, we'll create the API by first using MVC 6 to create REST endpoints, we'll build on the HTTP verb, as in explain exactly how they work, I'll show you how to do validation inside your API's, we'll talk about ViewModel mapping, and then how to use services in your API. Let's get started.

Create an API Controller

Let's start by creating an API controller, a controller specifically to expose in API. We're going to start in our Controllers directory, and I'm going to create a new folder and file for API, and then I'm going to call this my TripsController. This class has to be public, and then we're going to drive it from controller, just like we did when we built our controllers that are going to return views. In this case, we're going to return data as an API, and we're going to do it with MVC 6. This is unlike earlier versions of ASP.NET, where you had two different worlds, API controllers and view controllers. In MVC 6 everything's a controller, both kinds. It'll just change based on what you're going to actually return. Let's see what that looks like by first creating an action that returns a JsonResult. And I'll just call Get there, and say return Json, and I'll just create a new Trip object here, and just set one of its values just so we can get this data returning. And I'll just say the name's going to be My Trip. We'll get data out of the database in a minute, but let's start with this very simple version of it, where we're going to return just a new trip, using the Json result and then the Json as the method that's going to aserialize this for us. But before we can test this, we're going to want to turn off by going into Properties, the Debug Launching the URL, because instead of using the browser we're going to use a tool. This tool's called Postman. If you go to getpostman.com, you'll see that Postman is available on PCs as a Chrome App, and on Macs as a Mac App, and this is a tool that I like to use to test our APIs. So in our case we want to be able to perform and get, based on a certain URL, and in our case that's going to be API trips. So back in our controller, we're going to use the HttpGet attribute to specify what the route is, API trips. So that when we make a request to the server for a URI that matches that, this method will be called. This is akin to what we did in the startup, when we built our Default route here. Where we built default route, and specified that this was going to be the pattern, and that pattern was going to be based on App and Index, back in the MVC module, but instead we're going to use this attribute to specify it directly on our action. So let's build this, and if we execute this, we should get that Trip back. Notice that it has default values for everything, but that by calling this request and calling Json, we're getting this behavior of just serializing our data back, and it's being serialized as Json. But using the JsonResult and the Json doesn't give us a lot of opportunity, because we have to return Json at some point. We can't easily return any sort of errors. And so my preference, and my suggestion is to use IActionResult, just like we did before, but instead of using Json, we're going to actually specify with a helper, what we want to do as returning the response code, and OK is the 200 response, or the normal response when a success has happened. So we change our code to use IActionResult and OK, and we execute this again, we'll see that we get the same result. The reason this is better, is that if something bad happened, if let's say something bad happened, we could also return other result codes, like BadRequest. So here we can return BadRequest if we found some state where we needed to handle a BadRequest being returned, or a 400. That's usually the case when you're sent bad information in the actual request. So let's build this for a moment, and if we execute it instead of getting the result, we're actually going to get this 400 result, the BadRequest that people calling the APIs can actually test for. So we're actually using the status codes plus the verbs in a real way to build your API, and this is in my mind the right way to build APIs. So let's change our control to use a repository, instead of our dummy data. Let's do that next.

Returning Data

So now let's return some real data from the database in our API. In the API let's get rid of our BadRequest for now, we're going to reintroduce that later when we need it, but we wanted to introduce a constructor here, because we want to have our IWorldRepository injected into our controller. This is the same thing we were doing earlier, with the controllers that were returning views. We can use it in really the same way. So instead of returning the trip here, let's go ahead and say repository GetAllTrips, and take whatever the result is from that value here in the OK. So let's run this in Postman, and we're calling the same call but we're going to go out to the database to get it this time. So we can see what we're getting here is the result. It's a collection that contains two results, one for the US Trip, and one for the WorldTrip. Now we're not getting the stops associated with that, but I'll show you in a little bit how we can get those as well, but we're getting everything else we want. But one of the problems is that when it's serializing this as Json, it's taking the Pascal case that we have in the C# classes, and just serializing it as is. And what we'd really like to do to make sure that this is easily consumable by whomever is going to call it, is to make this a little more friendly in Json, and that is to Camel case these instead of Pascal cased. To do this we're going to go back over to the Startup, and when we add the add the Mvc, we can actually send in and action a lambda for setting up Mvc. What we'll want to do is, what AddMvc returns is something that we can call AddJsonOptions on to, and this is a special method we can call to pass in a lambda for us to configure what happens for our Json results. And in our case, we'll call config, SerializerSettings, ContractResolver, and we're going to change this to a new ContractResolver that comes with Json.NET which is the serializer for all of ASP.NET core called CamelCasedPropertyNameContractResolver, it's quite a mouthful, and we'll see that's a Newtonsoft Json Serialization, which is where Json.NET comes from. And by replacing it with this new Resolver, if we build this and run it in Postman again, we'll see that our properties are now Camel cased, starting with a lower cased letter, but it is still leaving any additional breaks in the names, like the C in Created or the N in userName, and maintaining those as Camel case, so that anyone consuming this, especially JavaScript consumers will be able to use this in a more natural way. So now that you've got a simple Get working, what about being able to add a new trip via our API? Let's do that next by implementing POST.

Using POST

So now let's implement POST so we can support creating of new trips. Let's start in Postman and see what a request actually looks like. We're going to leave this same URI, so we're going to go to API trips just like before, but we're going to change this to be a POST, and the idea here is that the different verbs have different actions. GET is retrieval of data, POST is creating new data, PUT is updating data, or you might also hear about PATCH as updating the data, because they do it in a little different way, and then there's the verb DELETE, which obviously also just deletes data. But let's take a look at POST, that's the one we're most interested at this point, and so for a POST we can actually have a Body, and we can get at the parameters that are being sent with the POST by clicking on this Params button. And so that adds a section here in the top, where we can specify the Body of the POST. In the case of a POST, all the data that you're sending is usually going to be in the form of some Body, and so for us this is just going to be a raw Body that we're going to send as Json. So let me write this, and I'll just say My New Trip. I don't need to specify all of the pieces, but that should be good enough, and if we send that we're going to see that it returned a 404, a Not Found. The reason it returned a Not Found in our case, is that we haven't implemented POST yet, so let's do that. Back in the TripsController let's create a new ActionResult, and we can call it anything we want, but I'll call it Post since that's what it's actually doing, and I'm just going to return an Ok of true for now, just a really simple result. But what POST wants to accept as a Trip could be an actual Trip object, and then I'll add the HttpPost here, again it says using the attribute based on the verb, so that it's going to match this URI and this verb of POST, to try to call this method itself. Now I'm talking about sending in an actual Trip here, but we could even do something as simple as string name. Let's go ahead and set a breakpoint here on the Ok so we can look to see what happens. We've started the debugger, and if I send this request now we're going to come down here and see that we're not getting the name correctly in the Body of what's being sent. We actually have to do something more interesting, let's change this to Trip theTrip as the body of the message coming in. Let's see if that works any better. We can see that we're getting a Trip object, but the Trip object is missing all of the data, to actually just a null Trip object here that's being passed in, because it's attempting to take that object that we have sent in, and map it to one of these property names. Let's let this run, and let's change this to be Camel case, just like our results were. Let's see if that's any better. You can see the Trip again, but we're still not getting the names, and the reason is that we have to tell it where we're getting the data in this POST. It could assume that this is coming from the URL or some other places, so we have to say FromBody. It's an attribute that we can put directly on the Body of the POST to say please map, please model bind is the correct term. Model bind the data that's coming in with the POST to this object, by trying to match up the names of the property of the Json, to the names of the property of this object. Let's run it one more time now that we've made that change, and let's test it here again from Postman. We're getting back inside the Body, but we're now getting Name mapped. Now I only included Name, I didn't include the Stops, or the UserName, or the Id, or the DateCreated, because the data that's coming in doesn't have to match that shape one for one, it's going to try to map as many of the properties as possible, and then the rest of the properties are going to get default values. So one thing to notice at this point in creating the API, is that we're using two attributes, but the attributes have the exact same URL pattern in them, api slash trips. We'd like to be able to centralize these, and we can. At the class level we can add an attribute called Route, and Route allows us to put the base Route for the entire class. So if we put api trips here, we can then make the Get and the Post just to be empty, and because they're empty it assumes they are just the same URL as the route. But you could imagine doing something like, putting slash foo in here, and this doesn't replace the Route, it amends the Route. So in this case, this method would be called on api slash trips slash foo. And we'll go ahead and do that in a minute, but we're not going to use it quite yet. We want to centralize that, and this is a pretty common practice when you're building APIs or Controllers for views. Now that we have the Route working, and we're getting the data through this FromBody, we're ready to actually start validating and then eventually saving this data. Let's talk about validation and mapping next.

Validation and View Models

Now let's talk about validation and View Models in APIs. If you remember the POST we have created in the last video, we can check for the ModelState, just like we did earlier in the Contact page. Calling an API is no different than calling a POST that results in a view. You have the same facility to see the data here, and then to test to see if it's valid. In our case we'll change this a little bit to use the Create call, because since we're in a POST it expects it in success for it to actually return a 201, which is a Created status code. And the Controller's going to help us, because it knows that what we need in order to return this is not only the object that contains the data, but also the URI to the location. So we'll just mock one up here as api, trips, theTrip dot name. And then if the model state isn't valid, then we'll just return a BadRequest. Let's see what this looks like in our API. If we go back to Postman and just give our trip a name like Fun, when we send this we can see that the Trip data is coming back in, there's our name, Fun, and that the model state is coming back as a valid, as true. That's because we don't have any of those same validation attributes used on the Trip class. Let's talk about that for a minute. I'm going to navigate over to the Trip class, and I could look at this and decide that, you know, we might want the Name to be required, and maybe string lengths and things like that. But I don't actually prefer to have those attributes here, much like we did in the Contact page earlier, I prefer to have View Models that really represent the contract with the client, 'cause not all of this data that's in our Trip is one I want to communicate to the client. The current UserName, since that will normally be stored in order to check to see whether a Trip belongs to a user, we don't need to expose that ultimately to the user. Same might even be true of Id, we might not use Id as the Id that we share with the user, it may just be a primary key to the data store. And so an alternative here is to use a ViewModel for Trip. Let's come down to the ViewModels, and let's create that ViewModel. And I'll make this public, and I'm going to create a couple properties. In our case, I'm only going to have the Name, and the Created DateTime for when the object was created, and in our case I want to use the Created Date as when this was made, unless someone overwrites it. So I'll just say DateTime dot UtcNow, so we have a value for Now that is based on the Universal Time Zone. So now we have that ViewModel, let's go back to the Controller for a minute. We'll probably need to bring in that namespace. And now, just because we have a TripViewModel doesn't mean that this is going to ever return as valid or false, unless over here we actually use attributes, just like we did in the Contact page. So if I say Required, and bring in the System Component Model Date Annotations, then I can add these as I need, and I'll use StringLength here and say maximum of 100, and minimum length of five. So you could have put this on the Trip itself, it really depends on the kind of project you're doing. There's often a question I get about should I be using ViewModels, or can I just use the entities? And some of this has to do with the size of your project, and how you're exposing the contract, because the shape of the data you return from an API is part of that contract, and if you need to hide any of that information it's better to hide it by creating ViewModels, than trying to do some trickery in the way the JavaScript is being generated. I tend to start, usually by using the entities, and then moving to ViewModels if you find it's necessary for the kind of project I'm building. But still, maybe half the projects I ever build, I end up using ViewModels for. So it's a hard question to ask, it's really dependent on the kind of things you're doing. Now that we have some validation attributes, our Controller should be able to actually test for them. So if we go ahead and run this in Postman, remember that our name might be too short for our validation, so we're going to come down here and see theTrip still has that Fun in it, but now it's actually theTrip ViewModel, that only includes the pieces that we seem to be interested in. And then we can see now that the ModelState is going to be false, and it's false because that name is just too short. In fact if we look into the ModelState object we can actually see that there's a set of values, and here it's going to say the Key is Name, and the ValidationState is Invalid. So we know in fact what field is wrong. Normally we would return this, and just get the 400 error that we see here, and also whatever data you want to send back to the client. One common approach here is actually to send the ModelState itself in the request. Now I don't suggest this in a public API that you want other people to use, but if you're the only consumer of your API this ends up being a pretty valid way to communicate the ModelState, any errors that are coming down. Let me send it again, and I'm just going to press play through it, and you're going to see that even though it's still returning a BadRequest, the data that it's then returning with is going to be each name of each field that is wrong, and then an error message that could be displayed. So now that we have this working, so that we can test for the ModelState, and we can do the right thing to sending the right status code that results in the correct answer to whether the POST was actually created or not, let's next talk about how to switch between ViewModels in actual objects we want to store, because ultimately we want to save this data to the database. And we can't save the ViewModel to the database, we want to convert that into an actual Trip object that we can store to the database. Let's do that next.

Using AutoMapper

So let's talk about using the open source project AutoMapper to solve some of the problems we have in saving it to the database. So if we're going to save this to the database, one of the first things we need to do is convert our ViewModel over to a newTrip. And we can certainly do this by just saying new Trip, Name equals theTrip.Name, and kind of go on and copy each of the fields one by one. But that's not a good approach, because it's very hard to copy this same code over and over and over again, and we also want to be able to handle things like that the field names are different here. And that's where a project called AutoMapper can really help us. So let's talk about that. AutoMapper is just a NuGet package that's going to allow us to do this. So let's go back to that project json, let's go to the end of the dependencies and let's add this. So as I type, we're going to get that same intellisense we have talked about, even for non-Microsoft projects. And I'm going to go ahead and pick a fairly recent version, 4.2.1 to add to our project, and so it's going to bring in the assembly so we can actually do this. So if we go back to the Controller, this is going to allow us to create our newTrip by calling a class called Mapper. And it's in the namespace of AutoMapper, probably unsurprisingly, and that has a static method on it called Map, where we can tell it that we want a Trip object, and we want to pass in theTrip, all right? So this is indicating what we're going to return out of this, which is going to be a newTrip, and what we're going to pass in is just the source information from that. So at this point, we should be able to send back the newTrip as a result of our Created, assuming the data's valid here. But we have a problem in that this assumes that maps have been created between the two types, from Trip to TripViewModel essentially, and the way we do that is actually in Startup. So you can do this anywhere in Startup really, but I'm going to go ahead and do this in Configure, 'cause I feel like it's about the right place to do it. So here we're going to call a method on Mapper, just still in that namespace, called Initialize. And Initialize takes a lambda, and we'll use a multi-line lambda because we might have a few things to initialize to do all the setting up of these Maps. We do this by calling config, CreateMap, and we can just use generic arguments to say to and from, and they will try to match all the field names based on that. So I'm going to go from TripViewModel as my source, and I want it to return a Trip. Now that I have Initialize, our code over here where I'm generating a Trip from a ViewModel should work. Let's debug this so we can see it work. Let's change the name of our trip to Trip Canada, and I'm doing this so it succeeds in our requirements. Our requirement is that the name has to be at least five characters long, and so by changing to Trip Canada we should get lucky. We come in and the ModelState is valid, so it's going to let us walk in, and then I want to convert theTrip which has two pieces of data, Trip Canada as well as this Created date. And I want to Map it to our newTrip. Now look at our newTrip that's been created, and we can see Trip Canada, but uh-oh! The DateCreated isn't being set, and the reason it's not being set is our Trip has a method called Created, not DateCreated. So in essence there's a few different ways to handle this, usually I have the field names the same in both classes, and we can fix that briefly, or the other alternative is you can write configuration that will Map one field to another. But because of the length of this course, I don't have time to go through a lot of those permutations, but it's those sorts of things that AutoMapper can do really well, so you can save the state of the kinds of conversions you want to do. Let's stop this for a moment to go over to my TripViewModel, and let's just change this name to DateCreated so that it fits, it's the same name as we had before, and let's try it again. So as I send it, we're coming in here and we can see that the State is valid and when I map the newTrip, we should be getting the new Create date. So it's now mapped both of these fields, because the TripViewModel has both of those fields by those names. Didn't map these other three, and it left them with their default values because it couldn't find any match between them. Now we could return this newTrip directly in the API, but if we're expecting a TripViewModel here, or the shape of a TripViewModel more importantly, we might as well return TripViewModels as well, so we're never exposing these sort of internal parts over our data structures to the outside world. So we still need to save to the database, and we'll get to that in a minute. But when we're done saving, we're going to want to return this, and we can do the same thing. Mapper dot Map, TripViewModel, so it's going to be the opposite of what we were doing a minute ago, and now I want to return the newTrip based on that. Now I'm doing this with the newTrip, because the database might actually change some of this information for us, so we want to make sure that we're sending the object as it's going to look after any database calls. So let's run this and see what happens. Here in Postman if we Send it, we're going to actually get an error. This is that same error page that was being returned, because we had used a developer exception page. But it does tell us that there is actually a Server Error happening. Let's debug this, and see why. So the ModelState is fine, converting to our newTrip is fine, but writing out our newTrip back to a ViewModel isn't working, and the reason for this is that when we set up our Map, we set it up going from ViewModel to entity. It's only a one-way. We can reverse this by actually calling ReverseMap at the end of it, and this creates this as a map and the configuration, and then creates the reverse so that we have both directions handled. So if we do that ReverseMap again, and let's go ahead and just Run this in Postman, we can now see that our Trip was created, 'cause we have the Created result here, and that we're getting that Map back from whatever the database had actually done to the data. So let's take this one step further before we go on to the next subject. If we look at our Controller, we know that our Controller for the Post now is using the Mapper, but what about the Get? So this is getting the result by calling the repository, and then what we'd like to do in the Ok is use the Mapper to Map TripViewModel our results. Now the problem is we're not actually dealing with an individual trip here, this is going to return an Ienumerable of trips. So what we have to do when we're using Map, is tell it that it wants to return a collection, and in our case Ienumerable is fine, 'cause that's actually what we're going to return, and then the results will be a collection of trips that it converts into a collection of TripViewModels. When you configure Maps in AutoMapper, it not only creates Maps for the TripViewModel to Trip, but it also creates it from a collection of ViewModels to the collection of entities as well. So you're getting both, without having to worry about it. So this will work without any additional configuration of the Maps. Let's run this just so you can see that. So let's change this back to a GET, let's Send this, we can see now we're getting that same data being returned, but we're only seeing what is in the ViewModels. We're not seeing what is also in the database data in the entity itself, and so you're going to have to make those decisions about what data's there as well. But here in our call, we'd like to have a way to handle the exceptional case, just like we've done here with returning a BadRequest if it's invalid. What about for our queries? It's actually a good idea to go ahead and use a try catch with a bad result, and so we can go ahead and catch the Exception and then return a BadRequest, and one of the things you can actually return is the Exception itself, though normally I would just return something that could be shown to an end-user. Showing them the actual Exception might expose some internals about how you're building your application. That's sort of up to you. You don't want to lose that Exception information though, we're going to add a TODO here for logging, so we can go ahead and log this error even though we're going to send this back to the user as just a BadRequest. Let's talk about logging next.

Using Logging

Now let's support logging inside of our API Controller, so we can see how that works. We're back here in the API Controller, and we have a space to do the logging, so let's implement that. If you remember back in our Startup, we actually used something called the LoggerFactory to set up what logging we wanted to do. In this case, we're just writing out to the debug stream our information about whatever is being logged. Certainly as you go more towards production and those sorts of things, you might end up logging to the console, to files, to a database, to a third-party store like Elmer or something, but this just sets up the where you're going to log. What about actually adding log items yourself? In most Controllers I suggest that you actually use this, and you do this by having the system inject an ILogger for your class, and so the idea here is that you use the generic argument to include your class name, and in our case that's the TripsController as a logger. And let me bring in the logging extensions namespace, and then I can store this logger here just like I did with the repository, and create a field for it so we can actually use it. And now that we have this logger object, this logger object is going to know about what class it's being logged from, so we don't have to do that especially, and we can just simply say logger dot Log. And I'm going to decide that this is an Error, though I could change this to be LogCritical if it were a really big error, or Information or Trace if I thought it wasn't that interesting, but for our case I'm going to say Error. Each of these names represents a different level of logging, and so as you turn up or down logging, you may want things like performance numbers to log at the information level, so that when you're in production it's not actually running a lot of that stuff. But later on when you're running in debug, where you have almost all the logs turned on, you might want to be able to see that. So here I can just say Failed to get All Trips, and then include any arguments I want for that. And often I won't even bother sending in the Exception that way, I might go ahead and just use the Exception here so I have the entire Exception inside my log. My suggestion is that as you include try catch to handle some of these cases, you're going to want to log as well as let someone know that they've done the wrong thing. But your logging certainly can be over verbose. I've had situations where I handled things like, file not found for bad URLs, and I've had it do something like email logging, and sound like it inundated with them as people are probing sites and doing things like that, and I can really sort of ignore most sort of missing pages, because a lot of those missing pages are either mistypes, or like I said probes, so I don't have to worry about it. So you can kind of decide at what level you want to handle this logging. But I suggest in many cases, most of your methods will need to do logging for some Exceptional cases, depending on what you want it to do. So we've gotten this far where we're actually being able to save our new Post, but we're still not saving it to the database. Let's finally do that next.

Saving to the Database

So finally let's save the Trip to the database. So here we'd like to be able to use our repository to add a Trip to the database. Our code should be as simple as that, but we don't have support for it in the repository yet, so let's go ahead and implement that. Let's first go to the interface for the repository, and let's add a couple of methods here. One will be AddTrip that takes an actual Trip object. Now you could have your ViewModels directly here in the repository, but I find it actually more useful to deal with the actual entity objects when dealing with the repository, but there's certainly nothing wrong if you decide that is something that makes more sense to you. A lot of these cases, it's more of a judgement call than some black and white rule that you might be looking for. So AddTrip in our case is just going to send the new Trip to the underlying context, and then we want to be able to, when a number of changes are being made, go ahead and save all of those changes in one fell swoop. And so I'll go ahead and add a, let's make it a Boolean, SaveChanges, and I'm going to make it Async, because I think it's probably a good idea to make longer-lived operations like saving to the database in a synchronous call. Here I'll be able to test to see whether the save was successful and return that true or false, and then this will save all of the changes that happen added to the repository all at once. So let's go over to our repository, and let's implement this interface, so we get these new methods that we have to implement. So for the AddTrip it's not that big a deal. We're simply going to go to the context, and say Add our new trip. There's not a whole lot there, it's a thin wrapper around the context but it could allow us to do some more interesting things later as we're dealing with sub-objects and maybe attached objects, or collections on those, but for now that should be good enough to get it in the database. And then we'll come down here to SaveChanges because all that this adding is doing, is pushing it into the context as a new object. It's not actually saving to the database yet. That's where SaveChanges comes in. I'm going to make this an asynchronous call that returns a Task that wraps a bool, so that we can actually call this asynchronously. And because I've made this change, we actually need to put this in the interface as well, because it's not longer just a simple bool, Task actually a bool that returns a Task. So let me bring in that Tasks namespace, and then here what we'll do is we'll call await, context dot SaveChangesAsync, and I'm going to return a Boolean that essentially says is it greater than zero. So the reason I wrapped this in parentheses, is I want this operation to be awaited, but then the result of this I want to actually compare, because SaveChanges and SaveChangesAsync both return an integer that represents the number of rows effected. So if the save failed, it could throw an Exception, but it could also come back as just zero, which means there were no rows effected by any changes. So we want to be able to communicate that. So now that we have the repository doing it, let's go back to the TripsController and say if, and again we're going to need to use async and await now, and luckily the Controllers in ASP.NET, it's as simple as wrapping these as an async action that will make them asynchronous for you. So I'm just going to say if await, repository dot SaveChangesAsync. If that succeeded, then we're going to call Created. And if not then we can still return a BadRequest, but this time we can tell them what actually happened. Failed to save changes to the database, right? We can tell them actually what happened without having to necessarily return them to the actual problem. Now we have two BadRequests here, and they're returning different sorts of information, and that's okay. In fact, another common approach is to just return here, Created, and let it fall down here. But I hate to have it fall down and then return the ModelState, 'cause that would assume that the ModelState is always the problem. So I'm just going to return Failed to save the trip. And we should have a trip that now is saved to the database, and we can see by just using the API. So let's go ahead and run this, and let's see what happens in Postman. So we have here that GET, let's go back to POST, and let's look at that Body. Here's my Trip Canada with the hope of actually adding it to the result, so there it said it created it successfully. So if we go back to making this a GET and issue this, we should get a collection that now includes Trip Canada, which it does. So we now have our POST working, and saving directly to the database so that we can query the database, and get the actual results back. Let's go back and create the Controller for stops now, so we can see how association Controllers are created as well.

The Stop Controller

So now let's implement the Stop Controller as an associative Controller. If we come back to our code here, let's go ahead and add another API Controller that I'm going to call the StopsController. Because our trips has a relationship to stops, we should be able to have a way to interact with stops on their own. So I'll make that a public class, make that a Controller, bring in the namespace. Because of the style of Controller, I already need the IWorldRepository to bring in the Models namespace, and an ILogger for my StopsController, so I can go ahead and log any errors. And I'll bring in the Logging namespace as well. Let's go ahead and assign these as local variables, and I'll use re-factoring to go ahead and add them as members, just like we did in the other class, so I'm not going to go too deep into why. And let's create that first Action. See here we want to return the stops for a specific trip, so we're going to need to get the name of the trip that we want to return the stops for. We're never going to really deal with the stops as a collection on themselves. It's always going to be in the context of a trip. So here let's pull out the trip by using the repository, and call GetTripByName. This is a method we haven't implemented yet, but let's pass in tripName so we can get the trip, and then we'll return the trip dot Stops. And let's complete this idea before we go and implement the actual data work by handling a catch, so if something bad happens we can go ahead and log it. And I'll include the Exception so that's logged as well, and if the return Ok never gets reached, we'll make sure that we always return a BadRequest. So in order to implement this, we're going to need this GetTripByName to be added to our repository. Let's start by going to the interface of the repository, and I'm just going to add GetTripByName, so that the interface now has it, but we have to implement it in our repository. And I'll make sure it's added by just using the control period to implement the interface, and it's only going to add methods that aren't already implemented, and so we should get GetTripByName right here, and it's set as throwing a NotImplementedException, which of course we're going to change. What we'll do is return context dot Trips dot Where, so we're going to use a lambda expression to figure out which trip to return. We should probably be doing something prettier here to handle differences in case, but for now that's good enough. And here, we'll just say FirstOrDefault, so it's going to attempt to return the trip that matches the name we send in. And that would probably be okay as a first run, but I know that from here we're going to need the stops, so I'm going to go ahead and use an Include here as well, in order to get the stops. So we need to go ahead and add the Microsoft Entity Framework Core namespace, and this is going to allow us to eager load that collection, so it'll allow us to add the collection of stops to the trip when it's returned. And the syntax for the lambda here is just the selection of the individual property that we want to include. If we needed to do this for more than one property, we could go ahead and add successive Includes. Now that we've implemented it, let's go back to the StopsController, and this should be returning our correct stops, and this should be returning our correct trip, and we can go ahead and actually Order our stops, to make sure we're getting them in the order that they were created. So this would probably be okay, except we have a long, glaring Exception, and that is what we actually want to do is return not a collection of the Stop class, which is the entity, but we want to return the ViewModel, just like we're doing with Trips. So let's come down here into our ViewModels, and let's add a StopViewModel. If we look at the entity for Stop, we know that we have some of these properties that we want to include: Name, Latitude, Longitude, Arrival Date, those sorts of things. And I'll just use a little editor inheritance, or copy/paste to set these up as the properties for my ViewModel. I'm not going to be including Id here, that'll be our hidden property that only the server knows about. And let's go ahead and add some validation here, just so we have a completed ViewModel, just like we did before with the tripName, I'm going to do the same with the Stop name, and go ahead and make it required, and a StringLength of five to 100. For my Latitude and Longitude, I'm not going to make those required mostly because we may or may not have them set up in every case as we add a stop. We'll be setting these later, so we don't want to force the user to specify them, those'll be more computed values, but we will need the Order to be required, and the Arrival to be required. So we now have a StopViewModel that we can actually use. Now we're not using these attributes in returning the ViewModel, but when we implement POST in a minute we'll need these. So back in the StopsController, we're going to want to use AutoMapper to Map to Ienumerable StopViewModel. Essentially the same thing we did in an earlier version, bring in the ViewModel namespace, Map this collection of Stops to a collection of StopViewModels. We put another parentheses around there, so that we're actually returning this class, the StopViewModel instead of the raw stop, and we make sure AutoMapper's added. Before this will work though, we're going to need to configure it in the Startup. If you remember we had this CreateMap for Trip, we can actually do the same thing here for Stop. I'm going to Map from the ViewModel to the entity, and then I'm going to Reverse that Map so that I have bi-directional Mapping, not just one way or the other. The last thing to do to make our Get method here on the StopsController work, is we're going to need to set up a route. Now we're going to want to specify that this is an HttpGet, but what we actually put in here is of interest. Because we want this to be a Controller that's handling the association of Stops to Trips, we're going to probably want it to be api trips, tripName slash stops. Let's talk about what's going on here. The other Controller is responsible for the api trips route, and in fact we haven't implemented it, but we probably will need to do a getting of an individual trip, and that is done with api trips, and then the tripName. We're going to extend this in our own Controller, by saying that the base route for all of these methods are going to be api trips, the tripName, and then the stops. This means we will want to get the collection of stops for a trip. We can assume that this is going to be. We can assume that this tripName is going to be passed in as a parameter. And in fact instead of being here on HttpGet, let's do it at the class level, because we're going to need this for more than one action. We're going to implement POST in a minute, and it's going to use that same route. With the route defined, we should be able to open up Postman and effectively go and get our stops. Now notice I'm doing api trips, and then the next parameter is that tripName, and I'm including the %20 as the space in that tripName, though if the names of your trips don't have spaces in them, you don't have to encode them in that way. Let's see if that works. So now for the US Trip, we can see that the list of stops here includes all those trips we had created in the sample code. Atlanta, New York, Boston, Chicago, et cetera. In that it's following the pattern of returning the ViewModel instead of the entire entity, so none of the server side only fields are going to be exposed to the users. Let's implement Post on the StopsController next.

Saving New Stops

So now let's add the action that'll let us save new stops. Here in the StopsController we had created the action forgetting the stops for a trip, let's go ahead and do the same thing for posting a new stop. In this case we're going to want to use the HttpPost, and we're going to use an empty string for the route, because we're going to inherit it like we did before from the Controllers attribute. Because of that, we're going to need this same tripName here in the Post, and then we'll accept from the Body a StopViewModel. Implementing this Post will be similar to what we did in adding a new trip. We'll first start with a try/catch block, so that we can handle any exceptional cases, and we'll go ahead and use the Logger to log any errors, and if everything goes wrong, we'll go ahead and return BadRequest. So what are we going to need to do here in the try? We first need to see if the VM is valid, we need to look up the Geocodes, essentially look up the Longitude and Latitude of a new stop and finally save to the database. So let's start with the ViewModel being valid. We can check for ModelState.IsValid just like we did earlier and if it is valid we'll go ahead and do these last two operations. The first thing is to actually create the new stop, by using the AutoMapper again. And ultimately we'll be returning the result which is going to be a call to Created, which is the result of a Post when you successfully save a new object. So let's go ahead and create that location, which is going to be api trips tripName stops, and then newStop dot Name. And then we'll use the Mapper again to convert it back to a StopViewModel. We're going to come back to looking up the Geocodes in a minute but let's look at saving this to the database. The trick here is going to be using the repository, and here we're going to Add a Stop, and in this case we want to pass in the tripName, and the newStop. And then we can surround this with if, await, repository, SaveChangesAsync, then we can return that. If that does fail, we'll fall down into the BadRequest. And because we've made this await, let's change our Controller here to be async, and Task so that we can actually make this an asynchronous operation. The AddStop here isn't part of the repository yet, so let's just use re-factoring to generate the new method, and let's go there so we can make sure that the names are fine. Stop, newStop, tripName, that looks good. And I'm going to move it here just so I can organize the interface a little better, and finally in the actual repository let's implement this. Going to implement the interface which is going to add this to my class, and I'll start by getting the actual trip, so I'm going to Get the TripByName, and if the trip exists I'll go ahead and add the trip to the Stops. Now in the current version of entity framework, this isn't good enough to actually add it to the context, so we have to use that context, Stops, and add that there as well. So the two things that are happening, is that here the foreign key is being set, and here it's actually being added as a new object. We need both of these to happen for our Stop being a related entity, to be saved correctly. Let's see if this is working now. Over in Postman let's convert this to a POST, and for the Body let's create that ViewModel. So for a name, let's say Houston Texas. For arrival let's give it a random date, and then for order let's give it 6. So when I execute the GET now, if we go all the way to the bottom, we should be able to see Houston now exists as one of the new Stops. But we are still missing that latitude and longitude, so let's go back and create a service that'll do that for us.

Implementing a Service

So now let's implement a Geolocation Service, specifically a Service that can get the latitude and longitude for each of our stops. We're going to start by going to the Services folder, and just adding a new file called GeoCoordsService dot cs, and this public class, we know at a minimum that we need an Ilogger for GeoCoordsService. And I'll go ahead and add that Extensions Logging namespace, and then go ahead and create a local logger. To get started, we'll create a new public method called GetCoords, and I'm going to say GetCoordsAsync and ask it to supply us with the name of where we want it to get the coordinates for. Because I've said it was async, let's make it an async method and use a task to return a new type of structure we're going to use called GeoCoordsResult. Let's go ahead and generate that in a new file, and like we've seen before, Visual Studio may be creating this at the root, so let's go ahead and move this up into the Services, so it's all in the same folder, and let's go over to that new type, so we can talk about what we really need. First we need a property for whether it's successful or not, then we need a string for any message, usually only on a false success, and then finally we need a couple of doubles, one for Longitude, and then a number unsurprisingly for a Latitude. Now that we have the result, we can go ahead and close that, and come back here to where we're actually getting the coordinates. First thing I want to do is, I want to create an instance of that GeoCoordsResult with some default values, and the default values are going to be Success equals false, and I'll make the message Failed to get coordinates. We're doing this so that if we need to return it in a failure condition, we don't have to set it up at that point. But when we're doing this successfully, we can just change the properties. Now we want to get a service address, an URL that will go ahead and get our coordinates for us. But to do this, we need a service that will go ahead and convert the name of a place, or even the address of a place, into a set of longitude and latitudes, and one such service is Bing Maps. If you go to bingmapsportal.com, this is a place where you can sign in or register for Bing Maps, and then be issued a special apiKey so you can make calls to Bing Maps to return a bunch of different sorts of things, including the latitude and longitude, which is what we'll be using. So the first thing I need is the apiKey, and then I'm going to need the encodedName. And I need the encodedName because I'm going to generate this as an URL, as a URI. And so there's a class called WebUtility, that's in System.Net that can encode a string for an URL specifically. So go ahead and put the name there, and then we're going to need to construct the actual URL. We can do this by using the URL that the Bing documentation gave us, which is dev.virtualearth.net, and then you can see the rest of it. And it takes two parameters, first the actual query which is going to be our encodedName, and then the key which will be our apiKey. So in a moment we're going to take this URL, we're going to issue it across the web, get the result and then parse some data to figure out what the latitude and longitude are, but let's talk about that apiKey first. This apiKey is something we probably just want to store in configuration. In fact over here in config.json, I could create a new section called Keys, and I'll just call this one the BingKey, in case I had more than one keys. And for its value I'm going to say, DONTEVERPUTKEYSINSOURCECONTROL. The reason I'm doing this, is that I'm going to be checking in the source code at some point, into some sort of source control, and so I don't want to necessarily throw my keys directly into the configuration file. I'd like it to be able to be set once I go live with this project. So that means I could set it at the project level, I could set it at the cloud host, or I could even ask IT department to set it as a environment variable. I want to include it here so I know it exists here, but I'm probably going to override it directly in our project. And you might say well I can override this, I could come over here and set it in the project Properties under Debug, I could set it right here just like we did earlier. Sure, but this file is going to be checked into source control as well, and you've just moved the problem, you haven't eliminated the problem. So on a development machine, you might have a development version of this API, and then you could just set it as an environment variable. In Windows this is pretty easy, you can search for advanced, and look at the advanced system settings. I can do this by going into Environment Variables, and I can go ahead and just add this. So I'll create a New Variable, and again following that config file, I can say Keys underscore underscore, which is the replacement for the separation, and then BingKey. For the Variable I'll paste my actual key, though I won't make it visible to you here in the video. You'll have to go get your own Bing Key in order for this functionality to work. But once we've added it here, I have it on my development machine for use in development, and then I'm going to need to be able to communicate to whomever is going to deploy this, whether I'm deploying it to a cloud solution, and I have to set it up there, or I have to tell IT to deploy it to our live servers, much like I'm going to ask them to do the same thing with the database connection here, once I make that change. If you're using environment variables like I did, Visual Studio isn't going to recognize it as a new environment variable, until I restart Visual Studio. So I'm going to do that real quick. And now we're restarted. Should be able to use this and get that actual key, so let's go back to the CoordsService, and what we want to do here is actually get this from configuration, so I could certainly read configuration, or if you remember I had registered ConfigurationRoot as a singleton, so let me add that namespace which is Extensions dot Configuration, and then I'll just call it config, and I'll store it at the class level. Again what I'm doing here is I'm adding configuration as another dependency to this class, and then storing it at the class level so I can use it in other places like right here. config, Keys, BingKey. Now you may remember that I just did this as an environment variable and used the double underscore. Just because I used the double underscore, doesn't mean I still can't use the colon in the configuration object. And so at this point, we should get an URL that will actually return the data that will include the latitude and longitude, for whatever name of place I'm going to include. So the actual calling out to this URL, there's a lot of little pieces that need to be moved, but instead of making that hard, I actually decided to go ahead and put most of that into a file in Resources. Again Resources can be retrieved either from the source code that you downloaded if you have that kind of subscription, or here is an URL over to a github repository that has all of the resource files. So if we look at the Resources folder, there'll be a GetCoordsService. And this is a bit of C#, though not a complete C# file, just a bunch of boilerplate that we're going to need, and I'll walk through what it does. So back in the actual GeoCoordsService after the URL, go ahead and just copy and paste that in, and let's talk about what it does. It first creates a client using HttpClient, and you may need to add that namespace, and then calls GetStringAsync on that client using the URL we constructed to go ahead and get the results of this query for the name. Once it returns, that return value is some json that we're going to parse with link to json. This JObject is going to allow us to parse it, and then walk through it and interrogate it. Now the form of what structure it needs to look at, is a little fragile because as the Bing API changes, we may need to tweak these. But it's been pretty stable for awhile now, so it should be okay. It goes ahead and looks for the resources that we searched for, because you can search for more than one resource but we're going to look for the first. And if it failed to return, we're just going to set the message up to Could not find whatever that name is as a location. Otherwise it's going to test another property in it called confidence, and this is a qualification of how confident it is that the data it returned is for the location we've specified. If it's not high we're not going to trust it, because it may just be in the middle of a country, or in the middle of a state, and that's probably not good enough. So we return and change that message for saying that we couldn't get a confident match for that name, and allowing them to maybe change the name and try again. And then finally if we did get it, we're going to go ahead and get the coordinates. This coordinates is going to return something called the j token, that we can actually look into to get the latitude and longitude. Once we have these, we can go ahead and change the result to specify the Latitude as the first result in the coords, and here we'll cast it to a double. So it is a double, but we're going to cast it to a double, because the indexer here is un-typed, but we know it's going to be a double, and the same for Longitude. But unsurprisingly for the second element in it. And since we think we have a good latitude and longitude at this point, we can change the Success to true, and change the Message to Success, or whatever you want to say. Probably won't be used if it actually worked. And at the end of here, we'll just say return result. Earlier we'll get that failed result, and go ahead and return it. We're going to want to use this Service in our own code, and so let's come down here to Startup and just register it as a new object. And I'm going to add it as a Transient object, because it doesn't really have any of it's own state. So that when we ask for it later, we'll usually get our own copy of this Service, because that's probably good enough instead of keeping it around for longer. Next we want to use it, let's do that in the next video.

Using the Service

Now let's use the Service in our creation of new stops. So we've registered this GeoCoordsService as a type, so if we go back to the StopsController we should be able to add it as a new injectable parameter into our Controller, and I'll call it coordsService for now, and then I want to store it as a local member, just like we've seen. And then down in the Post when we want to look up the Geocodes, let's actually do this. Get Geocodes async, and we'll pass in the newStop dot Name, and of course this needs to be await. Luckily our Controller is already async, because we needed it for the change we're doing to entity framework, but that's good enough. And if result not Success, let's use the logger to log an error, Failed to get. And the error we log, we'll just go ahead and say result dot Message. So whatever we got back from the service, we'll go ahead and log as an issue. Otherwise, we'll go ahead and do the proper work. And what is that proper work? That work is taking our newStop dot Latitude, equals result dot Latitude, and newStop dot Longitude, result dot Longitude. So we're setting those, and then when we go to add the stop and eventually do the actual save of changes, it will include the latitude and longitude. Let's build this to make sure we've done it right. And then here in Postman, let's change this to a different city so we have something to look for, and let's make it Atlanta, GA. When we send this newStop now, we should see not only are we getting the 201 Created, with the city, order, and arrival as we specified, but we're now getting a good latitude and longitude because our Geo coordinates server is working for us, it's doing the work. It's using that magic key to get at that. So we've created a simple, and probably not complete API at this point. Let's wrap up this module so we can see what we've learned.

Summary

So to expand on what you've learned so far, you can go see my Web API Design course. You can see that here at Pluralsight, courses/web-api-design, and it will teach you more about how to set up and figure out what your API should be exposing to users, and this is true across all different sorts of APIs including ones from ASP.NET core. So what have we learned so far? We've seen the API and View Controllers are not two distinct worlds like they used to be, and we're using MVC 6 to build both, and using the commonality between them to our benefit. We've lost a little of the functionality in being able to use the name of the action to imply the different verb, but I think it's a pretty small loss when you compare it with the benefits of there only being one framework. I've also shown you how to map the URIs for the route, directly at the Controller level, and hopefully that's simplified some of your code. I've also explained that understanding status codes and how they relate to building APIs is crucial, and luckily ASP.NET core makes that fairly simply by its helper methods, that will allow you to specify Created, and Ok, and BadRequest, and all the rest that you might need. And finally we also talked about how REST verbs should be mapped to the different sorts of operations you're doing. Read should be done with GET, creation of new objects should be done with POST, etc. And that by doing that, and creating your API you're going to create one that's going to make more sense to the developers trying to use the API. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET core 1.0.

ASP.NET Identity

Introduction

In this module, we're going to cover the Authorize attribute and how to use it to secure controllers and actions. We'll talk about the different configuration options for Identity. We'll talk about using the Entity Framework to store our Identity information. And we'll talk about how to use Identity when you're writing your own APIs using ASP.NET core. Let's get started.

What Is ASP.NET 5 Identity?

So what exactly is ASP.NET Identity? This system called Identity is a replacement for ASP.NET Membership, that you may have used in prior versions of ASP.NET. This system has additional options for supporting types of authentication and authorization. You can still use cookie based authentication like ASP.NET membership, but you're also open to OAuth2 and other forms of authentication and authorization. It's also a pluggable model so that you have complete control over what your users look like and how they're stored. You can even store them in non-relational storage like MongoDB or other no sequel databases. You can even store them in LDAP or active directory stores. Let's add ASP.NET Identity to our project and see how it works.

Authorizing Actions

Let's see how authorizing actions works in MPC6. If we open up the controllers and find our web controller for the app, what we're going to want to do is take the functionality we have on that homepage, and let's go ahead and move it to a new page that we want to protect to only logged in users. So I'm going to create a new action here. Called Trips. This will be a page that authenticated users can go to look at their trips. And I'm going to copy what we're doing in the index page, because that really has the functionality we're looking for. And the index page will no longer have any data associated with it. Let's go down to the views for a moment. And I'm just going in to make a quick copy of that index, 'cause it already has some of the functionality we're looking for for our new trips view. And our index view, I'm just going to change, to simply be a welcome screen. So I'm going to delete everything inside of the row. And just create a new div here. With a class of 12 columns, so that we're taking up the entire page. And I'll just use some simple HTML to welcome them to the app. And finally, I'm going to create a button so that they can click over to their trips page whether they're logged in or not. And I'll use tag helpers to point at the new trips page. Controller rolls with the app controller, but the action will now be trips. Let's go ahead and give it a class of a button, button large, so it's nice and dramatic and I'll say, button success. So we have a nice green button. I like to use a green button to draw people's eyes and get them to click on it. So now when we launch this, it'll take us to just a welcome page that we can go ahead and click over, to see our trips on our new trip view. But of course trips, it's going to only be for authenticated users. So we're going to use a new attribute called authorize. And that is inside Microsoft ASP.NET authorization. When a request is made to the trips action, the system will see whether they've already authenticated with the system. And if not, it will attempt to send them to a place where they can go ahead and login before they're allowed into trips. This is essentially putting a gate in front of trips for only authenticated users. And that's essentially what we want here. If you're following along from the last module, you'll remember we turned off using the web browser, let's just turn it back on by going into properties, debug, and we'll say launch URL, and this will launch the root of the website for us. So let's run this so we can see what it looks like. Our new homepage will have this giant button that says "View My Trips" and when we click over to it, we'll get an error that says, The following authentication scheme was not accepted. That's because we haven't configured or included identity at all. All we've said is we want to assume that only people that have authenticated with our system can get at this page, but we haven't told it any way to actually do authentication. So it's throwing us an error. So before we can add identity and authentication to our system, we're going to have to have a way to save users into the database so that we have something to authenticate it against. Let's do that next.

Storing Identities in the Database

Next, let's store identities in the database and introduce ASP.NET Identity to our system. We've already used the authorize attribute to protect one of our actions. But if we want to be able to use Identity, we have to store them directly in the database. So let's go over to the models folder, and let's start with our world context class. Just to remind you from our earlier module on entity framework core, this is the class that represents the different types of data that we're storing in the database. Since we want to also store identity information in this system, we're going to change the base class here into an identity DV context. And Identity DV context takes a generic argument that represents the entity that it's going to store our user information. Things like user name and password and email and any other pieces of information we want to add on to that. I'm just going to call ours a world user for now. And if we look at the helper for Identity, you'll see that it wants to add Identity and a framework core to our project. Let's go ahead and use that to add it. Now we need an identity package and editing framework core part of that package installed, we still need to create this new world user class. I'm just going to go into models and use shift F2 to create the new file, world user dot CS. And this will derive from a class called Identity User. So I'm going to add the using for, and this identity user has a number of properties that every user in Identity is going to need, like user name and password and hashes and all those different pieces. But we can add different properties here that will also be stored in the database or in the data store. So I'm going to create a new property, I'll call it date time, and I'll say first trip. Just to have some data that we're storing along with this identity user. If we use F12 to navigate down to identity user, we can see that it's using a base class that has the user name type in it, let's walk down to it, and here we can see a lot of the properties that it has by default. Email, email confirmed, lockout information, password hash, phone number, etc. So this represents a user in our system, and we're just going to extend it with the information that we want to also store at the user base level. This is one of the differences between the older membership system and Identity. Identity is going to allow us to extend that user object or replace it completely. Now that we have both the identity user defined and the base class of our world context changed, we're going to want to be able to store this information in the database. And if you remember, that's where migrations came in. Let's open up our folder and we're going to go back to using dot net EF in order to make entity framework calls. And I'm going to look at migrations and I'm going to use the command list to show the current migrations. And it shows a single migration. This is a stamp that it uses for time. And this is what I called original migration initial database. And that initial database created the tables for the trips in the stops for us, but that's all. Now that we've derived it from Identity DB context, we have other objects that need to be stored in the database. So we can make a migration that will add the rest of that schema for us. This is the same thing you would do as you change your model over time. So it's going to be dot net EF like before in migrations, but this time I'm going to add a new migration, and I'll call it adding identity. And so now let's go ahead and use the EF migrations option again, but this time I'm going to add a new migration for the changes I've just made. And that will include the new world user class that I want to store in the database as well as some other identities that the Identity DB context exposes. These other classes are for getting information about OAuth implementations, and sites and different rules about the database. So I'm going to call this identity classes. And it's done and created the new migration. And now we can see the identity classes here in the migrations folder. In fact, if we look in it we can see that it's creating a table for ASP.NET roles, for user tokens, for users, for claims, et cetera. All the things that internally, Identity needs to put in some data store. Now that we've added the migrations, we're going to need to update the database with this new schema. And if you remember, we did that with dot net EF database and then update. And that will update it to the latest migrations in the project. So we go back to Visual Studio and look at the sequel server object explorer. And we look at our databases, we'll see the world DB like we saw earlier, but now has more tables in it, not just the stops and the trips that we saw before. Now all these ASP.NET tables that relate to the different entities that Identity needs. And the users table is specifically that table of user objects, and we can see if we look at the columns, that there is now a column for first trip. Because the rest of these were built using the identity user class, and then we extended it by adding this first trip as a data type. So that will also be stored in the database. Now that we have the database updated, we're going to need some sample data. We can do that with the world context C data. We're still using this world context to store our normal data, but we also want a new object called the user manager. Let me go ahead and bring in that identity class. I'll have dependency injection injected into my constructor, and then go ahead and just add it here. And this user manager is going to allow me to add and remove and change users, we'll actually use this in a number of places. Before us, we're going to use it because we're going to create a sample user at the same time. So if we come down to ensure C data, here we're testing to see if any of the trips were created, and then creating the trips, right before it, let's go head and test to see whether the user exists. We can do this by using the user manager, find by email, and we're going to find by our test user name, which I'm going to call Sam dot Hastings at the world dot com equals null. Now this is a waitable, because it's in a synchronous call, so we're just use a wait there to test for it. If it does equal null, that means this user doesn't exist yet, so we have to go ahead and create them. So here we can say new world user, again it's just an entity, so we can just go ahead and cruft it up. And we'll set the user name to Sam Hastings, just one word, and then email, sam.hastings@theworld.com, then we can use the user manager to create the new user. And this is a waitable as well, there's a second parameter we need to add in the password. I'll just put in a fake password there. Note that this password is going to based on some configuration settings we'll add soon. And so the complexity of this, unless you change it to be more simple, has to have certain characteristics. It has to have a certain length, has to have a certain complexity in that it might need symbols, upper case and lower case characters and such, so if you try to run this code on your own and you use a simpler password and it fails, that is probably why. So at this point we're creating that sample user, which is great, but we also want to go ahead and change the user names that we had specified here and use the new user. So they own these individual trips. So that later we can go ahead and query these for the login user and be able to get it done. This is going to be our linkage between the world user and our actual trips. So if we build this and it compiles, we'll be ready to go ahead and configure Identity for our website. Let's do that next.

Configuring Identity

So now that we have the identities being stored in the data space in entity framework, let's go ahead and configure Identity to work with our app. We're going to start up here in the configure services. Because we're going to want to add services.AddIdentity. And Identity's going to take two different parameters. First it's going to take the type of user object, and that's our world user that we created earlier. And you can also make your own role object or in our case, we're going to use the default identity role object as it's going to be stored in the database. We didn't override that experience for what a role looks like. So we can just use the one that's built in. And this allows us to pass in a configuration action. So this will take a lambda function. And I'm just calling it config, for us to change the properties. And so for us, there may be different rules we want for how this stuff should work. For example, User.RequireUniqueEmail, we want to say yes. So that each user is going to be guaranteed to have a unique email. And we may also say, Password.RequiredLength =, let's say, 8. And so this how you configure the different options of the configuration. Making passwords weaker or stronger, having different requirements. This is where you would actually do that. The object that's returning from Identity we can also use to add where we're storing it, so add entity framework store. And here we're going to be including the name of the context object. In this case, the world context, 'cause that's where the identities entities are going to be stored. So this is a way to configure that. Once we've got this added to our configure services, then down in configure we can tell our app to use Identity. And that's where we turn on Identity in our system. But the important idea here is that the order matters. This order matters because this is the order that things are going to be handled in. We're basically putting in middleware that says, first, see if it's a static file, second, see if we need to handle identity, third, use NVC like we're doing down here. So typically user NVC is going to be one of the last items you're going to include, so I'm going to make sure Identity is before it. The last thing we'll want to do is actually configure how we're going to be using cookie authentication, which is the kind we define here. We can go ahead and add some configuration for our cookie authentication, by looking at the config object and looking at the cookies object. This is the options for identity cookies, and then it has different kinds of cookies that are supported. We're using an application cookie, just a cookie that we're going to supply. If you had an external cookie or a two factor cookie, you could look at the options for them as well, but we'll look at the application cookie. And we're looking for a property called login path. This is where we're going to define what the redirect will send people to, when they're not authenticated and we've asked them to be authenticated with the authorize attribute. And for us, that is that auth login. The auth controller and the login action on that controller. And this will allow us when we go ahead and build our project, and execute and go to that page that doesn't allow us anonymous access to forward to this correct path. Let's run this to see whether we can get our application running any better. And so now if we go to View My Trips, it's going to fail. This is actually is returning a failure, we can't see it, but it does have to be 400. But where did it send us? It sent us to auth login, with a return URL of our app's trips. And that's the experience that Identity is going to do for you as you try to attempt to go to a page that has the authorize attribute attached to it, it will attempt to log you in, authorize you by sending you to the auth login page that we specified, including a return path back to the original page. So that once we implement the login page, once you login, you'll be able to return to that page and see the actual authenticated information. To make this work, let's go ahead and implement a login page. Let's do that next.

Designing the Login View

Let's go ahead and design the login view so we can create the form that the users will use to login. Let's start by creating a new class in the controllers. And I'm just going to call that auth controller. And now it changes base class to controller, so that we know it's an NVC controller, and we're going to need a login action. In our case, if someone tries to go to the login page and they're already authenticated, we don't want them to bother trying to re login, since that will be a fool's errand, so we can actually check this by saying User.Identity.IsAuthenticated. So if the user's already authenticated, we can just return a redirect to action, and this is where we're going to specify the action name. We can actually specify the action name and the controller. Again, much like we were doing with the tag helpers. We're going to do the same thing. And that action this time is going to be trips, and the controller name is going to be app. So if the user has already authenticated and happen to try to go into the login page, we're just going to take him to the trips page so they can see what trips they have. So it's probably where they wanted to go anyway. If not, we'll go ahead and take them to a new view that we will use to allow them to give us their authentication information. So down on the views, let's create a new folder. We're creating a new folder because of course this is a separately named controller, and for it to find the view it needs to match the name of the controller here auth, auth. And then we can create a new NVC view page. And I'll call this the same that I would call the action, login. Change this to login. I'm going to start by creating a model and that model is going to be a class we're going to create in a moment. And that will be in TheWorld.ViewModels.LoginViewModel. So it'd be a class that we generate in a minute. But we will get there. And we'll start with those scripts that we used for validation on the context page. In fact, let's just go to that contact and borrow those. We're doing this because we're going to want to support validation on the login page, just like any other page. And let's build this page with bootstrap in mind. So we'll start with a row. And we'll start with a div, of column six, so it'll be in the center of the page, and column offset three, to actually center it. I'll just put in a little label for login, and then we'll start it with a form. And our form method is going to be a post. We're going to take this data and post it back to ourselves so we can actually do the login. And just like we did before we'll use the bootstrap classes for form group, label, and we'll say ASP four. And this will be the name on our model which we'll make user name, and then we'll do the same thing for input. But we'll add the class from bootstrap for form control. Let's copy this, to do the password. But we're going to need to specify the type because password is just going to be a string and it's not going to know what type to do, and the password of course will give us hiding of the password as it's being typed, which is what we'll want. Now we need to add the actual validation, not just the controls. So we're going to start with a new div, and ASP validation summary. And we'll use the validation summary model only, like we did before to specify that no property level validation should be shown here, only object level validation. And we're doing that because we're going to use spans for the ASP validation four in order to show our validations for those different properties of the models. We'll do the same things for password here. And up on the form, last thing to do is no validate, this makes the browser not validate and allow our code to force that validation. So you should have a login page that actually shows up now. But we need the login view model to exist. So let's create that. On our view models we'll create a new class. So go ahead and add these two properties. Neither of which should surprise you. First one meaning user name, and the other one being password. And we'll want both of these to be required, bring in those data annotations. Then we go further than this, but for login, this is probably sufficient. Let's go ahead and run this. So we now have our login form, and as we try to login in without putting our data in, we're getting those errors until we put in Sam Hastings, and try to log in. Now we're not actually logging in yet, just like we did before, it's automatically trying to take us to that same page. We need to implement that post. So we're actually going to implement two different operations, one for logging in with a post method, and also a get for logging out. Let's do that next.

Implement Login and Logout

Now let's implement the login and logout in our new auth controller. So now we're going to need a constructor because we need to be able to inject into our controller a class called a signed in manager. The sign in manager is in the identity names base, and takes a generic parameter and this is the type of user object that it does the sign in managing for. So bring in their models, and like we've done before, go ahead and create a local field to store it, so we can now implement the login action. To create the login action here, and the login action is going to take in our login view model. Which is in our view models folder. And we're also going to support, post. Because like we specified in the form in the last video, we're going to post all the data to this action in the form of the view model. So if it's in the form of a view model, we can go ahead and check if model's state is valid. And if it's not valid, we're just going to return view, to go back to our same login view to try again, including any model state problems. Otherwise we're going to end up short cutting out of this is, if model state is valid. With a redirection. So we're going to need to get the sign in result by using our sign in manager. The sign in manager is going to allow us to password sign in or sign in with a password, by passing in RVM dot user name, do this in separate lines so we can read it a little better, RVM dot password, whether if for insistent, and we're going to say true by default, and then false for whether to lock out the user if the sign in fails. This is going to attempt to do the password sign in, of course this being an async call, notice the async at the end, we're going to use a wait, and change this to an async controller. We're going to wrap our action result with a task, so that await actually does what we want it to do, and then we can check if sign in result. Succeeded, let's go ahead and actually redirect them to the result page. Else, we're going to say model state dot add model error, and I'm going to give a key of blank because I want it to be on the object, it's not one of the fields is wrong, but the whole objects is wrong. User name or password incorrect. We're adding this model state so that when it drops down here into the view, they'll get shown to the user and the user will attempt that again. If login's succeeded, then we can just return, which is just going to shortcut us out of here. Redirect to action, trips app. Now this works to redirect us to an exact page we want on login. But if we remember, when we redirect, we actually have this query string parameter that is passed to us with the login redirection. So we can implement that by actually saying here, string, return URL as a separate parameter. And that way we can simply change this to if return URL string is null into your white space, then we'll redirect where we want to, else, we will return redirect, and then we'll just give them that URL over the return URL. That way later on, if we were going to support the authorize attribute on different actions, we would always take us to where they attempted to go. Could match it with something like an account page, or a change profile page, or those sorts of things would have the same limitations. So we want to support the right thing in both cases. Let's see this working. We go to View My Page, I'll now put in the password. That will now take us to the app trips just like we expected. We have a problem, though. We just passed credentials using http. Which means that anyone we sent it to across the wire could've stole those credentials. For development, that's fine, right? But you don't want to accidentally deploy your application like that. So if we go up to configure services, we'll see our add NVC. And our add NVC has support for configuring yourself. So let's add a lambda expression there. Let's line those up real quick to make me happy, and in the config we can say filters dot add new require https attribute. And that's in the NVC name space. So what this will do is it will add a filter so that if we attempt to go to an http, it's going to try to redirect you to https. This will work for the entire site which is probably what you want to do in production. So when we try to go to the page, you'll notice it immediately redirected us over to the secure version of our website. And of course, there is nothing listening to us on that port. So you can't have the required attribute during development because it just makes it too hard to debug. So we want to limit this to just being used in production. We could of course do an if debug here, but that doesn't really solve the problem. That would solve the problem if we only had a couple different timings of machines, development machines and production machines, but we often might have some others. So we go up to the constructor. You might remember that we stored the I hosting environment here, that means we can just simply surround this with if hosting environment is production, then we want to force this new filter to be added. And in this way, we're only going to use https when we finally get to production. Be aware if you're testing in different environments where you haven't set the type of machine, production is going to be the default. So make sure you go ahead and use the ASP.NET core underscore environment to set the kind of machine for your staging and your test machines and other machines like that. And this way, at least this can be added when we finally get to production. By requiring the https, we're really telling it that when we're sending credentials across the wire, that we want to protect them with a certificate. And in pretty much any website that accept any sort of credentials, you're going to want to require https. Now that we're allowing ourselves to be logged in, let's go over to the layout page and use that information. And over in the side bar, we have this image and name, let's first test and only show this if we're logged in. So if user, identity is authenticated, then we'll show these two lines. If not, we won't begin unauthenticated with this information at all. For our user name, we can go ahead and use that user option again, identity, name. And this is just the user name of that user. If we wanted to get down at the actual database information, we could go a little further, but I'm not going to bother with that for now. The other thing we'll want to do is add a couple new list items here into our left menu. One will be for trips, and one will be for logout. Right? So logout, controller will be auth instead of trips and then let's just protect it in the same way. Only show these once someone has logged in. Now that we have our new menu items, protected by is authenticated, let's go ahead and see what this is going to look like in the browser. Now this is showing my trips in logout already, because we're already logged in. Because I told it to make that login persistent, it's going to remember it for a while. So let's go ahead and implement logout as a starting point. Back in the auth controller, we'll just need another action here. And because I know we're going to do logout, we're going to need async as part of the method signature. Like we've done before, wrap the action result and a task and we'll just call it logout. And all we'll do here is say if user identity is authenticated, or only going to attempt to try to log out if someone's already logged in. If they happen to come to this action, and they're not authenticated, we'll just return redirect to action, and take them back to the homepage. In fact, we'll take them back to the homepage in either case, but in our case for logout, we can then use sign in manager, sign out async. Unless does this force and get rid of the cookie collection. So that the users then signed out. If we refresh the page again, our logout will now take us to the sign out facility and then immediately bring us back to this homepage. And now that we're not logged in, all we get our home, about, and contact, we don't get those sections. But if we try to go to My Trips, login with our credentials, we'll now get, notice the user name directly here in the header. So we can have that difference between the two. So at this point we have identity protecting our individual webpages. We've created an EPI if we were going to do more rich client development or single page application development with angular, in our upcoming modules, so we need to protect them as well. Let's do that next.

Use Identity in the API

So we've been talking about Identity, but we haven't talked about Identity in the case of APIs yet. So there often comes a question about, can you use the same authentication you're using to login to your website for your API? And you certainly can do this and it's pretty common to do, but it's not the most secure solution. Using cookie auth for your API is most notably used when you're only using your API from your website. So you're pairing them up and hanging on and piggybacking on to the cookie authentication for your API. But as you build an API that's going to be used by other sorts of apps including mobile apps or third party apps, it falls apart pretty quickly. You're going to want to use Open Auth2 or Open ID Connect for these third parties because they are safer in support non-JavaScript clients in cases that the cookie authentication just doesn't work. You don't want JavaScript clients or mobile apps storing those cookies and hoping they don't time out and things like that. The other problem is that cookies are subject to cross site request forgery, so the more places those cookies are passed through to, the bigger problem you're going to have with security. And so it comes down to what level of risk are you willing to take on, what are your exact security requirements? The reality is that your local bank and your local pizza shop have very different requirements when it comes to the level of risk for being broken in or having hackers login as other people. And so you're going to want to take that into consideration, when you secure your API. I'm going to show you piggybacking onto cookie authentication. But if you need more, you need to integrate with OAuth2, OIDC or other technologies. You're going to have to go to one of our courses or the documentation that will teach you how to do things in a safer and more direct way. So let's add Identity into the API. Let's open up one of our API controllers. And I'll do it with our trips controller. And at the controller level, let me just go ahead and put that authorize attribute just like we did on the other controllers. So if we, we're on our website now that we have authorized, let me go ahead and get the trips using the API. So if we change this call to call our API, now that we've secured it, we'll notice that return to 200, but returns an html page. In fact we can see here that it's the login page. And that's because it's treating the API identically to the way it's treating views. And we just can't have that. So if we go back to the configuration, you remember where we set the login path, we can also change another piece of configuration. We can look at the config, cookies, and since that's the kind of configuration we're doing, and then the application cookie we can create something called the events property. And the event here is a set of callbacks that we can handle while the authentication is happening. And it's going to be a class called cookie authentication events, and let's bring in that name space. Authentication cookies, so one of the properties in the authentication events that we want to override is on redirect to login. The cookie authentication event is a set of events that you can take over responsibility for in the way that cookie authentication works. So we want to change the way that the redirect on login works so that when we have an API, it's going to return to us a status code instead of that redirection we saw. So we're going to assign this an asynchronous lambda. The style that it expects is asynchronous. So let's start by just doing a wait task dot yield, this is effectively saying go ahead and let the task complete. None of the operation do we want to do in here are actually asynchronous, so we're doing that to allow the lambda to actually be asynchronous. Let's put in some pseudo code here for a minute. If this isn't API, what do we want to do? It's an API, we really just want to take that http context response object. It set the status code to 401. We effectively just want to return this status code for API calls. Otherwise, we're going to want to do the response dot redirect to the context dot redirect URI. This is because by supplying on redirect to login, we're going to take responsibility for doing the redirection when necessary. And so we have to do the redirection here because we're taking over that responsibility. But how do we know it's an API call? So to test for it actually being an API, let's go ahead and look at the context request first. And request has a path, and I want to ask it whether it starts with a segment of API. So does the URI start with slash API? As the beginning of the path? And the start with segments actually has separated up into parts of the path and so it's looking for slash API, essentially, slash. This way you don't get a false match. And then we also want to check for the response status code is equal to 200. And the reason that's important is if it's returning some other sort of code, it's already returning a 302 for redirection, or it's doing a 500 because of an error, we don't want to change that status code to something else. But only when the status code is everything's okay and I'm trying to redirect on login, do I want you to treat it as a 401 return directly to the API. Let's see this work. So in Postman, let's go ahead and try this. And we'll see we're now getting unauthorized because we're not actually logged in. Let's see it work. Inside of Postman there's the ability to turn on the interceptor. And what this will do is it will make this call through Chrome, including any Chrome cookies there to there. So let's open Chrome. And let's go ahead and go to our homepage. There's the homepage. Let's go ahead and login. So we now have a cookie embedded in the browser. That we're logged in. So in Postman, because we have this interceptor turned on, when we send it through to the same call, the browser will have that authentication cookie and this should now work. We're now getting the results because we have first logged in interactively with the website. Now that we have the ability to login through the APIs, let's go ahead and use Identity in our APIs themselves.

Use Identity in Trips Controller

Now that we're using authorization in the API, let's go ahead and implement the TripsController using our identity information. So back here in the TripsController where we had just added that Authorize attribute, we want to be able to make the assumption that any call in the entire controller is authorized, so we can now take as faith that the user is a logged in user whenever the GET or the POST or whatever other methods in this controller are being called. The problem is when we call this GET method, we're getting all the trips, not the trips for the individual user. So let's change this. Let's change this to a GetTripsByUsername. And we're going to go ahead and pass in the username, and we can get that inside the controller by asking for the, this.User is the object that represents the claims for the user, but also includes an identity object, and the identity object has a name, and that'll be the username for our user from the identity system, which we can use to query the trips for that user. I'm going to generate the interface for GetTripsByUsername, and let me navigate over that there so we can just refactor this to do what we want. We're going to have it return just like GetAllTrips, IEnumerable Trip. And to clean this up a little I'm going to go ahead and put this up near GetAllTrips so that our interface is a little cleaner. Now we can look at the repository and implement that call. If you remember we go to the interface, Ctrl+., and tell it to implement the interface, which is going to add that call for us, GetTripsByUsername. And what we want to do here is essentially the same thing that we're doing for GetAllTrips, but we want to make it a little bit more elaborate. So instead of returning just all the trips, we want to add a Where clause, so in a trip when UserName equals the name we're being passed in as the username, go ahead and get those trips. In this case we're not using the include to get the stops because we just want the names that are being passed back, we're not getting the entire object. We could certainly come in here, and let's break this up into a separate line so we can read it a little better, we could go ahead and say include as well to go ahead and return for a username the trips and all the stops, which is something we'll probably want to do in our examples. Now if we build this, we can view this directly in Postman. We have that localhost api/trips, we're still logged in via Chrome, so when we send it, now we're only going to get the trips that are actually related to our logged in user Sam. Let's repeat this so we can show how POST can actually assign the current user. So we go back to the TripsController and look at our POST method, we're mapping the trip from the view model, and then we're adding that trip to the repository because this is a POST. But the piece that we want to do between the mapping of the new trip and saving it to the repository, we actually want to set newTrip.UserName equal to that User.Identity.Name. Again, because we can make the assumption that if it's gotten into this method because of the authorize attribute, that this method is authenticated, we can go ahead and just use the username here, so that as we add a new trip to the database, it will include that username. Let's build this. And then over in Postman let's go ahead and change this to a POST, let's set up the body as a raw JSON object, and if we remember, we need the name, My Fun Summer Vacation, for lack of a better name, and let's go ahead and run this. I've set the body and the data type here, and so what we should get by posting is a 201 Created, and here's my new brand new trip that I can start adding objects to immediately. Next let's repeat this and implement the StopsController in the same way.

Use Identity in the Stops Controller

Now that the TripsController is implemented using the identity and authorization, let's do the same with the StopsController. Back here in Visual Studio, I'm going to open up that StopsController, and first we want to do the same thing we did with the TripsController, and that is add the Authorize attribute. This Authorize attribute tells it that in every case when we call this controller we're expecting someone to be logged in or to have authentication information. Then again, in this way we can guarantee that every method, when it's called here, has a valid user of someone who's actually logged in. So if we come down here to the Get for the stops, you will remember we're getting that tripName here from the Route, so the tripName is being included in the stops. But now we need to change this. Instead of GetTripByName, let's change this to GetUserTripByName. We're going to add a new method to the repository instead of just changing the old one because there may be other reasons to get individual trips in an unauthorized fashion. And I'll go ahead and say User.Identity, you'll get used to typing this a lot, Identity.Name as a second parameter. Let's go ahead and use refactoring to add that to the repository, and then I'm going to navigate over to the interface. Much like before, we're going to need to change the return value, and I'm going to add it right here next to the GetTripByName so it has the same return value. And then back in the repository, like we've done before, we're going to tell it to implement the interface, and then we can go ahead and find our new GetTripByName, GetUserTripByName, that has the username, as well as the trip name. And much like getting the trip by name, we're going to actually borrow that code, or, as you probably know, I like to call it editor inheritance instead of copy/paste as I'm going to change the Where to say the t.Name has to equal the tripName and the UserName has to equal the username. This way someone can't ask for a tripName that doesn't belong to them accidentally. Remember, the user is not sending down their username. We're getting that from the authentication subsystem. We're still going to return the same pieces of data, and then if we go back to the StopsController, everything else is the same. We're going to take the trip, we're going to map the stops, and then return them. Same as before where we introduced identity here, we're going to use that identity name to filter out only trips with that name that belong to that user. And importantly, because we're using first, we're default in the repository, we're actually only getting the first trip by that name. And so in the big picture we probably at some point need a business rule to make sure that we don't have duplicate names, but that's another story for another time. Let's build this and then go over to Postman, and let's change this to, let's say, US Trip. And now that we call it, we're getting all the stops for that particular trip, for our US Trip. Now this doesn't look much different from what we were doing before, but now that it's authorized, we're guaranteeing that a logged in user is not only going to get a trip called US Trip, but it's going to get their US Trip and not accidentally be able to look at the data from someone else's trip. Let's repeat that for the AddStop. So when we post a newStop, if you'll remember how this code works, we're sending in a tripName and then a ViewModel. And when we actually save the newStop, we're going to want to include a third piece of information here. Much like when we queried the trip and includes the username to make sure it was the right trip, we need to do the same thing when we add this stop. Now inside this method, we don't need to do anything with that username because the username is attached to the trip and not the stop. So we don't need to assign it or anything, but we do need to change our AddStop method to be able to take this username. So let's navigate over to the AddStop on the interface by hitting F12, and let's force this to take a username as another parameter. And if you haven't done it yet, you might want to change the interface here to be username as well just so it's clear what we're actually sending in. So let's go to the repository and look for AddStop, and we're going to need to make the same change here. And here we're using the GetTripByName to get the trip. We're just using a method already on the repository. So we can actually say GetUserTripByName and just pass in that username because we already have the method for getting the trip for the specific user, and then everything just follows on naturally. We have the trip, being guaranteed that the trip belongs to that user, and then we're adding the stop to it. Let's build this and go back to Postman. We'll go back to specifying a Body. So the name of our stop here is going to be a city name that we're going to actually try to look up in the API, so let's go ahead and put Lebanon, Pennsylvania. And let's go ahead and add an arrival and just give it a simple date. Let's go ahead and send that. When we send that, remember we're sending it in the context of the logged in user, so it knows it's getting the US Trip here that belongs to me. Now if we come down here, we'll actually see arrival is set correctly, looked up the latitude and longitude correctly, and obviously has the correct name. So we know now that the stop method on our controller is also working. So now that we have all the API implemented along with the authentication, we should be ready to start building the Angular code. So let's wrap up this module.

Summary

So what have we learned in this module? I showed you how Identity in order to store its entities needs to use entity framework and you can create a new DB context for Identity or you can use an existing one and extend it to store the Identity entities if you'd like. I've shown you how authorize can be used in both view controllers as well as API controllers to control who can have access to control who has to be authenticated to have access to different parts of your project. I've shown you how configuration can allow you to change some of the properties of your project, such as password strength, the path for login, and even handle specific events that are related to Identity, like we did with on redirect to login. Lastly I showed you how Identity could be used to inject specific information across the app, whether that was in views, stored it in the database in the API, or even just check for authentication to change the way the UI looked based on whether someone's logged in or not. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET Core 1.0.

AngularJS

Introduction

In this next module we'll talk about AngularJS. We're going to start by adding AngularJS to our project. I'll show you how to build modules for Angular. We'll see basic data binding, then I'll show you views and controllers, as well as creating your own directives. AngularJS is a popular application framework written in JavaScript and completely open source. It was built by Google for a number of its own projects, so it's actually been dog fooded inside of Google for many large projects. Other than Google it's been adopted by lots of other companies to build their own forms over data sort of applications. That's really where AngularJS does its best work. AngularJS exposes everything as a set of services that you can use throughout your project and is for a client-side JavaScript experience. The idea behind AngularJS is to build a rich client-side applications. Sometimes these are called single page applications but I think that misnomer can get very confusing. Single page applications assume you're going to be building a single HTML page that's going to encompass all the functionality of your website. Whereas I think of Angular and other frameworks like it are better suited to build islands of functionality across your website. Currently we're going to be working with the 1.5 version for the examples that we're going to see and this one 1.X version has been around for a few years now and has a lot of proponents. But Google is introducing a lot of architectural changes for AngularJS 2 which is in its release candidate as of the recording of this course. We decided to use Angular 1 for this course because it was simply more stable right now. Angular 2 is probably the future but learning the techniques and the concepts of Angular here in this course will help you understand when you're ready to move to Angular 2. Let's see how we can add Angular to our own project.

Hello AngularJS

We're going to start off the demo by adding Angular to a particular page in our application. Before we can add Angular to our project we're going to open up the bower dot json and use it to add the current version of Angular 1 that is out there. And it'll be under bower under the name Angular. The current version is 157. So we close that, we can now use it in our project. Once we add it here in bower it's going to show up in our lip folder. There's Angular. So let's go ahead and open up the trips views, cause that's where we're going to do most of this work. We're going to limit our use of Angular to an individual page or at least for the purposes of the course we're only going to add it to one page. You could add to other pages where you need it, we could rewrite the contact page to use it, et cetera. But for us we're going to implement the core of our application that's going to allow us to add trips and add stops and display a map for those stops using Angular. Since I'm not going to include Angular in every page in my entire website I want to include it here on the trips page only. I could put it in the layout view as well but that would put it on every single page and that's unnecessary. So I'm going to use our friend, the section scripts that we've used on other pages to add scripts we need and just go ahead and find that source for Angular. There's our Angular min, so we have it now on the page. Now Angular works by defining something called an app. The app tells the Angular framework to start paying attention to this section of our page. Now this section of our page could be the entire page or could be a small set of elements and it does this by using an attribute, the NG app attribute, to say this is where you should start paying attention to this part of the page. Monitoring it for changes, taking a look at attributes. So essentially for searches for these NG app attributes to start running its own code. That's the way it gets bootstrapped in. So for us we want to go ahead and add that here on the div that contains all the functionality of our page. Now there's two ways to specify it. Normally you'll see as NG app and in fact Visual Studios Editor is pretty good about including the Angular attributes in intellisense, but there's two schools of thought about these attributes. The HTML5 spec says that if you want your own attributes you need to preface them with data dash. And to be technically correct we should probably start all these with data dash and in fact Visual Studios supports both formats with the data dash or without the data dash. Because most browsers are just going to ignore attributes it doesn't know about I don't mind using the shortened version that you see as much more common these days. Now we've included the script and we included the attribute so that the Angular code will start monitoring this part of our application. Let's go ahead and run it so we can see if anything is changed. Let's go over to the trips page and we have our application but nothing really has changed. It still has the same intentionality it had before. The big difference if we look at the developer tools is that our div now has something called an NG scope as a class added to it. Angular started to look at this application as something it calls a scope that we'll talk a little bit more as we get further into the discussion. But it has actually taken this element that we added the app too and started to look for different parts of Angular to be used. So let's go back and actually do something inside this container, I'm going to add a new div up here. I'm going to use double curly braces, this is the syntax in Angular that says I want to represent something that is gong be bound or computed. This is essentially similar to the at section in a razor file. It's a small piece of tech that tells Angular, hey take what is inside of here and actually compute it for me. So if we start with a string, we could just say something like 2+2= and add to 2+2. But the code we're writing in here is interesting, let me show you that it works first. There's a 2+2=4, which of course it computed that for. This is just JavaScript, all it's doing is it's taking this snippet of JavaScript and evaluating it for us and then plunking it into that div. That is at the core of what we're trying to do, we're trying to add to the mark up here some amount of description to what we want to display. Now very rarely would we do anything like just put JavaScript code here on the page, that's actually probably worst practice, that is the opposite of the best practice when we're writing these sorts of applications. But what we want is that they'll be enough information here in the mark up to describe what the page is supposed to be doing and then we're going to have our own JavaScript that actually runs most of this. And it does this by using a model of view controller mechanic but all on the client side because the important thing to understand here is everything we do with Angular is running in the browser. So it's code that once the page has been loaded is going to execute. Let's build our first controller so you can start to get a sense of how these things are constructed.

Your First Controller

So let's build your first module and your first controller. In order to build those pieces we're going to need our own piece of JavaScript here. So let's come up here to the wwwroot and let's go ahead and add a new JavaScript file here. I'm going to use control F2 just to create these files pretty quickly since we don't really need a template. Now I'm going to call this app-trips.js just conventionally to say it's the trip view of the app controller. And like we saw in our JavaScript module I'm just going to be using an immediately invoking function expression to take all of the code we're writing out of the global scope. It's not necessary to be in the global scope. And I'm going to call angular.module and this Angular dot module is where we're going to define a packet of code for Angular and I'm going to call this app-trips just to follow our convention. And then an empty array, the reason for this empty array is this how dependencies are managed. And as we start we're not going to have any dependencies. We'll revisit this page a little later. This is going to create a module for us that we can then specify in the trips where to get this code. So first let's add to our scripts here our new JavaScript file and then in the NG app we can tell if the name of the module that is responsible for this page. The idea here is for me quite interesting 'cause you could imagine packaging up all the JavaScript for a large application. You may have a handful of these modules, or even in some cases hundreds of the modules and different pages may rely on different modules as their starting point. This essentially bootstrapping our trips page here with a new module called app trips. It's all this is doing. Now that we have our module set up so it knows what code we want to be responsible for it, let's go ahead and create a controller. Again I'm going to create another JavaScript file and I'll just call this the trips controller and the same thing we did in the first one to separate it from the global scope. We can go ahead and use strict which of course I forgot to do over here. Let's go ahead and do that to be good citizens and now we want to create a new controller. We're going to do this by calling Angular dot module again with that same app trips name. And this is going to return us an object on which we can add our controller. So we call controller here and give it the name of the controller, which I'll call it trips controller and then let's name a new function. And I'm going to name it the same cause conventionally that's often what's done and that I can create a new function is the actual trips controller. So we're essentially saying create a controller, this is what its name should be and use this function as what the body of the controller really is. This is where the code exists for the controller. So let's talk about a couple of things. First here in the trip controller I referred to this Angular module but I did in a different way then when I defined it. The only difference between defining the module and getting a reference to an existing module is that second perimeter. The second perimeter tells Angular hey this is where I'm creating the module and then here I'm getting the existing module. So that bit of convention is important for you to remember as you're building these things so you can understand what the difference between these two patterns actually are. Now we could have built this all on one giant file but this allows us to have the separation so that our code is a little cleaner and easier to manage then having one giant file that has every controller, every service, every directive in one file. It allows us to have that modularity that we want. Now that we have the controller we want to first expose some data from the controller. So ordinarily I would just use the this pointer and this represents the object that is returned from the trips controller. Essentially a controller is going to call new trips controller, which is going to return something like a class, it's really a prototypical class. But because of the nature of JavaScript I'm actually going to call this the view model and just refer to it as this. This way I can call the VM, it's a little more descriptive then just saying this in every case. And let's add a property to the view model and just put my name in it, because I'm a little self-indulgent and that's all we'll do at this point. Let's just start with a very simple version of our controller. Just expose us to some data. Back here in the mark up let's first add our controller to the set of scripts we're going to be loading and let's take our div here and actually use instead of this root force binding let's use a controller. And the NG controller attribute is where we can specify the name of the controller. You're essentially saying here's a piece of code inside of our app that is responsible for this subsection of our page. And when we define the controller here we're going to use a syntax called the AS syntax to say AS VM. And this is essentially creating a variable that we're naming VM that we can use for data binding. So I can bind to get the data out of the controller that we specified. I'm going to go ahead and give it a class just like I would any other element. Just to center this on the page for now. If we go look at this in the browser now we can see my name now showing up, it's essentially taken that data that we've exposed in the controller and bound it here on the page. Now that we have a controller let's explore some of the basic ideas around data binding. Let's do that next.

Basic Data Binding

Now let's delve into some basic data binding. Back in our controller let's change our element here and call it trips and I'm just going to start with an array. And I'm going to construct a couple of objects in this array, let's call this name US trip, you'll notice that what I'm doing here is I'm mimicking the data we have on the server as well. So what we're exposing from the controller from really the view model is a collection of trips. How does it change what we do in the mark up? Instead of showing just the name and the VM with curly braces let's do something more interesting. I'm going to create a table and I know tables are bad but in fact we're actually going to show tabular data so tables are fine. And I'm going to use bootstraps table classes to make a good looking table. I'm going to call it table responsive which is one that we'll deal with different page widths well and then table striped so, you guessed it, so that the rows are striped. So let's create a table row and in the table row I'm going to use another of the Angular attributes or as they call them directives called repeat. This directive is going to allow us to walk through a collection and build up the mark up. So I'm going to say trip in VM trips, this is just like a foreach statement. We're going to create a variable called trip for each one that is in trips and then create a new row for each one of those and then in our one column say trip dot name and then the second column trip dot created. So let's see this in the browser. We're now seeing that two different rows in our table. We can see the data binding is working the way we would expect it too, except that our date format isn't very friendly. Let's solve that. The data binding syntax here allows for something called filters and filters are basically formatters or small pieces of code that know how to display information. And filters are defined by using a pipe and the name of a filter, which in our case will be the date filter because of course we want to show a date. When we use the date filter it's going to pick a default date format and use that to filter the data that's in date over to our new format of today. Optionally we can tell it the format we want to show by including a colon and then a string that's going to contain the information about how to format this. So we can say things like short date for pre-built format or even specifying our like month month, day day, year year year. And these are similar to dot net date formats but not exactly the same. So filters are going to allow us to make those decisions about how we're going to format certain things. And there's some built in filters and filters are just a JavaScript construct that you can create your own as well. Let's create another part of our table here and we'll just create a fake button and I'll just use button, button small and button primary. Specify the look of these guys and then I'll just put the word manage in there. Now this isn't doing any data binding right, all it's doing is really just including a button for us. And when we refresh this we're starting to get that look and feel that we're actually going to be able to use to show are different trips. So you can see doing things like list binding and filters and just object binding we can get quite a lot accomplished by having our controllers expose data that we can then use to define what's actually shown up in our HTML dom. Let's take this further with using Angular with forms, where it starts to really get powerful, we'll do that next.

Handling Forms

So let's see how we can use Angular to handle forms as well. Inside the section that the controller is managing let's create form as well and let's specify there's no validate and let's give it a name, new trip form. We have a nice descriptive name and then we can go ahead and build up a very simple form to use a div with class form group like we've done before. A label and an input right. Now do another div for our submit button. In the label its self we're going to want to say trip name and then the input we're going to want to specify form control like we've done before. Specify it's type as text just to be sure what we're storing and then we're going to set up an ID and name for it and for us this going to be the name ID, name equals name. It gets a little circular in reasoning but it also allows us here in the label to say this is for name so if someone clicks on the trip name itself on the label itself it takes them to this input. It's one of the things I like to make sure that all of the forms in my project are going to use. And finally let's add bootstrap classes to support the way the submit button looks as well. Back in the browser we can now see this very simple small form is now ready for us to actually implement and do something with. Back in the controller code lets add new member to our VM here called VM dot new trip. This is going to represent an optic that's going to accept all the data about a new trip and I'm just going to give it the object literal for an object with no properties. In order to allow this form to take the data we type into it and push it into that new trip we need to use another directive called NG model. The model will take the forms of VM dot new trip dot name. This dot name specifies the property to set when someone types into this control. Now even though name doesn't exist yet it'll create the new property if necessary. Now if we had default properties we could create that new trip in the JavaScript with some default values but that's not the case for our very simple form so that'll be good enough. We'd also like to have a way to handle when someone presses the add button. We can do this by instead of handling the input itself going to the form and saying NG submit. This is going to allow us to say VM dot add trip. Notice the parenthesis at the end, we're telling it to call the add trip function in this case that specified on our VM, so of course that means we need a VM dot add trip as a function. This is a member of the VM now and that this will be called when someone clicks on the add trip. So let's do the simplest thing here, let's call alert VM dot new trip dot name. So when someone clicks the add trip we're going to see if we can find the name that they typed in. Refresh that page briefly and let's put hello world and press add. So the code is able to get at that data that was pushed into it by using the NG model so that our controller continues to hold on to and be responsible for the data in the form but we're just using that linkage between the form controls and the underlying data to have that relationship. This is a fundamental idea you really want to get your head around and that is you're going to have code and in this case that's controller that's going to be responsible for the data that it's dealing with. And that you're going to use data binding with things like NG model or simple data binding like the double curly braces to expose it, to have the interaction with the user. Now we've done the bare minimum so far, before we can go ahead and handle the add properly let's go ahead and look at validation of this form. Let's do that next.

Validating Forms

Now let's look at validating the form using AngularJS. Back here in our form let's use the standard attribute for required to tell it that the name is required in our form and we'll actually use one directly from Angular called minlength. So the name of our trip has to exist and has to be at least five characters in size. And what we're doing here is we're adding attributes to the UI that know about what is required here. And this is in stark difference to the way we did it with the server side validation. Often we'll need to mimic what we have in server side validation her in an Angular form if that's what we're going to do. There's some attempts to sort of synchronize those between client and server but because we're dealing purely with client this is what we're going to end up with right now. Now we have the validation attributes there what are we going to do with it? Let's add a new directive on the actual submit button that says disable the button so someone can't submit this form until the data is valid. So we're going to start by using the form name here, new trip form dot dollar sign invalid. The dollar sign is something that Angular does when it's extending its own properties of module and controller names. So if you see dollar sign in front of a property you can pretty much guarantee Angular put it there. So this is a property that it has put on the form because it knows it's responsible for it and it makes this a true value if the form itself is invalid, if one of those validation pieces isn't working. So we're saying if the forms invalid disable the control. Let's see this in the browser. We can see now that when I hover over the add I can't actually click on that button because we don't have a trip name and if I start to type even at four letters the add doesn't show up but as soon as I say the O in hello ad works now. Remove it, add doesn't work again. So those rules are actually being validated in real time as I type. We might want to tell the user about these validation rules so let's do that next. Below the input I'm just going to create a new span and I'm going to use NG show to tell it when to display this span and I'm going to do that by saying new trip form. Again go into the form name and then I'm going to use the name of the input and that's going to be name and look for dollar sign air. Again an indicator cause it starts with dollar sign that this is something specific to Angular and then required. And required in this case is going to be the name of the type of validation because we're using required and minlength here those are going to be the two that we're going to test for. And I'll just put the message in here. And let's go ahead and give it a class to say warning, so that we're showing it in a way that's useful. So let's go ahead and copy this for our minlength but let's change this to minlength as the the name of the problem and let's change this to must be at least five characters. Let's refresh that page and we can see that it says name is required now because we told it to show it if the required error exists and even though we haven't done anything the errors can exist immediately. But as we start to type the required get's fulfilled and it falls back to the second error which is the minlength. And as I get to minlength that validation message goes away and the ad becomes valid and we can actually do something with it. So let's make this work temporarily here in the client. We're not actually sending data to the server yet but we will in a minute. So we go back to our JavaScript, instead of using that alert in the add trip let's actually add it to the collection. VM dot trips dot push in order to push it in our collection we started up here. And what am I going to push? I'm going to push a new object with name coming from VM dot new trip dot name and then created coming from new dates so we'll go ahead and add a new date there. So we're adding a new trip to our object. Now if we're going to add this to the collection, what's going to happen? Refresh it here and let's say another trip, we press add, what happened there? Angular notices that the collection has been changed and knows that it then needs to show it on the screen. In fact as we continue to click this that list will get longer and longer. Now these aren't actually being saved to the database yet, in fact none of this is from the database, we'll get there in a moment. But one of the things I don't like is that another trip doesn't get cleared so I can accidentally add the same trip a hundred times in case I get confused as a user. So here in the add trip I'm also going to say add new VM dot new trip equals another blank object. What this is going to do is it's going to tell the form that the data is gone, therefore clear the form. Back in the browser let's start again and we'll say another trip, press add and it adds the new trip and then clears the form so we're back where we started, all ready to add a new piece of information if we want. So you've seen how manipulating that collection displays different information on that screen and that how we can use the form to control that. Let's deal with some real data now, let's go ahead and get data from the server and show it here on our page. Let's do that next.

Retrieving Data with AngularJS

Now let's see how we can retrieve data from the API using Angular. Here in our controller we'd like to be able to fill this list of trips from our API instead but in order to do this we have to have a way to call to the server. Angular has a facility for that, has a service for that called HTTP. The way that Angular works with dependencies is that we can actually include them here in the function that represents the controller and they will be supplied. This is a lot like the constructor injection that we're seeing on the server side in ASP.net. So if we include dollar sign HTTP and again that dollar sign should be indicative that this is a service that can be supplied by Angular itself. We can then use it. Here I will just call http.get and then I'll point at the relative service name API trips to go ahead and retrieve data from the server. A couple of things to note about this is that this called get is matched to the server verb. So if we need it to post we'd use post, put put, delete delete. But in our case we're just going to do a plain old get. And what is returned from the get is a promise object, this promise object is one that we can immediately call then to specify the call back for success and failure. So the first perimeter to then is what happens when it succeeds and the second is what happens when it fails. So this is success and this is failure. To succeeds we can include as a perimeter here the response that it got from the server. This will be an object that contains a number of pieces of information. The one most interesting to us is response.data, which is the actual payload that we got from the server and this has already been converted from json into an object graph for us. So we'd like to be able to push this collection into the trip object on our vm. We can do that with a call on the Angular object called copy. This is where we're going to start with the data and we're going to tell it to copy to our vm.trips. Now this is a short cut, we could do a four each and sort of walk through this collection if we want but this is a very quick way to handle it. Let's see if we can actually get that data from the server. Let's refresh that page and we can see east coast fun US trip and world trip, those were the trips that were created in the data base. So we're actually getting that data and then immediately binding to it once the call to the server is complete. In the case of failure we'd like to be able to get that error function and show that to the user. We can do that by creating another member called error message. Now one thing I want to explain here is we can create members of the view model here that represent nonfunctional data. So error message is a way to say oh this is going to be a way we're going to show data on the screen if that data exists. Here in the failure we'll say error message equals fail to load data and we'll just include the error there. To display this let's go back over to our view and let's add an element up here and we'll put it under danger and we'll just say vm.ErrorMessage right. We can also use another directive to decide when we're going to show this. So we can say vm.ErrorMessage. So we're going to show this if the error message exists, now of course because this is JavaScript under the covers this is going to only come back as a positive if the error message not only exists but isn't an empty string. So back in the browser we can see that the error message isn't taking any room here just because it's an empty string but it will show up if we ever do get an error condition. In our trips controller, let's misspell trips for a moment and let's try that. So here we can see we got the fail to load data because our API name was incorrect and in fact because there are no members of that table the table isn't being shown either. So we're not getting any empty data when we don't need it. Let's fix that so we can see the real data being shown. The last piece we'll add here is a busy flag and because we're about to do the get I'm going to mark that busy as true and then we'd like to have a way to turn off the busy whether we succeeded or failed. We'd hate to have to do vm.isBusy = false and then copy it twice. That would work of course but that's not very elegant. The fluent syntax here is going to allow us on that promise to do a finally, finally is going to be a function that's going to be executed much like in a try finally block no matter which one of these was executed. So here we can say is busy equals false and so that we can use this to show that we're actually doing an operation. We're loading the api awfully quickly for a couple of reasons, one we only have a few trips so far and two we're on the local machine. Once we get into an actual scenario where we're running off machine, especially if we're on a slower machine with a slower connection lets say a mobile tablet we're going to notice that the operation is taking a minute. So we'd like to be able to show the user that. And so let's do that with another one of these divs and here we'll use the VM as busy to say go ahead and show this div when that marker for is busy is true. And we'll set up a class here of tech center because we'll want to go ahead and center this on the page. And let's use one of those font awesome icons, so class = fa fa-spinner and we'll do fa.spin as well. To tell it to take that spinner icon and go ahead and rotate it, which is something that font awesome supports. And we'll go ahead and say loading here as well. If we look at this in the browser we're not able to see the loading because it's happening pretty quickly. Let's come and dot that line where we clear it just so we can see what this going to look like. And there will be our little loading indicator that will show when we actually need to wait for an operation to complete. Now that we've commented back in we can see that it's going to show just briefly and we'll reuse that element a little later when we're going to save data to the server as well. So next let's implement the creation of a new trip so we can see that working as well.

Creating Data with AngularJS

Now to us Angular to create new data in the database through our API. Back in Visual Studio let's take our code inside the add trip, let's get rid of it, because we want to add this trip to the server let's start it out by first telling the display to show the is busy flag while we're doing that saving. And then let's use that http again to post to our api trips. Now if you remember when you built the API the same URI if you post to it, it will expect there to be a body that represents a new trip. In fact we already have that in our new trip, just like we did with the get we're going to want to call then with two functions. And then also a finally with one function to clear the is busy flag. We're clearing this because we turned it on temporarily when we decided to post this new trip to the server. Now we could take this new trip and push it into our list of trips but remember the actual trip objects may contain other fields that we want. So we actually want to get the response here in the then and push that. So we'll say vmtrips.push response.data. That data will represent the new trip object. And of course we'll do the same thing here with error message failed to save new trip. And in fact we'll want to clear out this error message before we start the operation as well. The reason is if you're trying to save it and it failed for a known reason that you could retry we want to clear the error message every time so we don't end up on a successful situation and we've got an error message stuck with an old error in it. If we have succeeded in pushing that new data in let's go ahead and clear the form by setting it to that empty object again. If we did this right we should be able to add a new trip, we'll call it Southern Fun and we'll get Southern Fun added to the bottom and for a minute we saw the loading because we told the is busy. Now we might have accidentally just added this to the bottom based on our local data but let's go ahead and refresh the page and that should cause a new get up to the server to happen to make sure it was actually saved in the database. Now we're getting them from the server and they're ordered differently because the server is returning them in name order. But that guarantees that our push actually worked. And so we've got a simple controller that can now get data from the server, display it and allow us to add new trips to that list as well. So now that we have the controller completely working let's talk a little bit about reuse, let's do that next.

Creating a Directive

So next let's create a module that has a directive in it that we can use on our website as a method of reusing the same code in different places. Let's start this by creating a new JavaScript file and I'll just call this our simpleControls. This will be a place where we can add more than one control that we want to reuse and I'll start it off with one of these immediately invoked function expressions and then of course use strict to make sure it's nice and safe. And here I will generate a new module, calling angular.module and I'll call this simpleControls, as the name of the module. Now in this case I'm going to specify the empty array at the end because I want to actually create this module but I'm going to use this one file to create some elements inside of that module. So I can do that with the ClueNet syntax here and I'm going to create what's called a directive. And in our case I want to create a wait cursor directive. Let's going to effectively be a new reusable component that shows a wait cursor. And I'll just call it wait cursor and then define a wait cursor function that's going to represent the definition of that wait cursor. This is similar to the pattern we used in creating the controller but in this case we're going to use a directive. So earlier we talked about directives being those attributes that we've been adding and decorating in our code but directives can also be used for complete elements. So what this is going to allow us to do in the trips is to actually replace our div here that showed the loading icon with with wait dash cursor. That's going to be the element type now and instead of having this content inside of it all we're going to want on it is that NG show. Now the NG show is going to still be used to show and hide this but the wait cursor will be a reusable component we can use in multiple places inside of our application. So let's go back to simple controls and let's just return an object. The way directives work is they return an object with some well-known properties in it that use to define what should be used as our directive here. So one of the properties you can specify is template url. So this is effectively saying I have a fragment of an HTML someplace that represents what this wait cursor looks like. And we're going to find this in views waitCurser.html. Now remember this is all client side so when I say view slash wait cursor we're talking about inside the wwwroot. So let's create a new folder for them call it views and let's go ahead and create a new file waitCurser.html. And similar to what we did before let's go ahead and create a div as container and that div with text center to be the description of what's in there. And then like we did before we'll use an icon. So before we open the browser we need to take our simple controls and add them to our view. So let's go to Trips.cshtml and let's go ahead and just grab our new simple controls right before our app controls. The reason for that is we're going to need a simple controls in our app trips controller. At first let's take a look at it in the browser. If we refresh the page we're not going to see it because remember we told it to hide when it was busy and if we refresh it really quick might be able to see it but it's hard to tell because our operation is really quick. So let's look in the tooling and see what this actually looks like. Our wait cursors here in the firebug extension or Chrome tools and it's using that the NG show to actually hide this element. So that part of it's working the way we expect it to but inside the element there's none of that template we were expecting, none of that injection of the template is working. So it probably isn't working but in case let's go change the NG show to just say true to show it in any case so we can take a look at it real quick. Go back to the razor file, I'm just going to change this to true so it shows as wait cursor all the time. We refresh our page, we can now see it is being shown, it is a valid part of the Y but none of our code is really working. The injection of that template isn't working and the reason that's not working is pretty simple. Browser's when they reach an element they don't understand they ignore it, they treat it as actually just a simple div, depending on the browser that can be a little different but in our case it's saying hey here's an element I don't know what to do with so I'm not going to do anything with it. I'm simply going to ignore it. That implies that our code isn't actually using our new directive, how do we get it to? If we go back to our app trips module, this is the module that is responsible for taking care of our whole page, of looking at the dom and finding the elements that we want to do something special with Angular. This includes directives. So just because we've included the simple controls on our page we still have to tell the main module of Angular, hey you're going to want to consider all the code in this module and expose it to the module as it needs. So we need to include the simple controls here as a dependency to the app trips module. This is going to make the app trips module us it as a set of directives that it knows what to do with. And so when it parses that dom it's going to see the wait cursor and know what to do with it, let's go look at it in the browser now. We refresh it we can see it's now showing up just as we expected it. Our wait cursor is now a structure that looks awfully a lot like the structure we created in the template, because that's in fact what it did. It noticed it as a wait cursor and it injected that template in. If we change this back to us the VM is busy we'll see that it's going to be hidden and shown correctly here in the browser though it's going to happen pretty quick. We do it because I'm only recording at 15 frames per second you may not be able to actually see it in the video but it is showing up very quickly. And we can prove that here in the tools in that our object is hidden here but inside the object is that template still. It's just being hidden from the screen while there's not an operation going on. So we've got an actual directive working. Let's looks at some other concepts around directives next. We go back to where we are using the wait cursor, one of the things we can actually do is use wait cursor simply as an attribute, just like NG app and NG controller are attributes we can decide to just use it here as the attribute to define that this is a wait cursor. In fact if we refresh we can see it continues to work. But what if that isn't really the pattern we want? Instead if we want to restrict it to be only the element we can do that by going back to our directive and adding restrict E. Restrict E say's restrict it to only the element style. But in our wait cursor here we're using an NG to show the entire element and that may not be what we want, we may want to extend our wait cursor with some attributes that are specific to it. We can actually do that. Let's go ahead and have a property display win and then we'll keep the VM that is busy because that'll be the Boolean we use to display that but then we can use this display when inside of our template the way we want to. So in here on the this div we can then use the NG show or display win. The reason this is important is it's not always at the top here maybe that we want to change some deeper part of the template based on that property. So instead of assuming that it's always at the top level where it happens to be in our example it doesn't need to be. You might have message and you might have font color and other sorts of properties that we want to include here but for now I'll just the NG show. And so what we end up having to do here is add a new part of our directive called scope. And a scope ends up being the object that we're binding our wait cursor to. And so we have to have a way to map what a specified as attribute over to what we're using inside of the template. So the scope ends up being a structure so that we can have more than one property. So let's call the property display when and we'll assign it by using the equal to tell it we're going to get it from an attribute name on the directive. And that attribute will be called also display when, so these do not have to be called the same things. In fact let's change that and let's call it show in the scope so that here in the template we'll go ahead and just call this show. So just to be clear the scope name is what's visible inside of the template and this equals and then a name is what we're going to use from the consumer of the directive here. But when we refresh it we notice it's not showing up. The reason it's not showing up is here in our attribute name. One of the things you may have noticed is that when we created the directive we used camelCasing for the name of the directive. But here in the mark up that camelCasing ended up as an all lower case with a dash in-between. And so for our display win to work because as compound word we need to do the same thing. Those need to be lower case as well and once it is our component works now. So in this way we can create these sort of chunks or components of code. Different developers use directives in different ways. Some people just create simple controls they can use here or there for simple reuse and I quite like that. But other organizations decide that everything should be a directive so that each view ends up being a whole directive that's self-contained in on its own. And that's not really a bad approach, especially as we look forward to the future with Angular 2 because that's an approach they're going to be taking. So you might want to take this idea of directives and really go all out on it and you'll be closer to the component model that we're seeing popularized in Angular 2. Let's wrap up this module.

Summary

If you want to learn more about AngularJS there are a couple of courses that can help you, AngularJS Getting Started you can see here on Pluralsight at pluralsight.com/courses/angularjs/get/started. And also recommend the AngularJS Fundamentals with is a more complete course on everything about AngularJS. And that's at angularJS/fundamentals. So where are we? I've shown you how Angular can help you build modular code and that's ultimately the way you're going to create rich clients for your websites. I've shown you how views, models and controllers are all divided much like they are on the server but the Angular is doing this on the client side. I showed you how to create directives so you can create your own reusable pieces of functionality for AngularJS. And finally I showed you how data binding works so that you have in the HTML all the information about how the view is being shown. And that you can do this in the views instead of having to do them in the code where you can get a little mixed up in what is business logic versus actual data binding. This has been Shawn Wildermuth of Wilder Minds thanks for watching Building a Web App with ASP.NET Core 1.0.

AngularJS Routing

Introduction

Welcome to building a web app with ASP.NET 5 MVC 6, Entity Framework 7, and AngularJS. In this module we'll introduce you to AngularJS Routing. We'll start by creating routes, using views, show you how to integrate non-Angular plugins, we'll go ahead and complete the functionality of the web app. Let's get started.

Adding Routing

Let's start by adding routing to our web app. Before we can get started, we're going to need to add Angular Routing to our project. If we open up that bower.json file, we can come and add it here just beside the main Angular file, by typing angular-route. Angular itself if modularized into different pieces that have different functionality associated with them, and angular-route being a fairly large piece, has its own package, as well as module. So here I'll add angular-route and pick the same version that we have for angular. Once we do that, it will go ahead and get the reference and put it directly into wwwroot, just like it did angular. Once that has been loaded, we can go back to our view, and include it here in our list of scripts. So as we can see it's in the angular-route folder, and then it's just simply the min version of that script. To add it to the functionality, we're going to go ahead and open up that original app-trips Java script file. If you remember this is where we're creating that module, and so we'll just include the module as a dependency to the app-trips module, as well. So, including the JavaScript just to find that module, but we won't be able to use it in our module, until we include it. So, we'll add ngRoute, which is the name of the module, and at that point we can actually configure client-side routes. We do this by handling the config method of the module object that's returned. The config method takes a callback function for when configuration needs to happen, and what we're going to do here is we're going to use parameter injection to include a property called routeProvider. This is an object, notice it starts with dollar sign, so we know it's one from Angular, that's going to allow us to define client-side routes. We do this by using the routeProvider, and calling when. So the first parameter of when is going to be the client-side route we're looking for, and so by starting with just a slash, we're going to say when we go to the route of the client-side routing, and we'll see what this looks like when we actually get this working. The second parameter is going to be an object that represents the information about how to execute that route, what to do in that route. So for us that is defining a controller, that it's going to be used for that individual view, and then a controllerAs, which is the alias we're going to use for data binding, and in our case we'll always use vm as the controllerAs, and then a templateURL for a path to the html that represents what is that actual view. So the controller is going to be the tripsController that we already defined. And for the templateURL, let's go ahead and create a new template in the Views folder, and we'll just call that tripsView.html. We're also going to use routeProvider to tell it what to do if none of the routes match, so the last one is going to be a call to otherwise, and otherwise takes an object that has a couple of properties possible on it, but the only one we really care about is redirectTo, and we're going to start with a slash. So if any route that isn't matched by any of the route provider when calls is found, we're going to simply point it at this first main route. Now that we have created the route let's go ahead and rebuild that tripsView, so we can see this actually working for a single route, as a starting point.

Creating Views

Now that the routes are defined, let's go ahead and create our first view. So let's see how this is actually going to work. Let's start by creating a new file in the Views folder, and this likely file we used in the waitCursor view it's just going to be an html fragment that represents just this view. We already have this data, if we go back to the Trips view, this entire fragment of html that we're already using by assigning the controller, we can use as that entire template, so I cut it, and I'm going to paste it over here in the new file. The only real change I have to do is I can get rid of this call to controller, because that's going to be assigned automatically by the routes. So the tripsController and the controllerAs are going to be attached to this fragment of html. But how does this fragment of html actually get into our page? It does this by creating a div that has a special directive attached to it called view. It's essentially saying, for this particular page that we're using a module for, find the ng-view and use that as the placeholder for, or views are injected onto the page. This is an important concept, because often we will have a route set up that only changes some part of the page, we want to leave the rest of the page as is. This is essentially the container for where those views are injected. So if we've done this right, we should be able to run this now, and go to the View Trips page. So now we should be able to come to this trips page and we can see that this is actually still working, we can even add a new trip. And that it goes ahead and adds that. So all the functionality we built to be embedded in this page is still on this page and working exactly the same, we're just using this routing system. Now what about that routes? We look at the URL up here, we'll notice that there's a pound syntax in here, and the pound syntax is one that was originally envisioned for inter-page linking, so being able to navigate on a page. You might see on some other websites they might use an exclamation point instead, and that's something you can actually configure. But I'm going to leave it as pound, because I think it's a little bit more descriptive. What that pound means is that everything after the pound is the client-side routes, so what do we have after the pound? A slash that represents this client-side view that we're showing here, and that's the idea with routing, is that when we add another view, the other view might be slash editor, or slash trip editor, or whatever we end up building next. And when that other view is shown, it simply swaps out these fragments of html, activate the controller, deactivates another controller as necessary. So you have this multi-pane effect in the client-side code within the browser, that will allow you to build much larger, complex applications, without ever having to go back to the server to refresh the page, it simply swaps out individual pieces of functionality and markup as necessary, so you can still build them as these component pieces. So now let's go ahead and build that second view, so we can really see how this navigation back and forth is going to work for us. Let's do that next.

Second View

Now that we've installed routing and created our first view, let's see what it's like to use more than one route and create our second view. Let's start back on our routing and let's create another route by using the routeProvider.when, but this time we're going to start with /editor. This will be an editor for an individual trip, the controller will be called tripEditorController, controllerAs continues to be vm, and then the templateURL will be views tripEditorView.html. So let's create that view real quick, I'm going to use a Control left two trick to go ahead and create the tripEditorView.html. And again we're starting with a blank slate, but we have the content of what we want here as what's left inside of the trips view. So I'm going to cut that for a moment, so what's left in the trips cshtml file is really just a description of what module to use and then a place for the view, that's really all we need is that placeholder, and of course, the scripts we're going to use. So back here in our tripEditorView.html file, I'm going to go ahead and paste all of that information in we were using before, but of course we've got some Razor code in here. We're not going to use this Razor code, we're going to actually display the list over here above the form. So let me just get rid of that Razor code for a minute, just to clean that up, and let's wrap this all in a single div, so we can more appropriately have at as a container. So normally I suggest that each of your views when you're using routing end up resolving to one container, and that's one of the reasons why we wrap these two sections, even though they're related into one container, because the controller's going to be attached at this level, and so it will be responsible for all of this, so that container ends up being somewhat important. Now of course I told you that we just got rid of that Razor code, let's go back to our trips, and we can really get rid of this model line in our Trips.cshtml, that server-side view, because what we want to do is we're going to do all the data access through the API with client-side code, so we can actually even look at the controller for trips, and get rid of this as well. Just return the call to View to go ahead and use this Trips.cshtml as our markup. We're also going to need a new JavaScript file, tripEditorController, and we'll use that same immediately enveloped function expression to protect ourselves from the global scope. And let's add strict, to be good citizens, and then, like we did with our other controller, we will call angular.module, app-trips as the name of the module, and then simply call controller afterwards, EditorController, and we're also going to define a function here that represents the actual controller we're going to use. And while we're feeling out the functionality for this, but let's just leave it empty for now, 'cause we want to see how the views are working together. Let's go back to our tripsView.html file, and let's change one thing about what we've constructed here. Here in the Manage button, let's go ahead and change this to use a link over to our route. So it's going to be #/editor, right? Where does this #/editor come from? It comes from the route, #/editor's the route, and then the pound is telling the browser that this is an inter-page link. So that as these are created, Manage should allow us to switch to the new view. Conversely, over in the tripEditorView, let's add a little button at the top that just says Back. And in fact that we'll use fontawesome, which is an angle left for the back, so we just have a little visual representation of what this means. Now where should this Back take us? This Back should take us just to #/, back to the route of our client-side route. So this implies something, this implies that all we're doing is writing the same sort of web code we had before, we're using links to go to different parts of an application, but instead of those being a server-side endpoint, they're now a client-side route. Let's go over to the browser, and let's refresh that. So now we have this view, and if we click on any of the Manage buttons, we can see down there that they're going to take us to that pound slash editor, and that takes us to the editor. If we hit that Back button, it's going to take us back to this view. At no point in any of this process are we actually making a server request, except to initially load this. And so this way we're given the experience of switching pages and doing different pieces of functionality, but it is entirely up to the client-side code to have this be managed in this way. And when we switch between these views, the controller is being called, but it doesn't mean that controller has to re-execute the calls to the server every time it needs to. And so it wants to be a little more efficient than it actually is. So we're actually going to see that we're getting an error up here, and the reason is, is that we didn't actually even define the controller, the controller's not even being loaded. So even in the case where the website is throwing errors, it's still going to try to manage the routing in the best way it can, so it's still showing those different pieces of functionality. The reason why we can't find this new tripEditorController is because we never included it as a script here. So let's do that. I'm going to show you that this new controller is actually working by just adding some piece of information here, just to data bind it very quickly. So, in the EditorView, I'll just say vm.name, so we can see it after The World. So now our data binding is in fact working. What's interesting here that I showed you that may not be obvious is that because the web address is changing, these are actually storable links, these are ones that could be shared and traded so that when someone executes this and loads all that server-side code into the browser, the routing isn't necessarily going to build that first view, if it's not necessary, it's going to see what's here in the URL and go, Okay, load the Editor View, without ever needing to, or forcing that first view to be shown and executed. So now that this is working, let's go ahead and make this Editor View actually work. Let's do that next.

Implementing the Editor

Now that we have our Editor View, let's go ahead and implement it. Let's start back at the route for this second view, and understand what the functionality is. Here in the first parameter of the when inside of our route definition, we're going to add another slash and a colon with the name of tripName, to indicate that we want a route parameter. We're specifying that here in the route itself we're going to use some variable that we'll be able to pull out, and the tripEditorController has the name of the trip. And in this way we can have a route that handles a single trip, based on what the route is. So back here in our tripsView, let's make this work by actually adding it here to our editor. We can do that by using the trip.name here inside cURLy braces, but the cURLy braces are not going to matter if we're just going to leave this as an href, Angular isn't going to know about those double cURLy braces inside of an attribute. So what we need to do is change this to be an ng-href, this is a directive specifically to allow data binding inside of an href, usually of an anchor tag. So in the browser now we can see that when we hover on these we're actually going to get a client-side route that's defined with a name with the name of the trip. Now we could've used IDs or something else as well, but I find this to be a little bit more illustrative. How do when then use this new tripName? If we go to our tripEditorController, let's get rid of our fake name here, and let's include a parameter inside the function parameter list called routeParams. routeParams is going to allow us to add tripName to the controller or the View model itself by saying, routeParams.tripName. Its assign this as a new property based on the fact that the route itself over here in app-trips.js is using that same name, tripName. So it's just extended this routeParams with whatever parameters it found in the route. And there could be more than one parameter in the route. So let's go back over to our View and instead of saying The World here, let's get rid of the little tag and let's just include vm.tripName, so that we can now have the tripName displayed in the view, and eventually we'll go load up all the stops for that trip and display them here, as well. But first thing's first. Now that when we click on each individual trip we're getting the name of the trip right there on top. Makes sense? So, we're passing data from inside the URL that we're constructing, using Angular, and then pulling it back out using that routeParams parameter. That's a sentence you don't want to say a bunch of times. So what do we want our page to actually look like here? What we'd like to do inside the controller is create a few more properties that we know we want to use for bindings. So let's start with stops as a list of the stops that we're going to edit, and right now it's an empty array, and, of course, like we did before, let's go ahead and add an errorMessage of empty, let's go ahead and spell errorMessage right, and isBusy equals, let's say true, for now. Now that we have our basic set of properties, let's go ahead and implement this View. The View is going to have a list of stops here and then a form for adding new stops. But before we do that, let's take a look and see what this looks like. Our list of stops in the left-hand side, let's go ahead and change those to only three wide, and that way we can make our map, that we're going to introduce later, much wider at nine. And let's change this tripName to an h2, to make it a little smaller, now that we've made it only three wide, a giant display of the tripName might not be as useful as we might imagine. Here we can use that same wait-cursor that we built before, remember we included it in our module, and this is all inside of that module, so we can continue to use it. We can use the display-when vm.isBusy. So we know have the reusable component simply being used here. Let's introduce you to another Bootstrap facility that can be pretty useful, and that is something called an alert. An alert is well-known sort of block of text that draws the eye to the user, and I'm going to do alert-danger, because we're going to use this to display our error message. For now I'll put Dummy Error, just so you can see what the alert actually looks like. Let's refresh our page and let's go to the World Trip. Here is that Dummy Error, and there is our, isBusy flag, which, of course, isn't going to say busy the entire time. Let's change this to display the vm.errorMessage, and we'll use the ng-show for vm.errorMessage, so only show it once we have an error message and it's not blank. So so far, so good, we've got the wait-cursor working, we've got a place to put our error message when an error occurs, and now let's think about how we want to actually display those stops. We're going to use the same table class that we used in displaying the trips, so we can say, table table-responsive and table-striped. And for our first row we're just going to use table headers to indicate what is in that column. So this will be the Location and the Arrival. Then we can use another row, but this time we're going to use the ng-repeat to say stop in vm.stops, right? We're going to recreate this row for every stop inside of the collection of stops, which, of course, is empty right now. And we'll just use basic data binding here to get a stop.name, arrival, and we'll use a filter again, date:shortDate. Back in the browser, if we refresh this, we'll see the headers for our list of stops, but, of course, we haven't done loading it, so the wait-cursor is still showing, and none of the rows are showing, because we don't have any stops yet. So we have the basic framework for what it looks like, the functionality for our page, so next let's call that API and get that actual data.

Calling the API

Let's go ahead and call the API to get our stops. Like we did before, let's go ahead include that http service in the parameter list of our Editor Controller, so that we can go ahead and call and get on api, trips, vm.tripName, stops. So we're essentially going to go get the stops for the current trip and then use the call to then, add the response, like we've done so many times before, angular.copy, response.data into our vm.stops. Otherwise, vm.ErrorMessage going to be, "Failed to load stops," and finally will be vm.isBusy = false. So to clear out that whole piece of functionality of loading it, as well. Let's put a little comment there for failure so we can see how it works. And so, at this point we should be able to get those stops and at least display them in the list. And so now we have that non-trivial list of stops from the US World Trip. And we can see that looking at our other trip that has some stops in it, we're going to get the smaller list, and if we go to one of the trips we've created but haven't done anything with, like the East Coast Fun, we'll see that it's not going to have any stops in it at all. So now that we have this, let's talk about building that map.

Using a Non-AngularJS Plugin

Now let's talk about how to use a non-Angular plugin, just a client-side JavaScript library, and make it work with Angular, by implementing our map. Now the first thing we want to see is, in the browser, we can see that there's some oddity with the way that the Back button is laid out on our page. Let's go ahead and fix that, so that we can take as much of the page as possible for our map here. All we'll do here is wrap our button in its own div. We'll refresh the page, we can see that it's now going to keep that Back button on this line on its own, and then everything else is lined up. And what we're going to do next is to add a map here of whatever the trip is, starting with the first one and down to the last one. Back in Visual Studio, let's start by going to our bower package. I'm going to add a new project called travelmap, and we're going to use the current version, which is 1.0.2. Now, caveat, I actually wrote this travel map, this travel map was specifically used for my world trip. So I want to show how this can be integrated, because travelmap has some intricacies that are not uncommon with other JavaScript libraries, especially ones that are ignorant of Angular. Let me show you what I mean. If we go back to our Trips.cshtml, let's go ahead and add the travelmap piece here. Script source equals lib, travelmap, and travelmap.min is fine. Now what may not be obvious is that over on the lib folder, this is where all our libraries that we've brought in with bower exist, except there's one here that we haven't specifically loaded in, gmaps. The reason gmaps is there is because travelmap requires it, and you're going to see this pretty commonly if you bring in certain projects, they will look for and to the files here other dependent projects, travelmap is dependent on gmaps, so we'll need to include gmaps as well. Now that we have the two libraries included, let's go back to our EditorView, and let's add our map here, by just creating a div that will call map. So it'll just be a container for the map itself, the Google Map that will have all of our travel stops listed on it. We'll also need to open up the site.css to go ahead and style that map. So we'll use the #map to indicate the idea of map on the page, and then we will say width 100%, and height 600 pixels. This height and width are specific to some requirements in the way the embedded Google Maps work, and since gMaps is a wrap-around Google Maps, that's where that comes from. So now let's go back to the controller and add support for it. Because we want to be able to show this map, I'm going to go ahead and create another function inside of the immediately invoked function expression, but outside of our controller function, called showMap. Now this could certainly be inside or even a member of the tripController, but since we're only going to be calling it based on code that's happening inside the controller, we can have this in either case. The important part is that we're using this immediately invoked function expression, so no matter where we put it, it's not going to be exposed out to the global scope. And the showMap function, I'm using an underscore as a beginning character, mostly as a shorthand for this is a private function, a function that's only going to be used within this file, and I'm going to take the stops we have and I'm going to draw them on the map. So first I'm going to make sure that stops is valid, so it's a valid object, and I'm going to say if stops stops.length is greater than zero, so if we have valid stops being added to us, let's go ahead and show the map. And here's where we can use the included API, which is travelMap, createMap, and that it's going to take an object literal that's going to have some overrides, including stops, these will be the individual stops on the map, and of course we're just going to pass on that local variable stops. And then selector, and this is going to be an expression that's going to be used to find the place to put the map on the page, and that will of course be #map, for an object whose ID is mapped, again, using css selectors, pretty common case, currentStop, this is going to be the which of the stops in the collection to highlight, and I'll just hardcode that as one for now, and I'll set the initialZoom to be 3. This will basically give us a view of the entire world in our window. Now that we have the showMaps defined, let's go ahead and add it here, once we get data from the server. Just call showMap, and include the vm.stops. Over in the browser, if we will refresh we'll see that we actually have some errors. So let's open those up and we'll see that there's immediately an error that says, "Google Maps API is required." Please use this JavaScript library. So we're going to use this URL that it's giving us to add a new script. The script will be in our Razor view, and let's put it right before the gMaps. And this isn't an uncommon thing where the thing that you're requiring it to use is actually a link off to a JavaScript file sitting on some other server than yours. Now that we have that included, let's go ahead and refresh this page, and we'll see that the map still isn't showing up and there's even more errors. And that's because we're starting to get errors about LatLong and LatLong integer not being a property of Lat. This is really telling us that the structure that the library is looking for is different than we're supplying. If we go over to the Projects folder, which is out on GitHub, we'll see in the docs that it talks about the structure that it expects for stops, and that includes a property called lat, a property called long, and a property called info. Now, of course, our stops that we're handing it are different, it's called latitude and longitude, and arrival date and name, doesn't match the same object structure we're looking at here, and so often when you're dealing with libraries like this you'll need to change the structure, map your data types into the data types they're expecting. And so let's do that. We're going to do that by including yet another library, but one we've already loaded with bower called underscore. Underscore is a library that will allow us to do LINQ-like queries on the client, so things like creating new copies of mapping one type to another, or doing searches, finds and queries, all of that is supported in underscore. So let's use it in our controller here, and if we do have stops, let's go ahead and create a new variable called mapStops, and let's pass that in as the stops to the map, and we'll use underscore this time to map these with the _.map function. Now let's talk about what's happening here. Underscore the entire library is actually contained in this underscore variable, it's not something we're passing in to the controller as a dependency, because we've included it on the page, JavaScript just makes that available at the global scope, therefore it's available here, and the map is going to be the function that allows us to map one type to the other, so we'll pass in stops and the second parameter for map takes a function that has the individual item in it, and in this function we will have code that returns the new data structure. So here we'll just say return a new object literal with latitude specified as item.latitude, the longitude of the new mapped object we're going to get from the longitude of the object that was returned to us from the API, and then for info, let's just include the name. We could have the date in there as well, but name is going to be good enough, info is used when we're popping up these items. So back on the browser, let's refresh this page, we're getting a map and we're getting a map that's actually showing us the information, because we've now done all the pieces that are going to be required there. To go back and look at the more complicated one of like the World Trip, and we're now getting that entire World Trip shown with all the different stops. Now we need to take this example and support adding our stops with the form at the bottom. And we'll do that next.

Validating a New Stop

Before we can accept new stops, let's go ahead and add validation to that stop form. If we look at our tripEditorView, you remember we have this form that has the different elements on it, and I'm actually going to move this to the top, so that when we have a really long sets of stops that it doesn't get pushed all the way to the bottom. So I'll put it before our table, shouldn't change any of the functionality we have, and let's go ahead and start to do the same validation we've seen in earlier examples, we'll add novalidate, we'll give it a name, newStopForm, we're going to want to add ng-model to support the object that we're actually pulling from. So that's going to end up being vm.newStop.arrival, and we'll go ahead and make it required, and we'll do the same thing down here, ng-model, vm name required. And like we've done before, we'll use the submit button to disable it, ng-disabled equals newStopForm invalid with the nice dollar sign on it. So if the form's invalid, go ahead and make the button not work. And so let's make sure this part is working so far, and let's go back to the controller, and let's add that new property, vm.newStop equals an empty object tag. Over in the browser we now have our control up here, and you notice that because both of these are required, the Add is disabled until we actually solve those required elements. So let's add that validation message so that we can actually make this work. Back to the View, we'll just add a span, and let's add the class of text-danger, and we'll just say required. And in here we will use the validation to ng-show them. So that's going to be newStopForm.arrival.error, remember the dollar sign means it's specifically for Angular, and required. Now, this arrival here assumes that we've actually added to our controls, id equals arrival and name equals arrival. We're likely going to need both for different scenarios, so we're going to go ahead and add both of them there, and let's repeat that here, since we know those are going to be the name. Let's copy our validation message, and just change this from arrival to name. Let's see if we have that working as well. Those say required and as we fulfill them they should go away. And we have the Add button working. Awesome. Unfortunately, the required isn't going to be enough for our validation, so let's start with the location, and just add a ng minlength of, let's say about five. So we're going to require that our name actually means something. And again if we go back, look at our page, once required is fulfilled it'll start to show the other validation until we solve it. For the arrival we have a different problem, and the different problem here is that what we need is to actually have a regular expression validator, because what we're going to expect in arrival is a date format. So I'm going to use the Angular directive for pattern, and this is a validation directive that will allow me to put in a regular expression, let's go ahead and put one in that forces us to use two characters slash two characters slash four characters to represent some date. It isn't actually validating, it's a validate, we can do that later, but for a simple test, this is probably good enough. And let's repeat it with the span, so if the pattern fails, we can say, "Must be in format of," and since we're in the US I'll go with the arcane month month, day day, year year year year as the format and be done with it. Again if we go back here we'll see the required and as we start to put in a date it'll complain and explain what format we need, and then once we have found a date that it's happy with, it'll go away. So we're pretty close to being able to actually support adding of these new stops, a validation is working in the way we want it to, and now that magic Add button should actually work. Let's implement that next.

Creating a New Stop

So to bring this functionality of this editor together, let's finish it off by actually implementing adding the new stops to the database and to the map. In order to make this form work, we're going to need to add another directive called ng-submit, which we have used before to say, run this code when this form is ready to submit. This won't be kicked off, as we talked about before until all the validation is working. So we'll just call it addStop, and just execute that method whenever the submit actually happens. Let's go back over to the controller and support that new method, vm.new, addStop equals a new function, since we're going to execute it as a function, and we're going to want to do a few things in here. First, we'll want to set the isBusy flag to equal true. And once we have set the busy flag, let's go ahead and use that http object again to post to the server. And this post to the server is going to be the same post we did here. So let's go ahead and take this and let's create the URL as something we can share. So we're constructing the URL here and we're going to use it in the get, but we're going to post it exactly that same URL. But this time we're going to post the vm.newStop, we're going to send it that data, and then use the promise to supply to functions, and, of course, a finally, with a third function. Let's work from the bottom up, vm.isBusy equals false, so we're going to clear out that busy flag once the operation's done, whether it's a success or failure, if it was a failure, we'll set the errorMessage to, "Failed to add new stop." And then in the success we'll get that response, and we'll first go to our stops and we'll push the new stop in, response.data, which will be the body of the complete stop as it was passed to us from the server. I'll go ahead and call showMap with our new version of stops that includes the new one, and the way that Travel map works is it will recreate it if you call that same map. And then finally we will set the new stop to equal an empty object again, so that'll clear out the form for us. With luck, if we go back to the browser, to go to one of our more simple forms, and let's go ahead and add say, nine 09, and then let's say Miami, Florida. Press the Add, and now our Miami, Florida is added to the map, and we can see now that we have that spur from Miami down to Florida. So we have the entire functionality working top to bottom, we have the map working, we have the adding of stops working, and as we can go back and forth between these, we'll continue to have the extra stops, because they're now saved in the server. We have a complete solution. Let's wrap up this module.

Summary

In the last two modules I've covered what can only be described as sort of the use case for Angular, of doing some fairly common tasks with Angular, but I really just break the surface. Just like we talked about in the last module, going to the AngularJS Get Started course, or the Angular Fundamentals course, or preferably both will give you a richer understanding of how AngularJS 1.4 and above work. What have we learned in this module? We've talked about Angular Routing and the beginning of, sort of, composition of a single page application. So, I showed you that, routing supports the client-side switching of views so that each of these pieces and nuggets of functionality can be separated into a Controller and View, much like we're already doing on the server with MVC 6. I've shown you that views are just simple html fragments, there's nothing special about them, they're just separate files to be downloaded from the server. We've talked about how routing builds on this Controller-View mechanism that we're already using on the server, and that Angular is just JavaScript like any other JavaScript library out there, so you can make it work with plugins that aren't necessarily built directly for Angular. This has been Shaun Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET Core 1.0.

ASP.NET Core Deployment

Introduction

Well, welcome back. In this module, we're going to be exploring ASP.NET deployment. This will include preparing your application for production environments, using the environment tag helpers, using Gulp to automate your builds and looking at the deployment tooling. The reality is that as you take your app and deploy it to different environments like development production and even staging, it has different needs. In development, you want the lot of information about the running system so that you can write your code quickly, run your tests quickly and make changes quickly. In production and staging, the performance is going to be more important than simply being able to make changes quickly. So your app has to be able to change as it's in different environments. We'll see how ASP.NET 5 is going to allow you to think about things in the sense of different environments. Let's get started.

Minifying Your JavaScript

One of the first things you're going to want to think about when preparing for production environments is taking your JavaScript and making it as small as possible so that downloading it is quicker. Let's see how that's done. We're going to use a tool called Gulp. Gulp is essentially a way to define different tasks for development. Gulp can be used in a variety of scenarios and I would suggest that you investigate Gulp more than we can really show you here. We're going to use it to prepare the minified versions of JavaScript for our application. Before we can use Gulp, we actually have to introduce a new file to our project called a package file. Our web app already has some configuration files in it. It has something called project.json that we've seen and worked with that contains the information about our ASP.NET 5 application, including all of the server-side dependencies. The bower.json, which we've also used, contains all of the client-side dependencies. We're going to add a third configuration for our project called a package.json. Let's come over here and say add new item. And in the client-side, we're going to install an NPM configuration file. NPM is Node Package Manager. It is a package management system similar to bower that Node uses in order to handle its dependencies. It's become more used these days as a way to package tooling for different environments. For web development, it's become pretty common to use certain tools like Gulp and Grunt that all based on Node. And so this is one of the places where the ASP.NET 5 team has decided instead of inventing their own beast here, they will just rely on the rest of the open-source world to supply some of these tools. And as time goes on, if another tool inside the Node space becomes useful, you'll just be able to add it with the same facility. So I'm going to add the package.json to our project. We can see here it's given us some standard name and version numbers. I'm going to go ahead and put our name here as TheWorld, and then there's a section for dev dependencies. Now if we were running a Node application, we'd have another property here for dependencies. That's the dependencies for our Node application. But because we're only using this as a way to get Node-based tooling that we're going to use, we only have the section for dev dependencies. These dev dependencies are dependencies that are fulfilled on development machines. Much like the other configuration files we've used, we can simply type in the dependencies here, and Visual Studio will go ahead and fulfill those for us. What we're looking for here is Gulp. Gulp is a task runner, essentially. It's a way we can define in a JavaScript file some things we want to happen on a periodic basis. For us, that's going to be using a project called Uglify, and there's a Gulp wrapper called gulp-uglify that can take JavaScript and run it through basically a compressor, makes all the variable names smaller, it takes out all the whitespace so you get a smaller version of your JavaScript code so that downloading it across the wire is cheaper. And that's really the core of what we'll want to do. So we're going to start with just these two development dependencies, Gulp and gulp-uglify.

Minifying Your JavaScript - Continued

To our project, let's go ahead and add another artifact and that is a Gulp configuration file. And it says Gulp configuration file, but it really is just a JavaScript file that is called a Gulp file. And they've given us some boilerplate here. First, we can see that we're getting Gulp as an object, and this requires essentially loading Gulp for us into the JavaScript file so that we can then do certain things. And for us, we're going to create a task inside Gulp to package our JavaScript. I'm going to call this minify as the name of the task we're going to execute. And I'm also going to need the Uglify. This is going to have that same name we saw inside the package manager, gulp-uglify. So we're essentially telling it that when we run Gulp with the word minify for our project, it's going to do a task. So to implement this task, we're going to actually return a set of operations. We're returning it so that it knows whether it's succeeded or failed. We're going to start by specifying to Gulp the source of what we want to process. In our case, it's going to be all of the JavaScript in our JS folder. This will be wwwroot/js/*.js. So we're going to get all the JavaScript files in that JS folder. And this uses a fluent syntax so we can then call pipe which effectively tells the system take all the source files you saw and then send them through this stream of processes. And the first of these is going to be Uglify, Uglify that we got up here from gulp-uglify will simply take each file and minify, compress them down. And then the last thing is another pipe, again take all the files after they've been minified. And what do we want to do? We want to save them by saying gulp.destination and we'll give it a destination of an app folder inside of our lib folder. So this will essentially be all of the JavaScript after they've been minified or uglified, if you prefer. Let's open up a command shell. I'm using Alt + space to do that. And here we can just use gulp at the command line by saying gulp and then the task we want it to do. Remember, in this directory is going to be the gulp file itself. So gulp minify is the task name, task name directly here from when you define the task, and it will build these. We come over here to our project and look at lib, there's now an _app folder. And in that are copies of each of these files. Looks like it's a site .js since that's one of the more simple ones. Site.js contains all of the same code we were running before, but the comments are gone, and it's minified this so it's taking as little room as possible. You'll notice things like all the variables are now single letters. Any parameters, it's going to do the same thing and try to minimize the size of everything. This should be treated as read-only. It shouldn't want to change these. You really want to change the ones that are over here in JavaScript. So we take our little site here, and notice all the commented code disappeared as well. Let's create another dummy variable so you can see this actually work, right? Let's create a quick variable called foo. We'll run it again. Let's open up the minified version. So we can now see that this is a minified version of that site.js, but we'd like to be able to run this Gulp file when we do a build, for instance. And we can do that by let's go down to our Gulp.js, let's right-click it and you'll see that there's an option for Task Runner Explorer. Let's click that. We can see this new UI here where it shows us our Gulp file with any tasks that are in them, and even will allow us to execute them here. Let's refresh this so it loads our Gulp file, and we can see minify is now one of the tasks. Now if we want this task to be run during some part of this process, we can do that here. We can actually go here and say after build, binding after build. So once the build runs, it will automatically execute that. And we can see that in that after the build runs, we get that same command experience here directly in the Task Runner Explorer. So we can see these work or not work. So in this case, we've gone ahead and built it to do that minification for us and it'll now do it every time we do a build. So now that we're building the minified versions, let's go ahead and use them in our project.

Using Minified JavaScript

Now that we've created the minified versions of our JavaScript, let's see how we would use them in ASP.NET 5. If we open up our layout page, we'll see that we have near the bottom here our site.js as a file here, and then we're getting it of course in the non-minified versions, but we'd like to be able to define loading one of these in development and one of these in production or staging. And so we can actually wrap this script in an element called Environment. And here we can specifiy the name of the enviroment, in our case this is going to be development. Let's run this real briefly. And if we look at our page, let's look at the HTML that was actually rendered. Here in the bottom of the body we can see that there is no development brace anymore, it's just the write script. And the idea here is that this environment block is something that Razor itself, the view engine, is looking at and trying to determine the right thing to do. Let's make a copy of this. Let's put a little break in between them so we know what we're talking about, and let's change this to production, staging. That's our two other environments we might want to care about. But in this case, we'll use the lib app site instead so that in development, we're going to get that fully debuggable version of the site, and then we'll use the efficient minimized versions based on production or staging. Let's go back to the properties of our project and let's just change this to production for a minute. Let's refresh our page now and we'll see that all the JavaScript is continuing to work but the code we're pulling in now is from that lib app site. And in fact if we look at the script for site, it's now that minified version is the one that's loading in the browser. And so the JavaScript is much smaller than it would be if we would always get the non-minified versions. And that's kind of the basis of the benefit here. Some people love the idea that this is more unreadable and people can't steal their code. There's no real value in that. The real value here is really about efficiency. Let's repeat this for our trips page. If we look at our trips, we note that a number of the scripts, these five, are ones that we've minified. So let's add the environment, so that we have the names for development. And let's just copy these for our production, staging environments. Now this is called names and it takes two because it is going to support any of these environments. And of course here we'll just change it by replacing .js with lib app and just copy that and just fix all these up so that in production or staging, we're going to use the more efficient ones. Let's save that and let's see it in the browser. So we've come over to the trips page and even though we're using the minified versions, We're seeing that there's probably an error. And the error is that it's having problems with the injector. The minification that Uglify does doesn't play well with the style of Angular that we're working with, and so there's actually a special project to support that. Let's talk about that for a minute just so you can see why that's important. If we look at one of our controllers, so this is going to be the same for most of our Angular code, we can see the real problem. So our function here is using the names of these parameters as an indicator of how to supply those parameters. It's looking up the built-in route params and the built-in HTTP object to pass in. But when we minify this, part of that minification process is making these one-letter parameter names, it's one of the techniques it uses to make it nice and small, so we need a way to indicate to the code here with the types of those parameters we want and so the trick here is we could certainly do this by hand, but the easier thing to do is to include another project in our Gulp process. Let's do that next.

Minifying AngularJS Code

Now let's see how to minify the Angular JS code that wasn't playing nice with the old minification. We'll start down here in the package.json again because we're going to need another Gulp package, and this one's called gulp-ng-annotate. The gulp-ng-annotate is simply another Gulp task that will annotate the code with the parameter names so that when we minify it, it'll do the right thing. So let's going to and change the Gulp file to include that. We'll first need to get the ngAnnotate by calling require. And then before we Uglify it, we'll pipe all the files through and use ngAnnotate to annotate it with those parameter names as necessary. So we build it, and then refresh our code back at trips, we can see it's all working well now, even though our controllers and directives are all now simply using the minified versions. We continue to have a working application even with the minification and Angular. The minification is a good example of when to use the different kinds of environments you might want like development, production and staging in your own applications. But we can actually get it this information directly on the configuration of our application to set up the way that your application works in different ways. Let's do that next.

Readying for Deployment

So now let's start to get our project ready for actual deployment. We're going to go ahead and open up our project.json, and there's a section in here that we haven't included yet but luckily we can add pretty easily called scripts. Notice we're getting IntelliSense for this project json file and that'll make it a little easier because we aren't going to start with a command called prepublish. Prepublish is used to execute certain scripts during a deployment process. So when you're deploying this, you might be missing some of those dependencies. The ASP.NET project itself will handle the new dependency problem, but because we're using bower and now we're using NPM for other dependencies, we have to have a way to specify how to get those dependencies fulfilled, and that's where prepublish comes in. Prepublish is going to allow us to specify an array of commands to run. And so the first of these is going to be npm install. Now NPM is the command line tool that takes the package.json and loads up those dependencies. In our case, that is these Gulps dependencies, though this will probably grow over time. We also need to do the same thing with bower. We want to go ahead and install all the bower dependencies because we're probably not going to check in that lib folder into our source control, so when we deploy this, it'll go ahead and get all those dependencies for NPM and for bower after the project system had already got the dependencies for .NET, all of the NuGet packages. In addition to prepublish, we'll probably going to also want to have another script for prepare. Prepare is going to be executed after prepublish and will allow you to run other scripts. In this case, we only have one so I'm not going to use an array here, I'll just use a simple string. And here I'll say gulp minify. This is essentially telling it to run the Gulp minification process or anything else you want to include here before the application is ready to be executed. This is really important when you're starting to deploy these on remote or foreign sites. Now you might wonder why do I need this when I already tied this to the after build? And that's because Visual Studio is not necessarily going to be running or executing these operations. There's other tooling that does this and they don't know about these task runner bindings. These are purely bindings for Visual Studio to use during the process of development. So we end up having to do them twice. So now that we have these scripts defined, we can actually deploy these projects. Let's see how to do that next.

Publishing with Visual Studio

So first let's talk about how we publish with Visual Studio. Here in our project, we can go up to the web node, the project node, and just pick publish. We can pick to publish directly to an Azure app service, which used to be called websites. We can import a profile for exporting, or let's just do it in the file system so we know what it's like. We'll just call it file publish and I'm going to pick a directory. I'll pick one that is well known to me, and I'll call this our TheWorld folder. And here I'm going to tell it what version of the framework to use, what runtime, and also what configuration release or debug. When I go ahead and run publish, this is going to build the project, build any of those pre or post publish scripts and then package the whole project into that folder. So let's open up that folder. And this is the folder we get. And if we open up that folder, we're going to see that it's going to include all those assemblies that we need to actually run our application. This is going to include any assemblies and the dependencies they have, and it has built our project into a DLL. I'll show you how you can run this in just a moment. If we look at the top to the directories, there's still a directory for wwwroot. This is where all those files in our original project got put, so all of the client-side static files are put into a directory called wwwroot. So now that we have the project, we can just go dotnet and then the name of the DLL, the complete name, TheWorld plus .dll. We can see that it's thrown an exception, and the exception is it's missing the config.json file because we would acquire it to use the database, we need to do something different here. So let's go back to the project and let's go ahead and look at the project.json file. Near the bottom of the project.json, there's going to be a section called publish options with another section inside of it called include. And these are the things that are going to be included when we publish our project. Now it already is including the wwwroot. We saw that in the project, as well as the web.config in case we're going to put it inside of IIS. But what we also need are the views and the config.json. Config.json is what it said it was complaining about, and we know that we need the actual view files. If you have any other files in the system that aren't in wwwroot, you'll need to include them here as well if you have templates for emails or other sorts of files you're using or even just some flat files or other configurations. You'll need to figure out where you'll want to put those. We add it by just adding the entries here. So I'm going to say views to get that entire folder. In here I'll say config.json to get our configuration file. We'll go ahead and just publish it again into the same directory. And going back to Explorer, we can now see the views folder was added, as well as that config.json. So here in the command prompt, if we just repeat that dotnet and then the assembly name, we can see it's correctly running because we don't have the ASP.NET core_environment set. It's defaulted to production. So let's see if this will actually work in the browser. We're getting an unable to connect because you can see it's redirected to https because we were adding the filter in our project to go to https in production builds. And this is what we'd want to go to go to actual production. But because we're still testing it, let's make a small change. So now that we've stopped it, let's just change that ASPNETCORE_ENVIRONMENT variable to Testing, more development if you prefer. And we should be able to run it again and we'll think it's a testing environment. And if we refresh, we should get the application actually running from the command line like we want. We could do this to serve pages from the command line pretty much anywhere. This could be in a virtual machine running in the cloud, this could be in a docker image, this could just be on an ad hoc server that you didn't want to necessarily run a full IAS on. And of course, this could be on a Linux or a Mac as well. Let's see how to use the command line to do the same thing so it's scriptable.

Publishing with the Command-line

Now let's see how to publish your application using the command line. So here in our project folder, we can use that same dotnet command to publish our project. And using this alone will create a new publish directory in our project, but I'm going to put it on the desktop again just so we can go and play with that folder. I can do that with -o and then the name, then the path I want to publish to. And I'll call this TheWorld2 this time. So this effectively did the same thing that we saw before. Let's go over to our new directory and we can see that it brought in the views and the config.json as well. So it's using those same files to determine the publish. And in fact, the Visual Studio extensions are just running the same command for us. So if we come in here and say dotnet TheWorld.dll, we can continue to serve those same pages, it's the same code effectively, but we do have another option. Let's go back to the project file and we can add a new section called runtimes. This is going to give us the ability to pick a runtime that we're going to build against. This is to create a completely self-contained version of our project. And there are a series of runtimes and you can include more than one, but we're just going to include the x64 version of the Win 8.1 runtime. There's also a Win 10 and a Win 7 version of these same runtimes, as well as different flavors for Mac and Linux. By telling it this runtime, I'm also telling it, it's going to be self-contained so I can get rid of this platform line in the .NETCore app. Because this is no longer a platform, this is actually just the dependencies for a .NetCore App in a portable way. So with this change, let's go back to the command line. I will go back to that same publish, but let's put it in a new directory, TheWorld3. And I also want to add a runtime, and the reason I'm specifying the runtime is I want to tell it to take our entire project and the complete.net core runtime and put it all in one directory for me. By doing this, I'm creating a directory that I can literally copy on to any machine that supports that runtimes. So any Windows box that supports Windows 8.1 or above, or if was using a Linux runtime, any Linux box that supported that version of Linux and be able to just execute it without installing any prerequisites. So I'll put win81-x64, which was the runtime name, and let's go to that new directory. And let's see what's in it. One thing you'll see is TheWorld.exe, as well as, say, TheWorld.dll. Remember we were using .NET, TheWorld.dll to actually execute the project. But in this case, this runs without having any external dependencies. So we can actually run this The World.exe, and this is a little bit of a magic hack. This, TheWorld.exe, will be different depending on the runtime. If you're running on a Mac, it's going to be a Mac executable. If it's running on a Linux, it's going to be a Linux executable. It's only exe because we're actually focused on a Windows executable. And this Windows executable is actually just the .NET tooling that's going to allow it to run the TheWorld.dll. So your code doesn't actually exist in the world.exe. It's sort of a parlor trick, but it's an effective one because I can now just say the world, and I can run this. And I could copy this to any Windows machine and that Windows machine does not need a version of the .NET Framework on it because I'm using .Net Core in this instance. Remember, we could use desktop.net as well, but this is giving us the ability to have a specific version of runtime bundled with our app so that as the runtime changes, we can version it with our project. That becomes a very useful tool when you're thinking about lots of small projects or micro services where you want to be able to deliver them and version them separately instead of having these monolithic applications that we've always built. Let's wrap up this module.

Summary

Well, if you've made it this far, you've viewed quite a long course on building a web app from really the ground up. I want to thank you for sticking with me through the entire process. In this module, we learned about ASP.NET deployment, and that include using tools like Gulp to simplify those preparations, doing things like minifying your JavaScript code is just the tip of that iceberg. There's certainly other tasks that you may want to take on like optimizing the images in your project, using lesser sass to compile into your CSS for the project, or even packaging your multiple JavaScripts and CSS into smaller numbers or files. All of that are tasks that Gulp can do really well. I showed you how to use the angular annotations project in order to handle minification directly for Angular JS code. And then we talked about using the command line or Visual Studio to deploy your applications. Where you end up hosting your applications has less to do with how you're packaging these up. The end of just being simple file directories that can be zipped up and dropped on a file server someplace. This has been Shawn Wildermuth of Wilder Minds. Thanks for watching Building a Web App with ASP.NET Core 1.0.